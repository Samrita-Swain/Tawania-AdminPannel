
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model WarehouseZone
 * 
 */
export type WarehouseZone = $Result.DefaultSelection<Prisma.$WarehouseZonePayload>
/**
 * Model WarehouseAisle
 * 
 */
export type WarehouseAisle = $Result.DefaultSelection<Prisma.$WarehouseAislePayload>
/**
 * Model WarehouseShelf
 * 
 */
export type WarehouseShelf = $Result.DefaultSelection<Prisma.$WarehouseShelfPayload>
/**
 * Model WarehouseBin
 * 
 */
export type WarehouseBin = $Result.DefaultSelection<Prisma.$WarehouseBinPayload>
/**
 * Model WarehouseStaff
 * 
 */
export type WarehouseStaff = $Result.DefaultSelection<Prisma.$WarehouseStaffPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model StoreStaff
 * 
 */
export type StoreStaff = $Result.DefaultSelection<Prisma.$StoreStaffPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SupplierContract
 * 
 */
export type SupplierContract = $Result.DefaultSelection<Prisma.$SupplierContractPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleItem
 * 
 */
export type SaleItem = $Result.DefaultSelection<Prisma.$SaleItemPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model TransferItem
 * 
 */
export type TransferItem = $Result.DefaultSelection<Prisma.$TransferItemPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model LoyaltyProgram
 * 
 */
export type LoyaltyProgram = $Result.DefaultSelection<Prisma.$LoyaltyProgramPayload>
/**
 * Model LoyaltyProgramTier
 * 
 */
export type LoyaltyProgramTier = $Result.DefaultSelection<Prisma.$LoyaltyProgramTierPayload>
/**
 * Model LoyaltyTransaction
 * 
 */
export type LoyaltyTransaction = $Result.DefaultSelection<Prisma.$LoyaltyTransactionPayload>
/**
 * Model Audit
 * 
 */
export type Audit = $Result.DefaultSelection<Prisma.$AuditPayload>
/**
 * Model AuditItem
 * 
 */
export type AuditItem = $Result.DefaultSelection<Prisma.$AuditItemPayload>
/**
 * Model AuditAssignment
 * 
 */
export type AuditAssignment = $Result.DefaultSelection<Prisma.$AuditAssignmentPayload>
/**
 * Model CustomerGroup
 * 
 */
export type CustomerGroup = $Result.DefaultSelection<Prisma.$CustomerGroupPayload>
/**
 * Model CustomerNote
 * 
 */
export type CustomerNote = $Result.DefaultSelection<Prisma.$CustomerNotePayload>
/**
 * Model CustomerPromotion
 * 
 */
export type CustomerPromotion = $Result.DefaultSelection<Prisma.$CustomerPromotionPayload>
/**
 * Model CustomerToGroup
 * 
 */
export type CustomerToGroup = $Result.DefaultSelection<Prisma.$CustomerToGroupPayload>
/**
 * Model LoyaltyProgramRule
 * 
 */
export type LoyaltyProgramRule = $Result.DefaultSelection<Prisma.$LoyaltyProgramRulePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model PromotionRedemption
 * 
 */
export type PromotionRedemption = $Result.DefaultSelection<Prisma.$PromotionRedemptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  WAREHOUSE_STAFF: 'WAREHOUSE_STAFF',
  STORE_MANAGER: 'STORE_MANAGER',
  STORE_STAFF: 'STORE_STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContractStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  TERMINATED: 'TERMINATED',
  RENEWAL_PENDING: 'RENEWAL_PENDING'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const PerformanceMetricType: {
  ON_TIME_DELIVERY: 'ON_TIME_DELIVERY',
  QUALITY: 'QUALITY',
  PRICE_COMPETITIVENESS: 'PRICE_COMPETITIVENESS',
  RESPONSIVENESS: 'RESPONSIVENESS',
  LEAD_TIME: 'LEAD_TIME'
};

export type PerformanceMetricType = (typeof PerformanceMetricType)[keyof typeof PerformanceMetricType]


export const PurchaseOrderStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  ORDERED: 'ORDERED',
  PARTIALLY_RECEIVED: 'PARTIALLY_RECEIVED',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseOrderStatus = (typeof PurchaseOrderStatus)[keyof typeof PurchaseOrderStatus]


export const InventoryStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  DAMAGED: 'DAMAGED',
  EXPIRED: 'EXPIRED',
  IN_TRANSIT: 'IN_TRANSIT',
  QUARANTINE: 'QUARANTINE',
  RETURNED: 'RETURNED',
  OUT_OF_STOCK: 'OUT_OF_STOCK'
};

export type InventoryStatus = (typeof InventoryStatus)[keyof typeof InventoryStatus]


export const InventoryMethod: {
  FIFO: 'FIFO',
  LIFO: 'LIFO',
  FEFO: 'FEFO',
  AVERAGE_COST: 'AVERAGE_COST'
};

export type InventoryMethod = (typeof InventoryMethod)[keyof typeof InventoryMethod]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  MOBILE_PAYMENT: 'MOBILE_PAYMENT',
  LOYALTY_POINTS: 'LOYALTY_POINTS',
  GIFT_CARD: 'GIFT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  REFUNDED: 'REFUNDED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ReturnStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ReturnStatus = (typeof ReturnStatus)[keyof typeof ReturnStatus]


export const RefundMethod: {
  ORIGINAL_PAYMENT: 'ORIGINAL_PAYMENT',
  STORE_CREDIT: 'STORE_CREDIT',
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type RefundMethod = (typeof RefundMethod)[keyof typeof RefundMethod]


export const RefundStatus: {
  PENDING: 'PENDING',
  PROCESSED: 'PROCESSED',
  REJECTED: 'REJECTED'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]


export const ReturnReason: {
  DEFECTIVE: 'DEFECTIVE',
  DAMAGED: 'DAMAGED',
  WRONG_ITEM: 'WRONG_ITEM',
  NOT_AS_DESCRIBED: 'NOT_AS_DESCRIBED',
  CHANGED_MIND: 'CHANGED_MIND',
  OTHER: 'OTHER'
};

export type ReturnReason = (typeof ReturnReason)[keyof typeof ReturnReason]


export const ItemCondition: {
  GOOD: 'GOOD',
  DAMAGED: 'DAMAGED',
  OPENED: 'OPENED',
  USED: 'USED'
};

export type ItemCondition = (typeof ItemCondition)[keyof typeof ItemCondition]


export const QCType: {
  RECEIVING: 'RECEIVING',
  RETURN: 'RETURN',
  RANDOM: 'RANDOM',
  COMPLAINT: 'COMPLAINT'
};

export type QCType = (typeof QCType)[keyof typeof QCType]


export const QCStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type QCStatus = (typeof QCStatus)[keyof typeof QCStatus]


export const QCItemStatus: {
  PENDING: 'PENDING',
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  PARTIALLY_PASSED: 'PARTIALLY_PASSED'
};

export type QCItemStatus = (typeof QCItemStatus)[keyof typeof QCItemStatus]


export const QCAction: {
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  REWORK: 'REWORK',
  RETURN_TO_SUPPLIER: 'RETURN_TO_SUPPLIER',
  DISPOSE: 'DISPOSE'
};

export type QCAction = (typeof QCAction)[keyof typeof QCAction]


export const TransferType: {
  WAREHOUSE_TO_WAREHOUSE: 'WAREHOUSE_TO_WAREHOUSE',
  WAREHOUSE_TO_STORE: 'WAREHOUSE_TO_STORE',
  STORE_TO_WAREHOUSE: 'STORE_TO_WAREHOUSE',
  STORE_TO_STORE: 'STORE_TO_STORE'
};

export type TransferType = (typeof TransferType)[keyof typeof TransferType]


export const TransferPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TransferPriority = (typeof TransferPriority)[keyof typeof TransferPriority]


export const TransferStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  IN_TRANSIT: 'IN_TRANSIT',
  PARTIALLY_RECEIVED: 'PARTIALLY_RECEIVED',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const AddressType: {
  SHIPPING: 'SHIPPING',
  BILLING: 'BILLING',
  BOTH: 'BOTH'
};

export type AddressType = (typeof AddressType)[keyof typeof AddressType]


export const LoyaltyTransactionType: {
  EARN: 'EARN',
  REDEEM: 'REDEEM',
  ADJUSTMENT: 'ADJUSTMENT',
  EXPIRY: 'EXPIRY'
};

export type LoyaltyTransactionType = (typeof LoyaltyTransactionType)[keyof typeof LoyaltyTransactionType]


export const LoyaltyTier: {
  STANDARD: 'STANDARD',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type LoyaltyTier = (typeof LoyaltyTier)[keyof typeof LoyaltyTier]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  TRANSFER: 'TRANSFER',
  ADJUSTMENT: 'ADJUSTMENT',
  SALE: 'SALE',
  RETURN: 'RETURN',
  APPROVAL: 'APPROVAL',
  REJECTION: 'REJECTION'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditStatus: {
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const AuditItemStatus: {
  PENDING: 'PENDING',
  COUNTED: 'COUNTED',
  RECONCILED: 'RECONCILED',
  DISCREPANCY: 'DISCREPANCY'
};

export type AuditItemStatus = (typeof AuditItemStatus)[keyof typeof AuditItemStatus]


export const AssignmentStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]


export const ProductCondition: {
  NEW: 'NEW',
  DAMAGED: 'DAMAGED'
};

export type ProductCondition = (typeof ProductCondition)[keyof typeof ProductCondition]


export const LoyaltyRuleType: {
  PURCHASE: 'PURCHASE',
  FIRST_PURCHASE: 'FIRST_PURCHASE',
  BIRTHDAY: 'BIRTHDAY',
  REFERRAL: 'REFERRAL',
  PRODUCT_CATEGORY: 'PRODUCT_CATEGORY',
  SPECIFIC_PRODUCT: 'SPECIFIC_PRODUCT',
  PURCHASE_FREQUENCY: 'PURCHASE_FREQUENCY',
  CUSTOM: 'CUSTOM'
};

export type LoyaltyRuleType = (typeof LoyaltyRuleType)[keyof typeof LoyaltyRuleType]


export const NotificationType: {
  TRANSFER_REQUEST: 'TRANSFER_REQUEST',
  TRANSFER_APPROVAL: 'TRANSFER_APPROVAL',
  TRANSFER_REJECTION: 'TRANSFER_REJECTION',
  TRANSFER_RECEIVED: 'TRANSFER_RECEIVED',
  LOW_STOCK: 'LOW_STOCK',
  STOCK_EXPIRING: 'STOCK_EXPIRING',
  AUDIT_ASSIGNED: 'AUDIT_ASSIGNED',
  AUDIT_COMPLETED: 'AUDIT_COMPLETED',
  PURCHASE_ORDER: 'PURCHASE_ORDER',
  SYSTEM: 'SYSTEM',
  LOYALTY_POINTS_EARNED: 'LOYALTY_POINTS_EARNED',
  LOYALTY_POINTS_REDEEMED: 'LOYALTY_POINTS_REDEEMED',
  LOYALTY_TIER_CHANGED: 'LOYALTY_TIER_CHANGED',
  PROMOTION_AVAILABLE: 'PROMOTION_AVAILABLE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const PromotionType: {
  DISCOUNT_AMOUNT: 'DISCOUNT_AMOUNT',
  DISCOUNT_PERCENTAGE: 'DISCOUNT_PERCENTAGE',
  FREE_SHIPPING: 'FREE_SHIPPING',
  BUY_X_GET_Y: 'BUY_X_GET_Y',
  BUNDLE_DISCOUNT: 'BUNDLE_DISCOUNT',
  LOYALTY_POINTS_MULTIPLIER: 'LOYALTY_POINTS_MULTIPLIER'
};

export type PromotionType = (typeof PromotionType)[keyof typeof PromotionType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type PerformanceMetricType = $Enums.PerformanceMetricType

export const PerformanceMetricType: typeof $Enums.PerformanceMetricType

export type PurchaseOrderStatus = $Enums.PurchaseOrderStatus

export const PurchaseOrderStatus: typeof $Enums.PurchaseOrderStatus

export type InventoryStatus = $Enums.InventoryStatus

export const InventoryStatus: typeof $Enums.InventoryStatus

export type InventoryMethod = $Enums.InventoryMethod

export const InventoryMethod: typeof $Enums.InventoryMethod

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ReturnStatus = $Enums.ReturnStatus

export const ReturnStatus: typeof $Enums.ReturnStatus

export type RefundMethod = $Enums.RefundMethod

export const RefundMethod: typeof $Enums.RefundMethod

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

export type ReturnReason = $Enums.ReturnReason

export const ReturnReason: typeof $Enums.ReturnReason

export type ItemCondition = $Enums.ItemCondition

export const ItemCondition: typeof $Enums.ItemCondition

export type QCType = $Enums.QCType

export const QCType: typeof $Enums.QCType

export type QCStatus = $Enums.QCStatus

export const QCStatus: typeof $Enums.QCStatus

export type QCItemStatus = $Enums.QCItemStatus

export const QCItemStatus: typeof $Enums.QCItemStatus

export type QCAction = $Enums.QCAction

export const QCAction: typeof $Enums.QCAction

export type TransferType = $Enums.TransferType

export const TransferType: typeof $Enums.TransferType

export type TransferPriority = $Enums.TransferPriority

export const TransferPriority: typeof $Enums.TransferPriority

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type AddressType = $Enums.AddressType

export const AddressType: typeof $Enums.AddressType

export type LoyaltyTransactionType = $Enums.LoyaltyTransactionType

export const LoyaltyTransactionType: typeof $Enums.LoyaltyTransactionType

export type LoyaltyTier = $Enums.LoyaltyTier

export const LoyaltyTier: typeof $Enums.LoyaltyTier

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type AuditItemStatus = $Enums.AuditItemStatus

export const AuditItemStatus: typeof $Enums.AuditItemStatus

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

export type ProductCondition = $Enums.ProductCondition

export const ProductCondition: typeof $Enums.ProductCondition

export type LoyaltyRuleType = $Enums.LoyaltyRuleType

export const LoyaltyRuleType: typeof $Enums.LoyaltyRuleType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type PromotionType = $Enums.PromotionType

export const PromotionType: typeof $Enums.PromotionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseZone`: Exposes CRUD operations for the **WarehouseZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseZones
    * const warehouseZones = await prisma.warehouseZone.findMany()
    * ```
    */
  get warehouseZone(): Prisma.WarehouseZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseAisle`: Exposes CRUD operations for the **WarehouseAisle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseAisles
    * const warehouseAisles = await prisma.warehouseAisle.findMany()
    * ```
    */
  get warehouseAisle(): Prisma.WarehouseAisleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseShelf`: Exposes CRUD operations for the **WarehouseShelf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseShelves
    * const warehouseShelves = await prisma.warehouseShelf.findMany()
    * ```
    */
  get warehouseShelf(): Prisma.WarehouseShelfDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseBin`: Exposes CRUD operations for the **WarehouseBin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseBins
    * const warehouseBins = await prisma.warehouseBin.findMany()
    * ```
    */
  get warehouseBin(): Prisma.WarehouseBinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseStaff`: Exposes CRUD operations for the **WarehouseStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseStaffs
    * const warehouseStaffs = await prisma.warehouseStaff.findMany()
    * ```
    */
  get warehouseStaff(): Prisma.WarehouseStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storeStaff`: Exposes CRUD operations for the **StoreStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreStaffs
    * const storeStaffs = await prisma.storeStaff.findMany()
    * ```
    */
  get storeStaff(): Prisma.StoreStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierContract`: Exposes CRUD operations for the **SupplierContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierContracts
    * const supplierContracts = await prisma.supplierContract.findMany()
    * ```
    */
  get supplierContract(): Prisma.SupplierContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleItem`: Exposes CRUD operations for the **SaleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleItems
    * const saleItems = await prisma.saleItem.findMany()
    * ```
    */
  get saleItem(): Prisma.SaleItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferItem`: Exposes CRUD operations for the **TransferItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferItems
    * const transferItems = await prisma.transferItem.findMany()
    * ```
    */
  get transferItem(): Prisma.TransferItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyProgram`: Exposes CRUD operations for the **LoyaltyProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyPrograms
    * const loyaltyPrograms = await prisma.loyaltyProgram.findMany()
    * ```
    */
  get loyaltyProgram(): Prisma.LoyaltyProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyProgramTier`: Exposes CRUD operations for the **LoyaltyProgramTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyProgramTiers
    * const loyaltyProgramTiers = await prisma.loyaltyProgramTier.findMany()
    * ```
    */
  get loyaltyProgramTier(): Prisma.LoyaltyProgramTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyTransaction`: Exposes CRUD operations for the **LoyaltyTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyTransactions
    * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
    * ```
    */
  get loyaltyTransaction(): Prisma.LoyaltyTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit`: Exposes CRUD operations for the **Audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audit.findMany()
    * ```
    */
  get audit(): Prisma.AuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditItem`: Exposes CRUD operations for the **AuditItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditItems
    * const auditItems = await prisma.auditItem.findMany()
    * ```
    */
  get auditItem(): Prisma.AuditItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditAssignment`: Exposes CRUD operations for the **AuditAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditAssignments
    * const auditAssignments = await prisma.auditAssignment.findMany()
    * ```
    */
  get auditAssignment(): Prisma.AuditAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerGroup`: Exposes CRUD operations for the **CustomerGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerGroups
    * const customerGroups = await prisma.customerGroup.findMany()
    * ```
    */
  get customerGroup(): Prisma.CustomerGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerNote`: Exposes CRUD operations for the **CustomerNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerNotes
    * const customerNotes = await prisma.customerNote.findMany()
    * ```
    */
  get customerNote(): Prisma.CustomerNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPromotion`: Exposes CRUD operations for the **CustomerPromotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPromotions
    * const customerPromotions = await prisma.customerPromotion.findMany()
    * ```
    */
  get customerPromotion(): Prisma.CustomerPromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerToGroup`: Exposes CRUD operations for the **CustomerToGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerToGroups
    * const customerToGroups = await prisma.customerToGroup.findMany()
    * ```
    */
  get customerToGroup(): Prisma.CustomerToGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyProgramRule`: Exposes CRUD operations for the **LoyaltyProgramRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyProgramRules
    * const loyaltyProgramRules = await prisma.loyaltyProgramRule.findMany()
    * ```
    */
  get loyaltyProgramRule(): Prisma.LoyaltyProgramRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotionRedemption`: Exposes CRUD operations for the **PromotionRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionRedemptions
    * const promotionRedemptions = await prisma.promotionRedemption.findMany()
    * ```
    */
  get promotionRedemption(): Prisma.PromotionRedemptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Warehouse: 'Warehouse',
    WarehouseZone: 'WarehouseZone',
    WarehouseAisle: 'WarehouseAisle',
    WarehouseShelf: 'WarehouseShelf',
    WarehouseBin: 'WarehouseBin',
    WarehouseStaff: 'WarehouseStaff',
    Store: 'Store',
    StoreStaff: 'StoreStaff',
    Supplier: 'Supplier',
    SupplierContract: 'SupplierContract',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    Product: 'Product',
    Category: 'Category',
    InventoryItem: 'InventoryItem',
    Sale: 'Sale',
    SaleItem: 'SaleItem',
    Transfer: 'Transfer',
    TransferItem: 'TransferItem',
    Customer: 'Customer',
    CustomerAddress: 'CustomerAddress',
    LoyaltyProgram: 'LoyaltyProgram',
    LoyaltyProgramTier: 'LoyaltyProgramTier',
    LoyaltyTransaction: 'LoyaltyTransaction',
    Audit: 'Audit',
    AuditItem: 'AuditItem',
    AuditAssignment: 'AuditAssignment',
    CustomerGroup: 'CustomerGroup',
    CustomerNote: 'CustomerNote',
    CustomerPromotion: 'CustomerPromotion',
    CustomerToGroup: 'CustomerToGroup',
    LoyaltyProgramRule: 'LoyaltyProgramRule',
    Notification: 'Notification',
    PromotionRedemption: 'PromotionRedemption'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "warehouse" | "warehouseZone" | "warehouseAisle" | "warehouseShelf" | "warehouseBin" | "warehouseStaff" | "store" | "storeStaff" | "supplier" | "supplierContract" | "purchaseOrder" | "purchaseOrderItem" | "product" | "category" | "inventoryItem" | "sale" | "saleItem" | "transfer" | "transferItem" | "customer" | "customerAddress" | "loyaltyProgram" | "loyaltyProgramTier" | "loyaltyTransaction" | "audit" | "auditItem" | "auditAssignment" | "customerGroup" | "customerNote" | "customerPromotion" | "customerToGroup" | "loyaltyProgramRule" | "notification" | "promotionRedemption"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      WarehouseZone: {
        payload: Prisma.$WarehouseZonePayload<ExtArgs>
        fields: Prisma.WarehouseZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          findFirst: {
            args: Prisma.WarehouseZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          findMany: {
            args: Prisma.WarehouseZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>[]
          }
          create: {
            args: Prisma.WarehouseZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          createMany: {
            args: Prisma.WarehouseZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>[]
          }
          delete: {
            args: Prisma.WarehouseZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          update: {
            args: Prisma.WarehouseZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          aggregate: {
            args: Prisma.WarehouseZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseZone>
          }
          groupBy: {
            args: Prisma.WarehouseZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseZoneCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseZoneCountAggregateOutputType> | number
          }
        }
      }
      WarehouseAisle: {
        payload: Prisma.$WarehouseAislePayload<ExtArgs>
        fields: Prisma.WarehouseAisleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseAisleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseAisleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          findFirst: {
            args: Prisma.WarehouseAisleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseAisleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          findMany: {
            args: Prisma.WarehouseAisleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>[]
          }
          create: {
            args: Prisma.WarehouseAisleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          createMany: {
            args: Prisma.WarehouseAisleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseAisleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>[]
          }
          delete: {
            args: Prisma.WarehouseAisleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          update: {
            args: Prisma.WarehouseAisleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseAisleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseAisleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseAisleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseAisleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAisleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseAisle>
          }
          groupBy: {
            args: Prisma.WarehouseAisleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseAisleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseAisleCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseAisleCountAggregateOutputType> | number
          }
        }
      }
      WarehouseShelf: {
        payload: Prisma.$WarehouseShelfPayload<ExtArgs>
        fields: Prisma.WarehouseShelfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseShelfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseShelfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          findFirst: {
            args: Prisma.WarehouseShelfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseShelfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          findMany: {
            args: Prisma.WarehouseShelfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>[]
          }
          create: {
            args: Prisma.WarehouseShelfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          createMany: {
            args: Prisma.WarehouseShelfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseShelfCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>[]
          }
          delete: {
            args: Prisma.WarehouseShelfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          update: {
            args: Prisma.WarehouseShelfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseShelfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseShelfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseShelfUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>[]
          }
          upsert: {
            args: Prisma.WarehouseShelfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          aggregate: {
            args: Prisma.WarehouseShelfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseShelf>
          }
          groupBy: {
            args: Prisma.WarehouseShelfGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseShelfGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseShelfCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseShelfCountAggregateOutputType> | number
          }
        }
      }
      WarehouseBin: {
        payload: Prisma.$WarehouseBinPayload<ExtArgs>
        fields: Prisma.WarehouseBinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseBinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseBinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          findFirst: {
            args: Prisma.WarehouseBinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseBinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          findMany: {
            args: Prisma.WarehouseBinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>[]
          }
          create: {
            args: Prisma.WarehouseBinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          createMany: {
            args: Prisma.WarehouseBinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseBinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>[]
          }
          delete: {
            args: Prisma.WarehouseBinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          update: {
            args: Prisma.WarehouseBinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseBinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseBinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseBinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>[]
          }
          upsert: {
            args: Prisma.WarehouseBinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          aggregate: {
            args: Prisma.WarehouseBinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseBin>
          }
          groupBy: {
            args: Prisma.WarehouseBinGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseBinGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseBinCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseBinCountAggregateOutputType> | number
          }
        }
      }
      WarehouseStaff: {
        payload: Prisma.$WarehouseStaffPayload<ExtArgs>
        fields: Prisma.WarehouseStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          findFirst: {
            args: Prisma.WarehouseStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          findMany: {
            args: Prisma.WarehouseStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>[]
          }
          create: {
            args: Prisma.WarehouseStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          createMany: {
            args: Prisma.WarehouseStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>[]
          }
          delete: {
            args: Prisma.WarehouseStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          update: {
            args: Prisma.WarehouseStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>[]
          }
          upsert: {
            args: Prisma.WarehouseStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          aggregate: {
            args: Prisma.WarehouseStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseStaff>
          }
          groupBy: {
            args: Prisma.WarehouseStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseStaffCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseStaffCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      StoreStaff: {
        payload: Prisma.$StoreStaffPayload<ExtArgs>
        fields: Prisma.StoreStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          findFirst: {
            args: Prisma.StoreStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          findMany: {
            args: Prisma.StoreStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>[]
          }
          create: {
            args: Prisma.StoreStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          createMany: {
            args: Prisma.StoreStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>[]
          }
          delete: {
            args: Prisma.StoreStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          update: {
            args: Prisma.StoreStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          deleteMany: {
            args: Prisma.StoreStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>[]
          }
          upsert: {
            args: Prisma.StoreStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          aggregate: {
            args: Prisma.StoreStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreStaff>
          }
          groupBy: {
            args: Prisma.StoreStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreStaffCountArgs<ExtArgs>
            result: $Utils.Optional<StoreStaffCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierContract: {
        payload: Prisma.$SupplierContractPayload<ExtArgs>
        fields: Prisma.SupplierContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          findFirst: {
            args: Prisma.SupplierContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          findMany: {
            args: Prisma.SupplierContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>[]
          }
          create: {
            args: Prisma.SupplierContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          createMany: {
            args: Prisma.SupplierContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>[]
          }
          delete: {
            args: Prisma.SupplierContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          update: {
            args: Prisma.SupplierContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          deleteMany: {
            args: Prisma.SupplierContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>[]
          }
          upsert: {
            args: Prisma.SupplierContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          aggregate: {
            args: Prisma.SupplierContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierContract>
          }
          groupBy: {
            args: Prisma.SupplierContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierContractCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierContractCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleItem: {
        payload: Prisma.$SaleItemPayload<ExtArgs>
        fields: Prisma.SaleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findFirst: {
            args: Prisma.SaleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findMany: {
            args: Prisma.SaleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          create: {
            args: Prisma.SaleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          createMany: {
            args: Prisma.SaleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          delete: {
            args: Prisma.SaleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          update: {
            args: Prisma.SaleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          deleteMany: {
            args: Prisma.SaleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          upsert: {
            args: Prisma.SaleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          aggregate: {
            args: Prisma.SaleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleItem>
          }
          groupBy: {
            args: Prisma.SaleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleItemCountArgs<ExtArgs>
            result: $Utils.Optional<SaleItemCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      TransferItem: {
        payload: Prisma.$TransferItemPayload<ExtArgs>
        fields: Prisma.TransferItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          findFirst: {
            args: Prisma.TransferItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          findMany: {
            args: Prisma.TransferItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          create: {
            args: Prisma.TransferItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          createMany: {
            args: Prisma.TransferItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          delete: {
            args: Prisma.TransferItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          update: {
            args: Prisma.TransferItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          deleteMany: {
            args: Prisma.TransferItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          upsert: {
            args: Prisma.TransferItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          aggregate: {
            args: Prisma.TransferItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferItem>
          }
          groupBy: {
            args: Prisma.TransferItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransferItemCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyProgram: {
        payload: Prisma.$LoyaltyProgramPayload<ExtArgs>
        fields: Prisma.LoyaltyProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          findMany: {
            args: Prisma.LoyaltyProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>[]
          }
          create: {
            args: Prisma.LoyaltyProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          createMany: {
            args: Prisma.LoyaltyProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          update: {
            args: Prisma.LoyaltyProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyProgram>
          }
          groupBy: {
            args: Prisma.LoyaltyProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyProgramCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyProgramTier: {
        payload: Prisma.$LoyaltyProgramTierPayload<ExtArgs>
        fields: Prisma.LoyaltyProgramTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyProgramTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyProgramTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyProgramTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyProgramTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          findMany: {
            args: Prisma.LoyaltyProgramTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>[]
          }
          create: {
            args: Prisma.LoyaltyProgramTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          createMany: {
            args: Prisma.LoyaltyProgramTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyProgramTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyProgramTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          update: {
            args: Prisma.LoyaltyProgramTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyProgramTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyProgramTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyProgramTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyProgramTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyProgramTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyProgramTier>
          }
          groupBy: {
            args: Prisma.LoyaltyProgramTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyProgramTierCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramTierCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyTransaction: {
        payload: Prisma.$LoyaltyTransactionPayload<ExtArgs>
        fields: Prisma.LoyaltyTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          findMany: {
            args: Prisma.LoyaltyTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
          }
          create: {
            args: Prisma.LoyaltyTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          createMany: {
            args: Prisma.LoyaltyTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          update: {
            args: Prisma.LoyaltyTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyTransaction>
          }
          groupBy: {
            args: Prisma.LoyaltyTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyTransactionCountAggregateOutputType> | number
          }
        }
      }
      Audit: {
        payload: Prisma.$AuditPayload<ExtArgs>
        fields: Prisma.AuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findFirst: {
            args: Prisma.AuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findMany: {
            args: Prisma.AuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          create: {
            args: Prisma.AuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          createMany: {
            args: Prisma.AuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          delete: {
            args: Prisma.AuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          update: {
            args: Prisma.AuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          deleteMany: {
            args: Prisma.AuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          upsert: {
            args: Prisma.AuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          aggregate: {
            args: Prisma.AuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit>
          }
          groupBy: {
            args: Prisma.AuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditCountArgs<ExtArgs>
            result: $Utils.Optional<AuditCountAggregateOutputType> | number
          }
        }
      }
      AuditItem: {
        payload: Prisma.$AuditItemPayload<ExtArgs>
        fields: Prisma.AuditItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          findFirst: {
            args: Prisma.AuditItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          findMany: {
            args: Prisma.AuditItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>[]
          }
          create: {
            args: Prisma.AuditItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          createMany: {
            args: Prisma.AuditItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>[]
          }
          delete: {
            args: Prisma.AuditItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          update: {
            args: Prisma.AuditItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          deleteMany: {
            args: Prisma.AuditItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>[]
          }
          upsert: {
            args: Prisma.AuditItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          aggregate: {
            args: Prisma.AuditItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditItem>
          }
          groupBy: {
            args: Prisma.AuditItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditItemCountArgs<ExtArgs>
            result: $Utils.Optional<AuditItemCountAggregateOutputType> | number
          }
        }
      }
      AuditAssignment: {
        payload: Prisma.$AuditAssignmentPayload<ExtArgs>
        fields: Prisma.AuditAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          findFirst: {
            args: Prisma.AuditAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          findMany: {
            args: Prisma.AuditAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>[]
          }
          create: {
            args: Prisma.AuditAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          createMany: {
            args: Prisma.AuditAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>[]
          }
          delete: {
            args: Prisma.AuditAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          update: {
            args: Prisma.AuditAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AuditAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AuditAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          aggregate: {
            args: Prisma.AuditAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditAssignment>
          }
          groupBy: {
            args: Prisma.AuditAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AuditAssignmentCountAggregateOutputType> | number
          }
        }
      }
      CustomerGroup: {
        payload: Prisma.$CustomerGroupPayload<ExtArgs>
        fields: Prisma.CustomerGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          findFirst: {
            args: Prisma.CustomerGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          findMany: {
            args: Prisma.CustomerGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          create: {
            args: Prisma.CustomerGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          createMany: {
            args: Prisma.CustomerGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          delete: {
            args: Prisma.CustomerGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          update: {
            args: Prisma.CustomerGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          deleteMany: {
            args: Prisma.CustomerGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          upsert: {
            args: Prisma.CustomerGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          aggregate: {
            args: Prisma.CustomerGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerGroup>
          }
          groupBy: {
            args: Prisma.CustomerGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupCountAggregateOutputType> | number
          }
        }
      }
      CustomerNote: {
        payload: Prisma.$CustomerNotePayload<ExtArgs>
        fields: Prisma.CustomerNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>
          }
          findFirst: {
            args: Prisma.CustomerNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>
          }
          findMany: {
            args: Prisma.CustomerNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>[]
          }
          create: {
            args: Prisma.CustomerNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>
          }
          createMany: {
            args: Prisma.CustomerNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>[]
          }
          delete: {
            args: Prisma.CustomerNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>
          }
          update: {
            args: Prisma.CustomerNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>
          }
          deleteMany: {
            args: Prisma.CustomerNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>[]
          }
          upsert: {
            args: Prisma.CustomerNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerNotePayload>
          }
          aggregate: {
            args: Prisma.CustomerNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerNote>
          }
          groupBy: {
            args: Prisma.CustomerNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerNoteCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerNoteCountAggregateOutputType> | number
          }
        }
      }
      CustomerPromotion: {
        payload: Prisma.$CustomerPromotionPayload<ExtArgs>
        fields: Prisma.CustomerPromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>
          }
          findFirst: {
            args: Prisma.CustomerPromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>
          }
          findMany: {
            args: Prisma.CustomerPromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>[]
          }
          create: {
            args: Prisma.CustomerPromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>
          }
          createMany: {
            args: Prisma.CustomerPromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>[]
          }
          delete: {
            args: Prisma.CustomerPromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>
          }
          update: {
            args: Prisma.CustomerPromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>
          }
          deleteMany: {
            args: Prisma.CustomerPromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>[]
          }
          upsert: {
            args: Prisma.CustomerPromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPromotionPayload>
          }
          aggregate: {
            args: Prisma.CustomerPromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPromotion>
          }
          groupBy: {
            args: Prisma.CustomerPromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPromotionCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPromotionCountAggregateOutputType> | number
          }
        }
      }
      CustomerToGroup: {
        payload: Prisma.$CustomerToGroupPayload<ExtArgs>
        fields: Prisma.CustomerToGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerToGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerToGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>
          }
          findFirst: {
            args: Prisma.CustomerToGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerToGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>
          }
          findMany: {
            args: Prisma.CustomerToGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>[]
          }
          create: {
            args: Prisma.CustomerToGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>
          }
          createMany: {
            args: Prisma.CustomerToGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerToGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>[]
          }
          delete: {
            args: Prisma.CustomerToGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>
          }
          update: {
            args: Prisma.CustomerToGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>
          }
          deleteMany: {
            args: Prisma.CustomerToGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerToGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerToGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>[]
          }
          upsert: {
            args: Prisma.CustomerToGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerToGroupPayload>
          }
          aggregate: {
            args: Prisma.CustomerToGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerToGroup>
          }
          groupBy: {
            args: Prisma.CustomerToGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerToGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerToGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerToGroupCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyProgramRule: {
        payload: Prisma.$LoyaltyProgramRulePayload<ExtArgs>
        fields: Prisma.LoyaltyProgramRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyProgramRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyProgramRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>
          }
          findFirst: {
            args: Prisma.LoyaltyProgramRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyProgramRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>
          }
          findMany: {
            args: Prisma.LoyaltyProgramRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>[]
          }
          create: {
            args: Prisma.LoyaltyProgramRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>
          }
          createMany: {
            args: Prisma.LoyaltyProgramRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyProgramRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>[]
          }
          delete: {
            args: Prisma.LoyaltyProgramRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>
          }
          update: {
            args: Prisma.LoyaltyProgramRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyProgramRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyProgramRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyProgramRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyProgramRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramRulePayload>
          }
          aggregate: {
            args: Prisma.LoyaltyProgramRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyProgramRule>
          }
          groupBy: {
            args: Prisma.LoyaltyProgramRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyProgramRuleCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramRuleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      PromotionRedemption: {
        payload: Prisma.$PromotionRedemptionPayload<ExtArgs>
        fields: Prisma.PromotionRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          findFirst: {
            args: Prisma.PromotionRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          findMany: {
            args: Prisma.PromotionRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          create: {
            args: Prisma.PromotionRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          createMany: {
            args: Prisma.PromotionRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          delete: {
            args: Prisma.PromotionRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          update: {
            args: Prisma.PromotionRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRedemptionPayload>
          }
          aggregate: {
            args: Prisma.PromotionRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionRedemption>
          }
          groupBy: {
            args: Prisma.PromotionRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionRedemptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    warehouse?: WarehouseOmit
    warehouseZone?: WarehouseZoneOmit
    warehouseAisle?: WarehouseAisleOmit
    warehouseShelf?: WarehouseShelfOmit
    warehouseBin?: WarehouseBinOmit
    warehouseStaff?: WarehouseStaffOmit
    store?: StoreOmit
    storeStaff?: StoreStaffOmit
    supplier?: SupplierOmit
    supplierContract?: SupplierContractOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderItem?: PurchaseOrderItemOmit
    product?: ProductOmit
    category?: CategoryOmit
    inventoryItem?: InventoryItemOmit
    sale?: SaleOmit
    saleItem?: SaleItemOmit
    transfer?: TransferOmit
    transferItem?: TransferItemOmit
    customer?: CustomerOmit
    customerAddress?: CustomerAddressOmit
    loyaltyProgram?: LoyaltyProgramOmit
    loyaltyProgramTier?: LoyaltyProgramTierOmit
    loyaltyTransaction?: LoyaltyTransactionOmit
    audit?: AuditOmit
    auditItem?: AuditItemOmit
    auditAssignment?: AuditAssignmentOmit
    customerGroup?: CustomerGroupOmit
    customerNote?: CustomerNoteOmit
    customerPromotion?: CustomerPromotionOmit
    customerToGroup?: CustomerToGroupOmit
    loyaltyProgramRule?: LoyaltyProgramRuleOmit
    notification?: NotificationOmit
    promotionRedemption?: PromotionRedemptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    createdAudits: number
    auditAssignments: number
    CustomerNote: number
    sentNotifications: number
    receivedNotifications: number
    Product_Product_createdByIdToUser: number
    Product_Product_updatedByIdToUser: number
    PurchaseOrder_PurchaseOrder_createdByIdToUser: number
    PurchaseOrder_PurchaseOrder_updatedByIdToUser: number
    createdSales: number
    sessions: number
    Supplier_Supplier_createdByIdToUser: number
    Supplier_Supplier_updatedByIdToUser: number
    Transfer_Transfer_approvedByIdToUser: number
    Transfer_Transfer_createdByIdToUser: number
    Transfer_Transfer_receivedByIdToUser: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    createdAudits?: boolean | UserCountOutputTypeCountCreatedAuditsArgs
    auditAssignments?: boolean | UserCountOutputTypeCountAuditAssignmentsArgs
    CustomerNote?: boolean | UserCountOutputTypeCountCustomerNoteArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    receivedNotifications?: boolean | UserCountOutputTypeCountReceivedNotificationsArgs
    Product_Product_createdByIdToUser?: boolean | UserCountOutputTypeCountProduct_Product_createdByIdToUserArgs
    Product_Product_updatedByIdToUser?: boolean | UserCountOutputTypeCountProduct_Product_updatedByIdToUserArgs
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: boolean | UserCountOutputTypeCountPurchaseOrder_PurchaseOrder_createdByIdToUserArgs
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: boolean | UserCountOutputTypeCountPurchaseOrder_PurchaseOrder_updatedByIdToUserArgs
    createdSales?: boolean | UserCountOutputTypeCountCreatedSalesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    Supplier_Supplier_createdByIdToUser?: boolean | UserCountOutputTypeCountSupplier_Supplier_createdByIdToUserArgs
    Supplier_Supplier_updatedByIdToUser?: boolean | UserCountOutputTypeCountSupplier_Supplier_updatedByIdToUserArgs
    Transfer_Transfer_approvedByIdToUser?: boolean | UserCountOutputTypeCountTransfer_Transfer_approvedByIdToUserArgs
    Transfer_Transfer_createdByIdToUser?: boolean | UserCountOutputTypeCountTransfer_Transfer_createdByIdToUserArgs
    Transfer_Transfer_receivedByIdToUser?: boolean | UserCountOutputTypeCountTransfer_Transfer_receivedByIdToUserArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomerNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProduct_Product_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProduct_Product_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseOrder_PurchaseOrder_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchaseOrder_PurchaseOrder_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupplier_Supplier_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupplier_Supplier_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransfer_Transfer_approvedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransfer_Transfer_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransfer_Transfer_receivedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    audits: number
    inventoryItems: number
    purchaseOrders: number
    Transfer_Transfer_destinationWarehouseIdToWarehouse: number
    Transfer_Transfer_sourceWarehouseIdToWarehouse: number
    staff: number
    zones: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audits?: boolean | WarehouseCountOutputTypeCountAuditsArgs
    inventoryItems?: boolean | WarehouseCountOutputTypeCountInventoryItemsArgs
    purchaseOrders?: boolean | WarehouseCountOutputTypeCountPurchaseOrdersArgs
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: boolean | WarehouseCountOutputTypeCountTransfer_Transfer_destinationWarehouseIdToWarehouseArgs
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: boolean | WarehouseCountOutputTypeCountTransfer_Transfer_sourceWarehouseIdToWarehouseArgs
    staff?: boolean | WarehouseCountOutputTypeCountStaffArgs
    zones?: boolean | WarehouseCountOutputTypeCountZonesArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransfer_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransfer_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseStaffWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseZoneWhereInput
  }


  /**
   * Count Type WarehouseZoneCountOutputType
   */

  export type WarehouseZoneCountOutputType = {
    aisles: number
  }

  export type WarehouseZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisles?: boolean | WarehouseZoneCountOutputTypeCountAislesArgs
  }

  // Custom InputTypes
  /**
   * WarehouseZoneCountOutputType without action
   */
  export type WarehouseZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZoneCountOutputType
     */
    select?: WarehouseZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseZoneCountOutputType without action
   */
  export type WarehouseZoneCountOutputTypeCountAislesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseAisleWhereInput
  }


  /**
   * Count Type WarehouseAisleCountOutputType
   */

  export type WarehouseAisleCountOutputType = {
    shelves: number
  }

  export type WarehouseAisleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelves?: boolean | WarehouseAisleCountOutputTypeCountShelvesArgs
  }

  // Custom InputTypes
  /**
   * WarehouseAisleCountOutputType without action
   */
  export type WarehouseAisleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisleCountOutputType
     */
    select?: WarehouseAisleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseAisleCountOutputType without action
   */
  export type WarehouseAisleCountOutputTypeCountShelvesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseShelfWhereInput
  }


  /**
   * Count Type WarehouseShelfCountOutputType
   */

  export type WarehouseShelfCountOutputType = {
    bins: number
  }

  export type WarehouseShelfCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bins?: boolean | WarehouseShelfCountOutputTypeCountBinsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseShelfCountOutputType without action
   */
  export type WarehouseShelfCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelfCountOutputType
     */
    select?: WarehouseShelfCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseShelfCountOutputType without action
   */
  export type WarehouseShelfCountOutputTypeCountBinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseBinWhereInput
  }


  /**
   * Count Type WarehouseBinCountOutputType
   */

  export type WarehouseBinCountOutputType = {
    inventoryItems: number
  }

  export type WarehouseBinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | WarehouseBinCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseBinCountOutputType without action
   */
  export type WarehouseBinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBinCountOutputType
     */
    select?: WarehouseBinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseBinCountOutputType without action
   */
  export type WarehouseBinCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    inventoryItems: number
    sales: number
    staff: number
    Transfer_Transfer_destinationStoreIdToStore: number
    Transfer_Transfer_sourceStoreIdToStore: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | StoreCountOutputTypeCountInventoryItemsArgs
    sales?: boolean | StoreCountOutputTypeCountSalesArgs
    staff?: boolean | StoreCountOutputTypeCountStaffArgs
    Transfer_Transfer_destinationStoreIdToStore?: boolean | StoreCountOutputTypeCountTransfer_Transfer_destinationStoreIdToStoreArgs
    Transfer_Transfer_sourceStoreIdToStore?: boolean | StoreCountOutputTypeCountTransfer_Transfer_sourceStoreIdToStoreArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStaffWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTransfer_Transfer_destinationStoreIdToStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTransfer_Transfer_sourceStoreIdToStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    products: number
    purchaseOrders: number
    contracts: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SupplierCountOutputTypeCountProductsArgs
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
    contracts?: boolean | SupplierCountOutputTypeCountContractsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierContractWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    auditItems: number
    inventoryItems: number
    purchaseOrderItems: number
    saleItems: number
    transferItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditItems?: boolean | ProductCountOutputTypeCountAuditItemsArgs
    inventoryItems?: boolean | ProductCountOutputTypeCountInventoryItemsArgs
    purchaseOrderItems?: boolean | ProductCountOutputTypeCountPurchaseOrderItemsArgs
    saleItems?: boolean | ProductCountOutputTypeCountSaleItemsArgs
    transferItems?: boolean | ProductCountOutputTypeCountTransferItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAuditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransferItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    other_Category: number
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_Category?: boolean | CategoryCountOutputTypeCountOther_CategoryArgs
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountOther_CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    auditItems: number
    saleItems: number
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem: number
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditItems?: boolean | InventoryItemCountOutputTypeCountAuditItemsArgs
    saleItems?: boolean | InventoryItemCountOutputTypeCountSaleItemsArgs
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | InventoryItemCountOutputTypeCountTransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | InventoryItemCountOutputTypeCountTransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountAuditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountTransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountTransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    LoyaltyTransaction: number
    PromotionRedemption: number
    items: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyTransaction?: boolean | SaleCountOutputTypeCountLoyaltyTransactionArgs
    PromotionRedemption?: boolean | SaleCountOutputTypeCountPromotionRedemptionArgs
    items?: boolean | SaleCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountLoyaltyTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountPromotionRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }


  /**
   * Count Type TransferCountOutputType
   */

  export type TransferCountOutputType = {
    items: number
  }

  export type TransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransferCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferCountOutputType
     */
    select?: TransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    customerAddresses: number
    CustomerNote: number
    CustomerToGroup: number
    loyaltyTransactions: number
    PromotionRedemption: number
    sales: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAddresses?: boolean | CustomerCountOutputTypeCountCustomerAddressesArgs
    CustomerNote?: boolean | CustomerCountOutputTypeCountCustomerNoteArgs
    CustomerToGroup?: boolean | CustomerCountOutputTypeCountCustomerToGroupArgs
    loyaltyTransactions?: boolean | CustomerCountOutputTypeCountLoyaltyTransactionsArgs
    PromotionRedemption?: boolean | CustomerCountOutputTypeCountPromotionRedemptionArgs
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerNoteWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerToGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerToGroupWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountLoyaltyTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPromotionRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type LoyaltyProgramCountOutputType
   */

  export type LoyaltyProgramCountOutputType = {
    CustomerPromotion: number
    LoyaltyProgramRule: number
    tiers: number
    transactions: number
  }

  export type LoyaltyProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerPromotion?: boolean | LoyaltyProgramCountOutputTypeCountCustomerPromotionArgs
    LoyaltyProgramRule?: boolean | LoyaltyProgramCountOutputTypeCountLoyaltyProgramRuleArgs
    tiers?: boolean | LoyaltyProgramCountOutputTypeCountTiersArgs
    transactions?: boolean | LoyaltyProgramCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramCountOutputType
     */
    select?: LoyaltyProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeCountCustomerPromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPromotionWhereInput
  }

  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeCountLoyaltyProgramRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramRuleWhereInput
  }

  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeCountTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramTierWhereInput
  }

  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }


  /**
   * Count Type AuditCountOutputType
   */

  export type AuditCountOutputType = {
    assignments: number
    items: number
  }

  export type AuditCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | AuditCountOutputTypeCountAssignmentsArgs
    items?: boolean | AuditCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditCountOutputType
     */
    select?: AuditCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAssignmentWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
  }


  /**
   * Count Type CustomerGroupCountOutputType
   */

  export type CustomerGroupCountOutputType = {
    CustomerToGroup: number
  }

  export type CustomerGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerToGroup?: boolean | CustomerGroupCountOutputTypeCountCustomerToGroupArgs
  }

  // Custom InputTypes
  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupCountOutputType
     */
    select?: CustomerGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeCountCustomerToGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerToGroupWhereInput
  }


  /**
   * Count Type CustomerPromotionCountOutputType
   */

  export type CustomerPromotionCountOutputType = {
    PromotionRedemption: number
  }

  export type CustomerPromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PromotionRedemption?: boolean | CustomerPromotionCountOutputTypeCountPromotionRedemptionArgs
  }

  // Custom InputTypes
  /**
   * CustomerPromotionCountOutputType without action
   */
  export type CustomerPromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotionCountOutputType
     */
    select?: CustomerPromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerPromotionCountOutputType without action
   */
  export type CustomerPromotionCountOutputTypeCountPromotionRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    createdAudits?: boolean | User$createdAuditsArgs<ExtArgs>
    auditAssignments?: boolean | User$auditAssignmentsArgs<ExtArgs>
    CustomerNote?: boolean | User$CustomerNoteArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    Product_Product_createdByIdToUser?: boolean | User$Product_Product_createdByIdToUserArgs<ExtArgs>
    Product_Product_updatedByIdToUser?: boolean | User$Product_Product_updatedByIdToUserArgs<ExtArgs>
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: boolean | User$PurchaseOrder_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: boolean | User$PurchaseOrder_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    createdSales?: boolean | User$createdSalesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    storeStaff?: boolean | User$storeStaffArgs<ExtArgs>
    Supplier_Supplier_createdByIdToUser?: boolean | User$Supplier_Supplier_createdByIdToUserArgs<ExtArgs>
    Supplier_Supplier_updatedByIdToUser?: boolean | User$Supplier_Supplier_updatedByIdToUserArgs<ExtArgs>
    Transfer_Transfer_approvedByIdToUser?: boolean | User$Transfer_Transfer_approvedByIdToUserArgs<ExtArgs>
    Transfer_Transfer_createdByIdToUser?: boolean | User$Transfer_Transfer_createdByIdToUserArgs<ExtArgs>
    Transfer_Transfer_receivedByIdToUser?: boolean | User$Transfer_Transfer_receivedByIdToUserArgs<ExtArgs>
    warehouseStaff?: boolean | User$warehouseStaffArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "password" | "image" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    createdAudits?: boolean | User$createdAuditsArgs<ExtArgs>
    auditAssignments?: boolean | User$auditAssignmentsArgs<ExtArgs>
    CustomerNote?: boolean | User$CustomerNoteArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | User$receivedNotificationsArgs<ExtArgs>
    Product_Product_createdByIdToUser?: boolean | User$Product_Product_createdByIdToUserArgs<ExtArgs>
    Product_Product_updatedByIdToUser?: boolean | User$Product_Product_updatedByIdToUserArgs<ExtArgs>
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: boolean | User$PurchaseOrder_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: boolean | User$PurchaseOrder_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    createdSales?: boolean | User$createdSalesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    storeStaff?: boolean | User$storeStaffArgs<ExtArgs>
    Supplier_Supplier_createdByIdToUser?: boolean | User$Supplier_Supplier_createdByIdToUserArgs<ExtArgs>
    Supplier_Supplier_updatedByIdToUser?: boolean | User$Supplier_Supplier_updatedByIdToUserArgs<ExtArgs>
    Transfer_Transfer_approvedByIdToUser?: boolean | User$Transfer_Transfer_approvedByIdToUserArgs<ExtArgs>
    Transfer_Transfer_createdByIdToUser?: boolean | User$Transfer_Transfer_createdByIdToUserArgs<ExtArgs>
    Transfer_Transfer_receivedByIdToUser?: boolean | User$Transfer_Transfer_receivedByIdToUserArgs<ExtArgs>
    warehouseStaff?: boolean | User$warehouseStaffArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      createdAudits: Prisma.$AuditPayload<ExtArgs>[]
      auditAssignments: Prisma.$AuditAssignmentPayload<ExtArgs>[]
      CustomerNote: Prisma.$CustomerNotePayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      receivedNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      Product_Product_createdByIdToUser: Prisma.$ProductPayload<ExtArgs>[]
      Product_Product_updatedByIdToUser: Prisma.$ProductPayload<ExtArgs>[]
      PurchaseOrder_PurchaseOrder_createdByIdToUser: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      PurchaseOrder_PurchaseOrder_updatedByIdToUser: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      createdSales: Prisma.$SalePayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      storeStaff: Prisma.$StoreStaffPayload<ExtArgs> | null
      Supplier_Supplier_createdByIdToUser: Prisma.$SupplierPayload<ExtArgs>[]
      Supplier_Supplier_updatedByIdToUser: Prisma.$SupplierPayload<ExtArgs>[]
      Transfer_Transfer_approvedByIdToUser: Prisma.$TransferPayload<ExtArgs>[]
      Transfer_Transfer_createdByIdToUser: Prisma.$TransferPayload<ExtArgs>[]
      Transfer_Transfer_receivedByIdToUser: Prisma.$TransferPayload<ExtArgs>[]
      warehouseStaff: Prisma.$WarehouseStaffPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      password: string | null
      image: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAudits<T extends User$createdAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditAssignments<T extends User$auditAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerNote<T extends User$CustomerNoteArgs<ExtArgs> = {}>(args?: Subset<T, User$CustomerNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedNotifications<T extends User$receivedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product_Product_createdByIdToUser<T extends User$Product_Product_createdByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Product_Product_createdByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product_Product_updatedByIdToUser<T extends User$Product_Product_updatedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Product_Product_updatedByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseOrder_PurchaseOrder_createdByIdToUser<T extends User$PurchaseOrder_PurchaseOrder_createdByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$PurchaseOrder_PurchaseOrder_createdByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseOrder_PurchaseOrder_updatedByIdToUser<T extends User$PurchaseOrder_PurchaseOrder_updatedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$PurchaseOrder_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSales<T extends User$createdSalesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storeStaff<T extends User$storeStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$storeStaffArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Supplier_Supplier_createdByIdToUser<T extends User$Supplier_Supplier_createdByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Supplier_Supplier_createdByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Supplier_Supplier_updatedByIdToUser<T extends User$Supplier_Supplier_updatedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Supplier_Supplier_updatedByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_approvedByIdToUser<T extends User$Transfer_Transfer_approvedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Transfer_Transfer_approvedByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_createdByIdToUser<T extends User$Transfer_Transfer_createdByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Transfer_Transfer_createdByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_receivedByIdToUser<T extends User$Transfer_Transfer_receivedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Transfer_Transfer_receivedByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouseStaff<T extends User$warehouseStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$warehouseStaffArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.createdAudits
   */
  export type User$createdAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * User.auditAssignments
   */
  export type User$auditAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    where?: AuditAssignmentWhereInput
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    cursor?: AuditAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * User.CustomerNote
   */
  export type User$CustomerNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    where?: CustomerNoteWhereInput
    orderBy?: CustomerNoteOrderByWithRelationInput | CustomerNoteOrderByWithRelationInput[]
    cursor?: CustomerNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerNoteScalarFieldEnum | CustomerNoteScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.receivedNotifications
   */
  export type User$receivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.Product_Product_createdByIdToUser
   */
  export type User$Product_Product_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.Product_Product_updatedByIdToUser
   */
  export type User$Product_Product_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.PurchaseOrder_PurchaseOrder_createdByIdToUser
   */
  export type User$PurchaseOrder_PurchaseOrder_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User.PurchaseOrder_PurchaseOrder_updatedByIdToUser
   */
  export type User$PurchaseOrder_PurchaseOrder_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User.createdSales
   */
  export type User$createdSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.storeStaff
   */
  export type User$storeStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    where?: StoreStaffWhereInput
  }

  /**
   * User.Supplier_Supplier_createdByIdToUser
   */
  export type User$Supplier_Supplier_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * User.Supplier_Supplier_updatedByIdToUser
   */
  export type User$Supplier_Supplier_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * User.Transfer_Transfer_approvedByIdToUser
   */
  export type User$Transfer_Transfer_approvedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.Transfer_Transfer_createdByIdToUser
   */
  export type User$Transfer_Transfer_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.Transfer_Transfer_receivedByIdToUser
   */
  export type User$Transfer_Transfer_receivedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * User.warehouseStaff
   */
  export type User$warehouseStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    where?: WarehouseStaffWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    name: number
    code: number
    address: number
    contactPerson: number
    phone: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    contactPerson?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    contactPerson?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    contactPerson?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: string
    name: string
    code: string
    address: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audits?: boolean | Warehouse$auditsArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    purchaseOrders?: boolean | Warehouse$purchaseOrdersArgs<ExtArgs>
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: boolean | Warehouse$Transfer_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: boolean | Warehouse$Transfer_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
    staff?: boolean | Warehouse$staffArgs<ExtArgs>
    zones?: boolean | Warehouse$zonesArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "address" | "contactPerson" | "phone" | "email" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audits?: boolean | Warehouse$auditsArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    purchaseOrders?: boolean | Warehouse$purchaseOrdersArgs<ExtArgs>
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: boolean | Warehouse$Transfer_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: boolean | Warehouse$Transfer_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
    staff?: boolean | Warehouse$staffArgs<ExtArgs>
    zones?: boolean | Warehouse$zonesArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      audits: Prisma.$AuditPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      Transfer_Transfer_destinationWarehouseIdToWarehouse: Prisma.$TransferPayload<ExtArgs>[]
      Transfer_Transfer_sourceWarehouseIdToWarehouse: Prisma.$TransferPayload<ExtArgs>[]
      staff: Prisma.$WarehouseStaffPayload<ExtArgs>[]
      zones: Prisma.$WarehouseZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      address: string | null
      contactPerson: string | null
      phone: string | null
      email: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audits<T extends Warehouse$auditsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Warehouse$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Warehouse$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_destinationWarehouseIdToWarehouse<T extends Warehouse$Transfer_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$Transfer_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_sourceWarehouseIdToWarehouse<T extends Warehouse$Transfer_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$Transfer_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Warehouse$staffArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zones<T extends Warehouse$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly code: FieldRef<"Warehouse", 'String'>
    readonly address: FieldRef<"Warehouse", 'String'>
    readonly contactPerson: FieldRef<"Warehouse", 'String'>
    readonly phone: FieldRef<"Warehouse", 'String'>
    readonly email: FieldRef<"Warehouse", 'String'>
    readonly isActive: FieldRef<"Warehouse", 'Boolean'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.audits
   */
  export type Warehouse$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Warehouse.inventoryItems
   */
  export type Warehouse$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Warehouse.purchaseOrders
   */
  export type Warehouse$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Warehouse.Transfer_Transfer_destinationWarehouseIdToWarehouse
   */
  export type Warehouse$Transfer_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.Transfer_Transfer_sourceWarehouseIdToWarehouse
   */
  export type Warehouse$Transfer_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.staff
   */
  export type Warehouse$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    where?: WarehouseStaffWhereInput
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    cursor?: WarehouseStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * Warehouse.zones
   */
  export type Warehouse$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    where?: WarehouseZoneWhereInput
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    cursor?: WarehouseZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseZone
   */

  export type AggregateWarehouseZone = {
    _count: WarehouseZoneCountAggregateOutputType | null
    _min: WarehouseZoneMinAggregateOutputType | null
    _max: WarehouseZoneMaxAggregateOutputType | null
  }

  export type WarehouseZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    warehouseId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    warehouseId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseZoneCountAggregateOutputType = {
    id: number
    name: number
    code: number
    warehouseId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseZoneMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    warehouseId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseZoneMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    warehouseId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseZoneCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    warehouseId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseZone to aggregate.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseZones
    **/
    _count?: true | WarehouseZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseZoneMaxAggregateInputType
  }

  export type GetWarehouseZoneAggregateType<T extends WarehouseZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseZone[P]>
      : GetScalarType<T[P], AggregateWarehouseZone[P]>
  }




  export type WarehouseZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseZoneWhereInput
    orderBy?: WarehouseZoneOrderByWithAggregationInput | WarehouseZoneOrderByWithAggregationInput[]
    by: WarehouseZoneScalarFieldEnum[] | WarehouseZoneScalarFieldEnum
    having?: WarehouseZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseZoneCountAggregateInputType | true
    _min?: WarehouseZoneMinAggregateInputType
    _max?: WarehouseZoneMaxAggregateInputType
  }

  export type WarehouseZoneGroupByOutputType = {
    id: string
    name: string
    code: string
    warehouseId: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: WarehouseZoneCountAggregateOutputType | null
    _min: WarehouseZoneMinAggregateOutputType | null
    _max: WarehouseZoneMaxAggregateOutputType | null
  }

  type GetWarehouseZoneGroupByPayload<T extends WarehouseZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseZoneGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseZoneGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aisles?: boolean | WarehouseZone$aislesArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseZone"]>

  export type WarehouseZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseZone"]>

  export type WarehouseZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseZone"]>

  export type WarehouseZoneSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "warehouseId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseZone"]>
  export type WarehouseZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisles?: boolean | WarehouseZone$aislesArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type WarehouseZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $WarehouseZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseZone"
    objects: {
      aisles: Prisma.$WarehouseAislePayload<ExtArgs>[]
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      warehouseId: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseZone"]>
    composites: {}
  }

  type WarehouseZoneGetPayload<S extends boolean | null | undefined | WarehouseZoneDefaultArgs> = $Result.GetResult<Prisma.$WarehouseZonePayload, S>

  type WarehouseZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseZoneCountAggregateInputType | true
    }

  export interface WarehouseZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseZone'], meta: { name: 'WarehouseZone' } }
    /**
     * Find zero or one WarehouseZone that matches the filter.
     * @param {WarehouseZoneFindUniqueArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseZoneFindUniqueArgs>(args: SelectSubset<T, WarehouseZoneFindUniqueArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseZoneFindUniqueOrThrowArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneFindFirstArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseZoneFindFirstArgs>(args?: SelectSubset<T, WarehouseZoneFindFirstArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneFindFirstOrThrowArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseZones
     * const warehouseZones = await prisma.warehouseZone.findMany()
     * 
     * // Get first 10 WarehouseZones
     * const warehouseZones = await prisma.warehouseZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseZoneWithIdOnly = await prisma.warehouseZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseZoneFindManyArgs>(args?: SelectSubset<T, WarehouseZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseZone.
     * @param {WarehouseZoneCreateArgs} args - Arguments to create a WarehouseZone.
     * @example
     * // Create one WarehouseZone
     * const WarehouseZone = await prisma.warehouseZone.create({
     *   data: {
     *     // ... data to create a WarehouseZone
     *   }
     * })
     * 
     */
    create<T extends WarehouseZoneCreateArgs>(args: SelectSubset<T, WarehouseZoneCreateArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseZones.
     * @param {WarehouseZoneCreateManyArgs} args - Arguments to create many WarehouseZones.
     * @example
     * // Create many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseZoneCreateManyArgs>(args?: SelectSubset<T, WarehouseZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseZones and returns the data saved in the database.
     * @param {WarehouseZoneCreateManyAndReturnArgs} args - Arguments to create many WarehouseZones.
     * @example
     * // Create many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseZones and only return the `id`
     * const warehouseZoneWithIdOnly = await prisma.warehouseZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseZone.
     * @param {WarehouseZoneDeleteArgs} args - Arguments to delete one WarehouseZone.
     * @example
     * // Delete one WarehouseZone
     * const WarehouseZone = await prisma.warehouseZone.delete({
     *   where: {
     *     // ... filter to delete one WarehouseZone
     *   }
     * })
     * 
     */
    delete<T extends WarehouseZoneDeleteArgs>(args: SelectSubset<T, WarehouseZoneDeleteArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseZone.
     * @param {WarehouseZoneUpdateArgs} args - Arguments to update one WarehouseZone.
     * @example
     * // Update one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseZoneUpdateArgs>(args: SelectSubset<T, WarehouseZoneUpdateArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseZones.
     * @param {WarehouseZoneDeleteManyArgs} args - Arguments to filter WarehouseZones to delete.
     * @example
     * // Delete a few WarehouseZones
     * const { count } = await prisma.warehouseZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseZoneDeleteManyArgs>(args?: SelectSubset<T, WarehouseZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseZoneUpdateManyArgs>(args: SelectSubset<T, WarehouseZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseZones and returns the data updated in the database.
     * @param {WarehouseZoneUpdateManyAndReturnArgs} args - Arguments to update many WarehouseZones.
     * @example
     * // Update many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseZones and only return the `id`
     * const warehouseZoneWithIdOnly = await prisma.warehouseZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseZone.
     * @param {WarehouseZoneUpsertArgs} args - Arguments to update or create a WarehouseZone.
     * @example
     * // Update or create a WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.upsert({
     *   create: {
     *     // ... data to create a WarehouseZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseZone we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseZoneUpsertArgs>(args: SelectSubset<T, WarehouseZoneUpsertArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneCountArgs} args - Arguments to filter WarehouseZones to count.
     * @example
     * // Count the number of WarehouseZones
     * const count = await prisma.warehouseZone.count({
     *   where: {
     *     // ... the filter for the WarehouseZones we want to count
     *   }
     * })
    **/
    count<T extends WarehouseZoneCountArgs>(
      args?: Subset<T, WarehouseZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseZoneAggregateArgs>(args: Subset<T, WarehouseZoneAggregateArgs>): Prisma.PrismaPromise<GetWarehouseZoneAggregateType<T>>

    /**
     * Group by WarehouseZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseZoneGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseZone model
   */
  readonly fields: WarehouseZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aisles<T extends WarehouseZone$aislesArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseZone$aislesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseZone model
   */
  interface WarehouseZoneFieldRefs {
    readonly id: FieldRef<"WarehouseZone", 'String'>
    readonly name: FieldRef<"WarehouseZone", 'String'>
    readonly code: FieldRef<"WarehouseZone", 'String'>
    readonly warehouseId: FieldRef<"WarehouseZone", 'String'>
    readonly description: FieldRef<"WarehouseZone", 'String'>
    readonly createdAt: FieldRef<"WarehouseZone", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseZone findUnique
   */
  export type WarehouseZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone findUniqueOrThrow
   */
  export type WarehouseZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone findFirst
   */
  export type WarehouseZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseZones.
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseZones.
     */
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * WarehouseZone findFirstOrThrow
   */
  export type WarehouseZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseZones.
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseZones.
     */
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * WarehouseZone findMany
   */
  export type WarehouseZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZones to fetch.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseZones.
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * WarehouseZone create
   */
  export type WarehouseZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseZone.
     */
    data: XOR<WarehouseZoneCreateInput, WarehouseZoneUncheckedCreateInput>
  }

  /**
   * WarehouseZone createMany
   */
  export type WarehouseZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseZones.
     */
    data: WarehouseZoneCreateManyInput | WarehouseZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseZone createManyAndReturn
   */
  export type WarehouseZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseZones.
     */
    data: WarehouseZoneCreateManyInput | WarehouseZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseZone update
   */
  export type WarehouseZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseZone.
     */
    data: XOR<WarehouseZoneUpdateInput, WarehouseZoneUncheckedUpdateInput>
    /**
     * Choose, which WarehouseZone to update.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone updateMany
   */
  export type WarehouseZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseZones.
     */
    data: XOR<WarehouseZoneUpdateManyMutationInput, WarehouseZoneUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseZones to update
     */
    where?: WarehouseZoneWhereInput
    /**
     * Limit how many WarehouseZones to update.
     */
    limit?: number
  }

  /**
   * WarehouseZone updateManyAndReturn
   */
  export type WarehouseZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseZones.
     */
    data: XOR<WarehouseZoneUpdateManyMutationInput, WarehouseZoneUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseZones to update
     */
    where?: WarehouseZoneWhereInput
    /**
     * Limit how many WarehouseZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseZone upsert
   */
  export type WarehouseZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseZone to update in case it exists.
     */
    where: WarehouseZoneWhereUniqueInput
    /**
     * In case the WarehouseZone found by the `where` argument doesn't exist, create a new WarehouseZone with this data.
     */
    create: XOR<WarehouseZoneCreateInput, WarehouseZoneUncheckedCreateInput>
    /**
     * In case the WarehouseZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseZoneUpdateInput, WarehouseZoneUncheckedUpdateInput>
  }

  /**
   * WarehouseZone delete
   */
  export type WarehouseZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter which WarehouseZone to delete.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone deleteMany
   */
  export type WarehouseZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseZones to delete
     */
    where?: WarehouseZoneWhereInput
    /**
     * Limit how many WarehouseZones to delete.
     */
    limit?: number
  }

  /**
   * WarehouseZone.aisles
   */
  export type WarehouseZone$aislesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    where?: WarehouseAisleWhereInput
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    cursor?: WarehouseAisleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseZone without action
   */
  export type WarehouseZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseAisle
   */

  export type AggregateWarehouseAisle = {
    _count: WarehouseAisleCountAggregateOutputType | null
    _min: WarehouseAisleMinAggregateOutputType | null
    _max: WarehouseAisleMaxAggregateOutputType | null
  }

  export type WarehouseAisleMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseAisleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseAisleCountAggregateOutputType = {
    id: number
    name: number
    code: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseAisleMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseAisleMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseAisleCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAisleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseAisle to aggregate.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseAisles
    **/
    _count?: true | WarehouseAisleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseAisleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseAisleMaxAggregateInputType
  }

  export type GetWarehouseAisleAggregateType<T extends WarehouseAisleAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseAisle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseAisle[P]>
      : GetScalarType<T[P], AggregateWarehouseAisle[P]>
  }




  export type WarehouseAisleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseAisleWhereInput
    orderBy?: WarehouseAisleOrderByWithAggregationInput | WarehouseAisleOrderByWithAggregationInput[]
    by: WarehouseAisleScalarFieldEnum[] | WarehouseAisleScalarFieldEnum
    having?: WarehouseAisleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseAisleCountAggregateInputType | true
    _min?: WarehouseAisleMinAggregateInputType
    _max?: WarehouseAisleMaxAggregateInputType
  }

  export type WarehouseAisleGroupByOutputType = {
    id: string
    name: string
    code: string
    zoneId: string
    createdAt: Date
    updatedAt: Date
    _count: WarehouseAisleCountAggregateOutputType | null
    _min: WarehouseAisleMinAggregateOutputType | null
    _max: WarehouseAisleMaxAggregateOutputType | null
  }

  type GetWarehouseAisleGroupByPayload<T extends WarehouseAisleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseAisleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseAisleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseAisleGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseAisleGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseAisleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
    shelves?: boolean | WarehouseAisle$shelvesArgs<ExtArgs>
    _count?: boolean | WarehouseAisleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseAisle"]>

  export type WarehouseAisleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseAisle"]>

  export type WarehouseAisleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseAisle"]>

  export type WarehouseAisleSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseAisleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "zoneId" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseAisle"]>
  export type WarehouseAisleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
    shelves?: boolean | WarehouseAisle$shelvesArgs<ExtArgs>
    _count?: boolean | WarehouseAisleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseAisleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }
  export type WarehouseAisleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }

  export type $WarehouseAislePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseAisle"
    objects: {
      zone: Prisma.$WarehouseZonePayload<ExtArgs>
      shelves: Prisma.$WarehouseShelfPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      zoneId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseAisle"]>
    composites: {}
  }

  type WarehouseAisleGetPayload<S extends boolean | null | undefined | WarehouseAisleDefaultArgs> = $Result.GetResult<Prisma.$WarehouseAislePayload, S>

  type WarehouseAisleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseAisleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseAisleCountAggregateInputType | true
    }

  export interface WarehouseAisleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseAisle'], meta: { name: 'WarehouseAisle' } }
    /**
     * Find zero or one WarehouseAisle that matches the filter.
     * @param {WarehouseAisleFindUniqueArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseAisleFindUniqueArgs>(args: SelectSubset<T, WarehouseAisleFindUniqueArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseAisle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseAisleFindUniqueOrThrowArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseAisleFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseAisleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseAisle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleFindFirstArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseAisleFindFirstArgs>(args?: SelectSubset<T, WarehouseAisleFindFirstArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseAisle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleFindFirstOrThrowArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseAisleFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseAisleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseAisles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseAisles
     * const warehouseAisles = await prisma.warehouseAisle.findMany()
     * 
     * // Get first 10 WarehouseAisles
     * const warehouseAisles = await prisma.warehouseAisle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseAisleWithIdOnly = await prisma.warehouseAisle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseAisleFindManyArgs>(args?: SelectSubset<T, WarehouseAisleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseAisle.
     * @param {WarehouseAisleCreateArgs} args - Arguments to create a WarehouseAisle.
     * @example
     * // Create one WarehouseAisle
     * const WarehouseAisle = await prisma.warehouseAisle.create({
     *   data: {
     *     // ... data to create a WarehouseAisle
     *   }
     * })
     * 
     */
    create<T extends WarehouseAisleCreateArgs>(args: SelectSubset<T, WarehouseAisleCreateArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseAisles.
     * @param {WarehouseAisleCreateManyArgs} args - Arguments to create many WarehouseAisles.
     * @example
     * // Create many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseAisleCreateManyArgs>(args?: SelectSubset<T, WarehouseAisleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseAisles and returns the data saved in the database.
     * @param {WarehouseAisleCreateManyAndReturnArgs} args - Arguments to create many WarehouseAisles.
     * @example
     * // Create many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseAisles and only return the `id`
     * const warehouseAisleWithIdOnly = await prisma.warehouseAisle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseAisleCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseAisleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseAisle.
     * @param {WarehouseAisleDeleteArgs} args - Arguments to delete one WarehouseAisle.
     * @example
     * // Delete one WarehouseAisle
     * const WarehouseAisle = await prisma.warehouseAisle.delete({
     *   where: {
     *     // ... filter to delete one WarehouseAisle
     *   }
     * })
     * 
     */
    delete<T extends WarehouseAisleDeleteArgs>(args: SelectSubset<T, WarehouseAisleDeleteArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseAisle.
     * @param {WarehouseAisleUpdateArgs} args - Arguments to update one WarehouseAisle.
     * @example
     * // Update one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseAisleUpdateArgs>(args: SelectSubset<T, WarehouseAisleUpdateArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseAisles.
     * @param {WarehouseAisleDeleteManyArgs} args - Arguments to filter WarehouseAisles to delete.
     * @example
     * // Delete a few WarehouseAisles
     * const { count } = await prisma.warehouseAisle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseAisleDeleteManyArgs>(args?: SelectSubset<T, WarehouseAisleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseAisles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseAisleUpdateManyArgs>(args: SelectSubset<T, WarehouseAisleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseAisles and returns the data updated in the database.
     * @param {WarehouseAisleUpdateManyAndReturnArgs} args - Arguments to update many WarehouseAisles.
     * @example
     * // Update many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseAisles and only return the `id`
     * const warehouseAisleWithIdOnly = await prisma.warehouseAisle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseAisleUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseAisleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseAisle.
     * @param {WarehouseAisleUpsertArgs} args - Arguments to update or create a WarehouseAisle.
     * @example
     * // Update or create a WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.upsert({
     *   create: {
     *     // ... data to create a WarehouseAisle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseAisle we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseAisleUpsertArgs>(args: SelectSubset<T, WarehouseAisleUpsertArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseAisles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleCountArgs} args - Arguments to filter WarehouseAisles to count.
     * @example
     * // Count the number of WarehouseAisles
     * const count = await prisma.warehouseAisle.count({
     *   where: {
     *     // ... the filter for the WarehouseAisles we want to count
     *   }
     * })
    **/
    count<T extends WarehouseAisleCountArgs>(
      args?: Subset<T, WarehouseAisleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseAisleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseAisle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAisleAggregateArgs>(args: Subset<T, WarehouseAisleAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAisleAggregateType<T>>

    /**
     * Group by WarehouseAisle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseAisleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseAisleGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseAisleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseAisleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseAisleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseAisle model
   */
  readonly fields: WarehouseAisleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseAisle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseAisleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends WarehouseZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseZoneDefaultArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shelves<T extends WarehouseAisle$shelvesArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseAisle$shelvesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseAisle model
   */
  interface WarehouseAisleFieldRefs {
    readonly id: FieldRef<"WarehouseAisle", 'String'>
    readonly name: FieldRef<"WarehouseAisle", 'String'>
    readonly code: FieldRef<"WarehouseAisle", 'String'>
    readonly zoneId: FieldRef<"WarehouseAisle", 'String'>
    readonly createdAt: FieldRef<"WarehouseAisle", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseAisle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseAisle findUnique
   */
  export type WarehouseAisleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle findUniqueOrThrow
   */
  export type WarehouseAisleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle findFirst
   */
  export type WarehouseAisleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseAisles.
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseAisles.
     */
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseAisle findFirstOrThrow
   */
  export type WarehouseAisleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseAisles.
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseAisles.
     */
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseAisle findMany
   */
  export type WarehouseAisleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisles to fetch.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseAisles.
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseAisle create
   */
  export type WarehouseAisleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseAisle.
     */
    data: XOR<WarehouseAisleCreateInput, WarehouseAisleUncheckedCreateInput>
  }

  /**
   * WarehouseAisle createMany
   */
  export type WarehouseAisleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseAisles.
     */
    data: WarehouseAisleCreateManyInput | WarehouseAisleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseAisle createManyAndReturn
   */
  export type WarehouseAisleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseAisles.
     */
    data: WarehouseAisleCreateManyInput | WarehouseAisleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseAisle update
   */
  export type WarehouseAisleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseAisle.
     */
    data: XOR<WarehouseAisleUpdateInput, WarehouseAisleUncheckedUpdateInput>
    /**
     * Choose, which WarehouseAisle to update.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle updateMany
   */
  export type WarehouseAisleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseAisles.
     */
    data: XOR<WarehouseAisleUpdateManyMutationInput, WarehouseAisleUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseAisles to update
     */
    where?: WarehouseAisleWhereInput
    /**
     * Limit how many WarehouseAisles to update.
     */
    limit?: number
  }

  /**
   * WarehouseAisle updateManyAndReturn
   */
  export type WarehouseAisleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseAisles.
     */
    data: XOR<WarehouseAisleUpdateManyMutationInput, WarehouseAisleUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseAisles to update
     */
    where?: WarehouseAisleWhereInput
    /**
     * Limit how many WarehouseAisles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseAisle upsert
   */
  export type WarehouseAisleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseAisle to update in case it exists.
     */
    where: WarehouseAisleWhereUniqueInput
    /**
     * In case the WarehouseAisle found by the `where` argument doesn't exist, create a new WarehouseAisle with this data.
     */
    create: XOR<WarehouseAisleCreateInput, WarehouseAisleUncheckedCreateInput>
    /**
     * In case the WarehouseAisle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseAisleUpdateInput, WarehouseAisleUncheckedUpdateInput>
  }

  /**
   * WarehouseAisle delete
   */
  export type WarehouseAisleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter which WarehouseAisle to delete.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle deleteMany
   */
  export type WarehouseAisleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseAisles to delete
     */
    where?: WarehouseAisleWhereInput
    /**
     * Limit how many WarehouseAisles to delete.
     */
    limit?: number
  }

  /**
   * WarehouseAisle.shelves
   */
  export type WarehouseAisle$shelvesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    where?: WarehouseShelfWhereInput
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    cursor?: WarehouseShelfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseAisle without action
   */
  export type WarehouseAisleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseShelf
   */

  export type AggregateWarehouseShelf = {
    _count: WarehouseShelfCountAggregateOutputType | null
    _min: WarehouseShelfMinAggregateOutputType | null
    _max: WarehouseShelfMaxAggregateOutputType | null
  }

  export type WarehouseShelfMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    aisleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseShelfMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    aisleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseShelfCountAggregateOutputType = {
    id: number
    name: number
    code: number
    aisleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseShelfMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    aisleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseShelfMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    aisleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseShelfCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    aisleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseShelfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseShelf to aggregate.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseShelves
    **/
    _count?: true | WarehouseShelfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseShelfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseShelfMaxAggregateInputType
  }

  export type GetWarehouseShelfAggregateType<T extends WarehouseShelfAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseShelf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseShelf[P]>
      : GetScalarType<T[P], AggregateWarehouseShelf[P]>
  }




  export type WarehouseShelfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseShelfWhereInput
    orderBy?: WarehouseShelfOrderByWithAggregationInput | WarehouseShelfOrderByWithAggregationInput[]
    by: WarehouseShelfScalarFieldEnum[] | WarehouseShelfScalarFieldEnum
    having?: WarehouseShelfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseShelfCountAggregateInputType | true
    _min?: WarehouseShelfMinAggregateInputType
    _max?: WarehouseShelfMaxAggregateInputType
  }

  export type WarehouseShelfGroupByOutputType = {
    id: string
    name: string
    code: string
    aisleId: string
    createdAt: Date
    updatedAt: Date
    _count: WarehouseShelfCountAggregateOutputType | null
    _min: WarehouseShelfMinAggregateOutputType | null
    _max: WarehouseShelfMaxAggregateOutputType | null
  }

  type GetWarehouseShelfGroupByPayload<T extends WarehouseShelfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseShelfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseShelfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseShelfGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseShelfGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseShelfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bins?: boolean | WarehouseShelf$binsArgs<ExtArgs>
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseShelfCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseShelf"]>

  export type WarehouseShelfSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseShelf"]>

  export type WarehouseShelfSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseShelf"]>

  export type WarehouseShelfSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseShelfOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "aisleId" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseShelf"]>
  export type WarehouseShelfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bins?: boolean | WarehouseShelf$binsArgs<ExtArgs>
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseShelfCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseShelfIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }
  export type WarehouseShelfIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }

  export type $WarehouseShelfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseShelf"
    objects: {
      bins: Prisma.$WarehouseBinPayload<ExtArgs>[]
      aisle: Prisma.$WarehouseAislePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      aisleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseShelf"]>
    composites: {}
  }

  type WarehouseShelfGetPayload<S extends boolean | null | undefined | WarehouseShelfDefaultArgs> = $Result.GetResult<Prisma.$WarehouseShelfPayload, S>

  type WarehouseShelfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseShelfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseShelfCountAggregateInputType | true
    }

  export interface WarehouseShelfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseShelf'], meta: { name: 'WarehouseShelf' } }
    /**
     * Find zero or one WarehouseShelf that matches the filter.
     * @param {WarehouseShelfFindUniqueArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseShelfFindUniqueArgs>(args: SelectSubset<T, WarehouseShelfFindUniqueArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseShelf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseShelfFindUniqueOrThrowArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseShelfFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseShelfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseShelf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfFindFirstArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseShelfFindFirstArgs>(args?: SelectSubset<T, WarehouseShelfFindFirstArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseShelf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfFindFirstOrThrowArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseShelfFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseShelfFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseShelves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseShelves
     * const warehouseShelves = await prisma.warehouseShelf.findMany()
     * 
     * // Get first 10 WarehouseShelves
     * const warehouseShelves = await prisma.warehouseShelf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseShelfWithIdOnly = await prisma.warehouseShelf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseShelfFindManyArgs>(args?: SelectSubset<T, WarehouseShelfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseShelf.
     * @param {WarehouseShelfCreateArgs} args - Arguments to create a WarehouseShelf.
     * @example
     * // Create one WarehouseShelf
     * const WarehouseShelf = await prisma.warehouseShelf.create({
     *   data: {
     *     // ... data to create a WarehouseShelf
     *   }
     * })
     * 
     */
    create<T extends WarehouseShelfCreateArgs>(args: SelectSubset<T, WarehouseShelfCreateArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseShelves.
     * @param {WarehouseShelfCreateManyArgs} args - Arguments to create many WarehouseShelves.
     * @example
     * // Create many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseShelfCreateManyArgs>(args?: SelectSubset<T, WarehouseShelfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseShelves and returns the data saved in the database.
     * @param {WarehouseShelfCreateManyAndReturnArgs} args - Arguments to create many WarehouseShelves.
     * @example
     * // Create many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseShelves and only return the `id`
     * const warehouseShelfWithIdOnly = await prisma.warehouseShelf.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseShelfCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseShelfCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseShelf.
     * @param {WarehouseShelfDeleteArgs} args - Arguments to delete one WarehouseShelf.
     * @example
     * // Delete one WarehouseShelf
     * const WarehouseShelf = await prisma.warehouseShelf.delete({
     *   where: {
     *     // ... filter to delete one WarehouseShelf
     *   }
     * })
     * 
     */
    delete<T extends WarehouseShelfDeleteArgs>(args: SelectSubset<T, WarehouseShelfDeleteArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseShelf.
     * @param {WarehouseShelfUpdateArgs} args - Arguments to update one WarehouseShelf.
     * @example
     * // Update one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseShelfUpdateArgs>(args: SelectSubset<T, WarehouseShelfUpdateArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseShelves.
     * @param {WarehouseShelfDeleteManyArgs} args - Arguments to filter WarehouseShelves to delete.
     * @example
     * // Delete a few WarehouseShelves
     * const { count } = await prisma.warehouseShelf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseShelfDeleteManyArgs>(args?: SelectSubset<T, WarehouseShelfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseShelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseShelfUpdateManyArgs>(args: SelectSubset<T, WarehouseShelfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseShelves and returns the data updated in the database.
     * @param {WarehouseShelfUpdateManyAndReturnArgs} args - Arguments to update many WarehouseShelves.
     * @example
     * // Update many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseShelves and only return the `id`
     * const warehouseShelfWithIdOnly = await prisma.warehouseShelf.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseShelfUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseShelfUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseShelf.
     * @param {WarehouseShelfUpsertArgs} args - Arguments to update or create a WarehouseShelf.
     * @example
     * // Update or create a WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.upsert({
     *   create: {
     *     // ... data to create a WarehouseShelf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseShelf we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseShelfUpsertArgs>(args: SelectSubset<T, WarehouseShelfUpsertArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseShelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfCountArgs} args - Arguments to filter WarehouseShelves to count.
     * @example
     * // Count the number of WarehouseShelves
     * const count = await prisma.warehouseShelf.count({
     *   where: {
     *     // ... the filter for the WarehouseShelves we want to count
     *   }
     * })
    **/
    count<T extends WarehouseShelfCountArgs>(
      args?: Subset<T, WarehouseShelfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseShelfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseShelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseShelfAggregateArgs>(args: Subset<T, WarehouseShelfAggregateArgs>): Prisma.PrismaPromise<GetWarehouseShelfAggregateType<T>>

    /**
     * Group by WarehouseShelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseShelfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseShelfGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseShelfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseShelfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseShelfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseShelf model
   */
  readonly fields: WarehouseShelfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseShelf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseShelfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bins<T extends WarehouseShelf$binsArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseShelf$binsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aisle<T extends WarehouseAisleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseAisleDefaultArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseShelf model
   */
  interface WarehouseShelfFieldRefs {
    readonly id: FieldRef<"WarehouseShelf", 'String'>
    readonly name: FieldRef<"WarehouseShelf", 'String'>
    readonly code: FieldRef<"WarehouseShelf", 'String'>
    readonly aisleId: FieldRef<"WarehouseShelf", 'String'>
    readonly createdAt: FieldRef<"WarehouseShelf", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseShelf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseShelf findUnique
   */
  export type WarehouseShelfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf findUniqueOrThrow
   */
  export type WarehouseShelfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf findFirst
   */
  export type WarehouseShelfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseShelves.
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseShelves.
     */
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseShelf findFirstOrThrow
   */
  export type WarehouseShelfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseShelves.
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseShelves.
     */
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseShelf findMany
   */
  export type WarehouseShelfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelves to fetch.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseShelves.
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseShelf create
   */
  export type WarehouseShelfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseShelf.
     */
    data: XOR<WarehouseShelfCreateInput, WarehouseShelfUncheckedCreateInput>
  }

  /**
   * WarehouseShelf createMany
   */
  export type WarehouseShelfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseShelves.
     */
    data: WarehouseShelfCreateManyInput | WarehouseShelfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseShelf createManyAndReturn
   */
  export type WarehouseShelfCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseShelves.
     */
    data: WarehouseShelfCreateManyInput | WarehouseShelfCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseShelf update
   */
  export type WarehouseShelfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseShelf.
     */
    data: XOR<WarehouseShelfUpdateInput, WarehouseShelfUncheckedUpdateInput>
    /**
     * Choose, which WarehouseShelf to update.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf updateMany
   */
  export type WarehouseShelfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseShelves.
     */
    data: XOR<WarehouseShelfUpdateManyMutationInput, WarehouseShelfUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseShelves to update
     */
    where?: WarehouseShelfWhereInput
    /**
     * Limit how many WarehouseShelves to update.
     */
    limit?: number
  }

  /**
   * WarehouseShelf updateManyAndReturn
   */
  export type WarehouseShelfUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseShelves.
     */
    data: XOR<WarehouseShelfUpdateManyMutationInput, WarehouseShelfUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseShelves to update
     */
    where?: WarehouseShelfWhereInput
    /**
     * Limit how many WarehouseShelves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseShelf upsert
   */
  export type WarehouseShelfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseShelf to update in case it exists.
     */
    where: WarehouseShelfWhereUniqueInput
    /**
     * In case the WarehouseShelf found by the `where` argument doesn't exist, create a new WarehouseShelf with this data.
     */
    create: XOR<WarehouseShelfCreateInput, WarehouseShelfUncheckedCreateInput>
    /**
     * In case the WarehouseShelf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseShelfUpdateInput, WarehouseShelfUncheckedUpdateInput>
  }

  /**
   * WarehouseShelf delete
   */
  export type WarehouseShelfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter which WarehouseShelf to delete.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf deleteMany
   */
  export type WarehouseShelfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseShelves to delete
     */
    where?: WarehouseShelfWhereInput
    /**
     * Limit how many WarehouseShelves to delete.
     */
    limit?: number
  }

  /**
   * WarehouseShelf.bins
   */
  export type WarehouseShelf$binsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    where?: WarehouseBinWhereInput
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    cursor?: WarehouseBinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseShelf without action
   */
  export type WarehouseShelfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseBin
   */

  export type AggregateWarehouseBin = {
    _count: WarehouseBinCountAggregateOutputType | null
    _avg: WarehouseBinAvgAggregateOutputType | null
    _sum: WarehouseBinSumAggregateOutputType | null
    _min: WarehouseBinMinAggregateOutputType | null
    _max: WarehouseBinMaxAggregateOutputType | null
  }

  export type WarehouseBinAvgAggregateOutputType = {
    capacity: number | null
  }

  export type WarehouseBinSumAggregateOutputType = {
    capacity: number | null
  }

  export type WarehouseBinMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    shelfId: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseBinMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    shelfId: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseBinCountAggregateOutputType = {
    id: number
    name: number
    code: number
    shelfId: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseBinAvgAggregateInputType = {
    capacity?: true
  }

  export type WarehouseBinSumAggregateInputType = {
    capacity?: true
  }

  export type WarehouseBinMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    shelfId?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseBinMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    shelfId?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseBinCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    shelfId?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseBinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseBin to aggregate.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseBins
    **/
    _count?: true | WarehouseBinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseBinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseBinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseBinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseBinMaxAggregateInputType
  }

  export type GetWarehouseBinAggregateType<T extends WarehouseBinAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseBin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseBin[P]>
      : GetScalarType<T[P], AggregateWarehouseBin[P]>
  }




  export type WarehouseBinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseBinWhereInput
    orderBy?: WarehouseBinOrderByWithAggregationInput | WarehouseBinOrderByWithAggregationInput[]
    by: WarehouseBinScalarFieldEnum[] | WarehouseBinScalarFieldEnum
    having?: WarehouseBinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseBinCountAggregateInputType | true
    _avg?: WarehouseBinAvgAggregateInputType
    _sum?: WarehouseBinSumAggregateInputType
    _min?: WarehouseBinMinAggregateInputType
    _max?: WarehouseBinMaxAggregateInputType
  }

  export type WarehouseBinGroupByOutputType = {
    id: string
    name: string
    code: string
    shelfId: string
    capacity: number | null
    createdAt: Date
    updatedAt: Date
    _count: WarehouseBinCountAggregateOutputType | null
    _avg: WarehouseBinAvgAggregateOutputType | null
    _sum: WarehouseBinSumAggregateOutputType | null
    _min: WarehouseBinMinAggregateOutputType | null
    _max: WarehouseBinMaxAggregateOutputType | null
  }

  type GetWarehouseBinGroupByPayload<T extends WarehouseBinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseBinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseBinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseBinGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseBinGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseBinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItems?: boolean | WarehouseBin$inventoryItemsArgs<ExtArgs>
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseBinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseBin"]>

  export type WarehouseBinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseBin"]>

  export type WarehouseBinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseBin"]>

  export type WarehouseBinSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseBinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "shelfId" | "capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseBin"]>
  export type WarehouseBinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | WarehouseBin$inventoryItemsArgs<ExtArgs>
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
    _count?: boolean | WarehouseBinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseBinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }
  export type WarehouseBinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }

  export type $WarehouseBinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseBin"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      shelf: Prisma.$WarehouseShelfPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      shelfId: string
      capacity: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseBin"]>
    composites: {}
  }

  type WarehouseBinGetPayload<S extends boolean | null | undefined | WarehouseBinDefaultArgs> = $Result.GetResult<Prisma.$WarehouseBinPayload, S>

  type WarehouseBinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseBinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseBinCountAggregateInputType | true
    }

  export interface WarehouseBinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseBin'], meta: { name: 'WarehouseBin' } }
    /**
     * Find zero or one WarehouseBin that matches the filter.
     * @param {WarehouseBinFindUniqueArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseBinFindUniqueArgs>(args: SelectSubset<T, WarehouseBinFindUniqueArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseBin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseBinFindUniqueOrThrowArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseBinFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseBinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseBin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinFindFirstArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseBinFindFirstArgs>(args?: SelectSubset<T, WarehouseBinFindFirstArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseBin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinFindFirstOrThrowArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseBinFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseBinFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseBins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseBins
     * const warehouseBins = await prisma.warehouseBin.findMany()
     * 
     * // Get first 10 WarehouseBins
     * const warehouseBins = await prisma.warehouseBin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseBinWithIdOnly = await prisma.warehouseBin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseBinFindManyArgs>(args?: SelectSubset<T, WarehouseBinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseBin.
     * @param {WarehouseBinCreateArgs} args - Arguments to create a WarehouseBin.
     * @example
     * // Create one WarehouseBin
     * const WarehouseBin = await prisma.warehouseBin.create({
     *   data: {
     *     // ... data to create a WarehouseBin
     *   }
     * })
     * 
     */
    create<T extends WarehouseBinCreateArgs>(args: SelectSubset<T, WarehouseBinCreateArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseBins.
     * @param {WarehouseBinCreateManyArgs} args - Arguments to create many WarehouseBins.
     * @example
     * // Create many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseBinCreateManyArgs>(args?: SelectSubset<T, WarehouseBinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseBins and returns the data saved in the database.
     * @param {WarehouseBinCreateManyAndReturnArgs} args - Arguments to create many WarehouseBins.
     * @example
     * // Create many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseBins and only return the `id`
     * const warehouseBinWithIdOnly = await prisma.warehouseBin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseBinCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseBinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseBin.
     * @param {WarehouseBinDeleteArgs} args - Arguments to delete one WarehouseBin.
     * @example
     * // Delete one WarehouseBin
     * const WarehouseBin = await prisma.warehouseBin.delete({
     *   where: {
     *     // ... filter to delete one WarehouseBin
     *   }
     * })
     * 
     */
    delete<T extends WarehouseBinDeleteArgs>(args: SelectSubset<T, WarehouseBinDeleteArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseBin.
     * @param {WarehouseBinUpdateArgs} args - Arguments to update one WarehouseBin.
     * @example
     * // Update one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseBinUpdateArgs>(args: SelectSubset<T, WarehouseBinUpdateArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseBins.
     * @param {WarehouseBinDeleteManyArgs} args - Arguments to filter WarehouseBins to delete.
     * @example
     * // Delete a few WarehouseBins
     * const { count } = await prisma.warehouseBin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseBinDeleteManyArgs>(args?: SelectSubset<T, WarehouseBinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseBins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseBinUpdateManyArgs>(args: SelectSubset<T, WarehouseBinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseBins and returns the data updated in the database.
     * @param {WarehouseBinUpdateManyAndReturnArgs} args - Arguments to update many WarehouseBins.
     * @example
     * // Update many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseBins and only return the `id`
     * const warehouseBinWithIdOnly = await prisma.warehouseBin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseBinUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseBinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseBin.
     * @param {WarehouseBinUpsertArgs} args - Arguments to update or create a WarehouseBin.
     * @example
     * // Update or create a WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.upsert({
     *   create: {
     *     // ... data to create a WarehouseBin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseBin we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseBinUpsertArgs>(args: SelectSubset<T, WarehouseBinUpsertArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseBins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinCountArgs} args - Arguments to filter WarehouseBins to count.
     * @example
     * // Count the number of WarehouseBins
     * const count = await prisma.warehouseBin.count({
     *   where: {
     *     // ... the filter for the WarehouseBins we want to count
     *   }
     * })
    **/
    count<T extends WarehouseBinCountArgs>(
      args?: Subset<T, WarehouseBinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseBinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseBin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseBinAggregateArgs>(args: Subset<T, WarehouseBinAggregateArgs>): Prisma.PrismaPromise<GetWarehouseBinAggregateType<T>>

    /**
     * Group by WarehouseBin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseBinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseBinGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseBinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseBinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseBinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseBin model
   */
  readonly fields: WarehouseBinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseBin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseBinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends WarehouseBin$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseBin$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shelf<T extends WarehouseShelfDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseShelfDefaultArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseBin model
   */
  interface WarehouseBinFieldRefs {
    readonly id: FieldRef<"WarehouseBin", 'String'>
    readonly name: FieldRef<"WarehouseBin", 'String'>
    readonly code: FieldRef<"WarehouseBin", 'String'>
    readonly shelfId: FieldRef<"WarehouseBin", 'String'>
    readonly capacity: FieldRef<"WarehouseBin", 'Int'>
    readonly createdAt: FieldRef<"WarehouseBin", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseBin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseBin findUnique
   */
  export type WarehouseBinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin findUniqueOrThrow
   */
  export type WarehouseBinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin findFirst
   */
  export type WarehouseBinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseBins.
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseBins.
     */
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseBin findFirstOrThrow
   */
  export type WarehouseBinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseBins.
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseBins.
     */
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseBin findMany
   */
  export type WarehouseBinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBins to fetch.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseBins.
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseBin create
   */
  export type WarehouseBinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseBin.
     */
    data: XOR<WarehouseBinCreateInput, WarehouseBinUncheckedCreateInput>
  }

  /**
   * WarehouseBin createMany
   */
  export type WarehouseBinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseBins.
     */
    data: WarehouseBinCreateManyInput | WarehouseBinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseBin createManyAndReturn
   */
  export type WarehouseBinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseBins.
     */
    data: WarehouseBinCreateManyInput | WarehouseBinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseBin update
   */
  export type WarehouseBinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseBin.
     */
    data: XOR<WarehouseBinUpdateInput, WarehouseBinUncheckedUpdateInput>
    /**
     * Choose, which WarehouseBin to update.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin updateMany
   */
  export type WarehouseBinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseBins.
     */
    data: XOR<WarehouseBinUpdateManyMutationInput, WarehouseBinUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseBins to update
     */
    where?: WarehouseBinWhereInput
    /**
     * Limit how many WarehouseBins to update.
     */
    limit?: number
  }

  /**
   * WarehouseBin updateManyAndReturn
   */
  export type WarehouseBinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseBins.
     */
    data: XOR<WarehouseBinUpdateManyMutationInput, WarehouseBinUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseBins to update
     */
    where?: WarehouseBinWhereInput
    /**
     * Limit how many WarehouseBins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseBin upsert
   */
  export type WarehouseBinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseBin to update in case it exists.
     */
    where: WarehouseBinWhereUniqueInput
    /**
     * In case the WarehouseBin found by the `where` argument doesn't exist, create a new WarehouseBin with this data.
     */
    create: XOR<WarehouseBinCreateInput, WarehouseBinUncheckedCreateInput>
    /**
     * In case the WarehouseBin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseBinUpdateInput, WarehouseBinUncheckedUpdateInput>
  }

  /**
   * WarehouseBin delete
   */
  export type WarehouseBinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter which WarehouseBin to delete.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin deleteMany
   */
  export type WarehouseBinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseBins to delete
     */
    where?: WarehouseBinWhereInput
    /**
     * Limit how many WarehouseBins to delete.
     */
    limit?: number
  }

  /**
   * WarehouseBin.inventoryItems
   */
  export type WarehouseBin$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * WarehouseBin without action
   */
  export type WarehouseBinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseStaff
   */

  export type AggregateWarehouseStaff = {
    _count: WarehouseStaffCountAggregateOutputType | null
    _min: WarehouseStaffMinAggregateOutputType | null
    _max: WarehouseStaffMaxAggregateOutputType | null
  }

  export type WarehouseStaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    warehouseId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseStaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    warehouseId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseStaffCountAggregateOutputType = {
    id: number
    userId: number
    warehouseId: number
    position: number
    isManager: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseStaffMinAggregateInputType = {
    id?: true
    userId?: true
    warehouseId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseStaffMaxAggregateInputType = {
    id?: true
    userId?: true
    warehouseId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseStaffCountAggregateInputType = {
    id?: true
    userId?: true
    warehouseId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseStaff to aggregate.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseStaffs
    **/
    _count?: true | WarehouseStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseStaffMaxAggregateInputType
  }

  export type GetWarehouseStaffAggregateType<T extends WarehouseStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseStaff[P]>
      : GetScalarType<T[P], AggregateWarehouseStaff[P]>
  }




  export type WarehouseStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseStaffWhereInput
    orderBy?: WarehouseStaffOrderByWithAggregationInput | WarehouseStaffOrderByWithAggregationInput[]
    by: WarehouseStaffScalarFieldEnum[] | WarehouseStaffScalarFieldEnum
    having?: WarehouseStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseStaffCountAggregateInputType | true
    _min?: WarehouseStaffMinAggregateInputType
    _max?: WarehouseStaffMaxAggregateInputType
  }

  export type WarehouseStaffGroupByOutputType = {
    id: string
    userId: string
    warehouseId: string
    position: string | null
    isManager: boolean
    createdAt: Date
    updatedAt: Date
    _count: WarehouseStaffCountAggregateOutputType | null
    _min: WarehouseStaffMinAggregateOutputType | null
    _max: WarehouseStaffMaxAggregateOutputType | null
  }

  type GetWarehouseStaffGroupByPayload<T extends WarehouseStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseStaffGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseStaffGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseStaff"]>

  export type WarehouseStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseStaff"]>

  export type WarehouseStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseStaff"]>

  export type WarehouseStaffSelectScalar = {
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "warehouseId" | "position" | "isManager" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseStaff"]>
  export type WarehouseStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type WarehouseStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type WarehouseStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $WarehouseStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      warehouseId: string
      position: string | null
      isManager: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseStaff"]>
    composites: {}
  }

  type WarehouseStaffGetPayload<S extends boolean | null | undefined | WarehouseStaffDefaultArgs> = $Result.GetResult<Prisma.$WarehouseStaffPayload, S>

  type WarehouseStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseStaffCountAggregateInputType | true
    }

  export interface WarehouseStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseStaff'], meta: { name: 'WarehouseStaff' } }
    /**
     * Find zero or one WarehouseStaff that matches the filter.
     * @param {WarehouseStaffFindUniqueArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseStaffFindUniqueArgs>(args: SelectSubset<T, WarehouseStaffFindUniqueArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseStaffFindUniqueOrThrowArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffFindFirstArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseStaffFindFirstArgs>(args?: SelectSubset<T, WarehouseStaffFindFirstArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffFindFirstOrThrowArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseStaffs
     * const warehouseStaffs = await prisma.warehouseStaff.findMany()
     * 
     * // Get first 10 WarehouseStaffs
     * const warehouseStaffs = await prisma.warehouseStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseStaffWithIdOnly = await prisma.warehouseStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseStaffFindManyArgs>(args?: SelectSubset<T, WarehouseStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseStaff.
     * @param {WarehouseStaffCreateArgs} args - Arguments to create a WarehouseStaff.
     * @example
     * // Create one WarehouseStaff
     * const WarehouseStaff = await prisma.warehouseStaff.create({
     *   data: {
     *     // ... data to create a WarehouseStaff
     *   }
     * })
     * 
     */
    create<T extends WarehouseStaffCreateArgs>(args: SelectSubset<T, WarehouseStaffCreateArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseStaffs.
     * @param {WarehouseStaffCreateManyArgs} args - Arguments to create many WarehouseStaffs.
     * @example
     * // Create many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseStaffCreateManyArgs>(args?: SelectSubset<T, WarehouseStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseStaffs and returns the data saved in the database.
     * @param {WarehouseStaffCreateManyAndReturnArgs} args - Arguments to create many WarehouseStaffs.
     * @example
     * // Create many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseStaffs and only return the `id`
     * const warehouseStaffWithIdOnly = await prisma.warehouseStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseStaff.
     * @param {WarehouseStaffDeleteArgs} args - Arguments to delete one WarehouseStaff.
     * @example
     * // Delete one WarehouseStaff
     * const WarehouseStaff = await prisma.warehouseStaff.delete({
     *   where: {
     *     // ... filter to delete one WarehouseStaff
     *   }
     * })
     * 
     */
    delete<T extends WarehouseStaffDeleteArgs>(args: SelectSubset<T, WarehouseStaffDeleteArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseStaff.
     * @param {WarehouseStaffUpdateArgs} args - Arguments to update one WarehouseStaff.
     * @example
     * // Update one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseStaffUpdateArgs>(args: SelectSubset<T, WarehouseStaffUpdateArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseStaffs.
     * @param {WarehouseStaffDeleteManyArgs} args - Arguments to filter WarehouseStaffs to delete.
     * @example
     * // Delete a few WarehouseStaffs
     * const { count } = await prisma.warehouseStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseStaffDeleteManyArgs>(args?: SelectSubset<T, WarehouseStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseStaffUpdateManyArgs>(args: SelectSubset<T, WarehouseStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseStaffs and returns the data updated in the database.
     * @param {WarehouseStaffUpdateManyAndReturnArgs} args - Arguments to update many WarehouseStaffs.
     * @example
     * // Update many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseStaffs and only return the `id`
     * const warehouseStaffWithIdOnly = await prisma.warehouseStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseStaff.
     * @param {WarehouseStaffUpsertArgs} args - Arguments to update or create a WarehouseStaff.
     * @example
     * // Update or create a WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.upsert({
     *   create: {
     *     // ... data to create a WarehouseStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseStaff we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseStaffUpsertArgs>(args: SelectSubset<T, WarehouseStaffUpsertArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffCountArgs} args - Arguments to filter WarehouseStaffs to count.
     * @example
     * // Count the number of WarehouseStaffs
     * const count = await prisma.warehouseStaff.count({
     *   where: {
     *     // ... the filter for the WarehouseStaffs we want to count
     *   }
     * })
    **/
    count<T extends WarehouseStaffCountArgs>(
      args?: Subset<T, WarehouseStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseStaffAggregateArgs>(args: Subset<T, WarehouseStaffAggregateArgs>): Prisma.PrismaPromise<GetWarehouseStaffAggregateType<T>>

    /**
     * Group by WarehouseStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseStaffGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseStaff model
   */
  readonly fields: WarehouseStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseStaff model
   */
  interface WarehouseStaffFieldRefs {
    readonly id: FieldRef<"WarehouseStaff", 'String'>
    readonly userId: FieldRef<"WarehouseStaff", 'String'>
    readonly warehouseId: FieldRef<"WarehouseStaff", 'String'>
    readonly position: FieldRef<"WarehouseStaff", 'String'>
    readonly isManager: FieldRef<"WarehouseStaff", 'Boolean'>
    readonly createdAt: FieldRef<"WarehouseStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseStaff findUnique
   */
  export type WarehouseStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff findUniqueOrThrow
   */
  export type WarehouseStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff findFirst
   */
  export type WarehouseStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseStaffs.
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseStaffs.
     */
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * WarehouseStaff findFirstOrThrow
   */
  export type WarehouseStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseStaffs.
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseStaffs.
     */
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * WarehouseStaff findMany
   */
  export type WarehouseStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaffs to fetch.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseStaffs.
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * WarehouseStaff create
   */
  export type WarehouseStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseStaff.
     */
    data: XOR<WarehouseStaffCreateInput, WarehouseStaffUncheckedCreateInput>
  }

  /**
   * WarehouseStaff createMany
   */
  export type WarehouseStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseStaffs.
     */
    data: WarehouseStaffCreateManyInput | WarehouseStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseStaff createManyAndReturn
   */
  export type WarehouseStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseStaffs.
     */
    data: WarehouseStaffCreateManyInput | WarehouseStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseStaff update
   */
  export type WarehouseStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseStaff.
     */
    data: XOR<WarehouseStaffUpdateInput, WarehouseStaffUncheckedUpdateInput>
    /**
     * Choose, which WarehouseStaff to update.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff updateMany
   */
  export type WarehouseStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseStaffs.
     */
    data: XOR<WarehouseStaffUpdateManyMutationInput, WarehouseStaffUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseStaffs to update
     */
    where?: WarehouseStaffWhereInput
    /**
     * Limit how many WarehouseStaffs to update.
     */
    limit?: number
  }

  /**
   * WarehouseStaff updateManyAndReturn
   */
  export type WarehouseStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseStaffs.
     */
    data: XOR<WarehouseStaffUpdateManyMutationInput, WarehouseStaffUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseStaffs to update
     */
    where?: WarehouseStaffWhereInput
    /**
     * Limit how many WarehouseStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseStaff upsert
   */
  export type WarehouseStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseStaff to update in case it exists.
     */
    where: WarehouseStaffWhereUniqueInput
    /**
     * In case the WarehouseStaff found by the `where` argument doesn't exist, create a new WarehouseStaff with this data.
     */
    create: XOR<WarehouseStaffCreateInput, WarehouseStaffUncheckedCreateInput>
    /**
     * In case the WarehouseStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseStaffUpdateInput, WarehouseStaffUncheckedUpdateInput>
  }

  /**
   * WarehouseStaff delete
   */
  export type WarehouseStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter which WarehouseStaff to delete.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff deleteMany
   */
  export type WarehouseStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseStaffs to delete
     */
    where?: WarehouseStaffWhereInput
    /**
     * Limit how many WarehouseStaffs to delete.
     */
    limit?: number
  }

  /**
   * WarehouseStaff without action
   */
  export type WarehouseStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    phone: string | null
    email: string | null
    openingHours: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    phone: string | null
    email: string | null
    openingHours: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    code: number
    address: number
    phone: number
    email: number
    openingHours: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    name: string
    code: string
    address: string | null
    phone: string | null
    email: string | null
    openingHours: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItems?: boolean | Store$inventoryItemsArgs<ExtArgs>
    sales?: boolean | Store$salesArgs<ExtArgs>
    staff?: boolean | Store$staffArgs<ExtArgs>
    Transfer_Transfer_destinationStoreIdToStore?: boolean | Store$Transfer_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Transfer_Transfer_sourceStoreIdToStore?: boolean | Store$Transfer_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "address" | "phone" | "email" | "openingHours" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | Store$inventoryItemsArgs<ExtArgs>
    sales?: boolean | Store$salesArgs<ExtArgs>
    staff?: boolean | Store$staffArgs<ExtArgs>
    Transfer_Transfer_destinationStoreIdToStore?: boolean | Store$Transfer_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Transfer_Transfer_sourceStoreIdToStore?: boolean | Store$Transfer_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      staff: Prisma.$StoreStaffPayload<ExtArgs>[]
      Transfer_Transfer_destinationStoreIdToStore: Prisma.$TransferPayload<ExtArgs>[]
      Transfer_Transfer_sourceStoreIdToStore: Prisma.$TransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      address: string | null
      phone: string | null
      email: string | null
      openingHours: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends Store$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Store$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Store$salesArgs<ExtArgs> = {}>(args?: Subset<T, Store$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Store$staffArgs<ExtArgs> = {}>(args?: Subset<T, Store$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_destinationStoreIdToStore<T extends Store$Transfer_Transfer_destinationStoreIdToStoreArgs<ExtArgs> = {}>(args?: Subset<T, Store$Transfer_Transfer_destinationStoreIdToStoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transfer_Transfer_sourceStoreIdToStore<T extends Store$Transfer_Transfer_sourceStoreIdToStoreArgs<ExtArgs> = {}>(args?: Subset<T, Store$Transfer_Transfer_sourceStoreIdToStoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly code: FieldRef<"Store", 'String'>
    readonly address: FieldRef<"Store", 'String'>
    readonly phone: FieldRef<"Store", 'String'>
    readonly email: FieldRef<"Store", 'String'>
    readonly openingHours: FieldRef<"Store", 'String'>
    readonly isActive: FieldRef<"Store", 'Boolean'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.inventoryItems
   */
  export type Store$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Store.sales
   */
  export type Store$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Store.staff
   */
  export type Store$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    where?: StoreStaffWhereInput
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    cursor?: StoreStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * Store.Transfer_Transfer_destinationStoreIdToStore
   */
  export type Store$Transfer_Transfer_destinationStoreIdToStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Store.Transfer_Transfer_sourceStoreIdToStore
   */
  export type Store$Transfer_Transfer_sourceStoreIdToStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model StoreStaff
   */

  export type AggregateStoreStaff = {
    _count: StoreStaffCountAggregateOutputType | null
    _min: StoreStaffMinAggregateOutputType | null
    _max: StoreStaffMaxAggregateOutputType | null
  }

  export type StoreStaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    storeId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreStaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    storeId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreStaffCountAggregateOutputType = {
    id: number
    userId: number
    storeId: number
    position: number
    isManager: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreStaffMinAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreStaffMaxAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreStaffCountAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreStaff to aggregate.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreStaffs
    **/
    _count?: true | StoreStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreStaffMaxAggregateInputType
  }

  export type GetStoreStaffAggregateType<T extends StoreStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreStaff[P]>
      : GetScalarType<T[P], AggregateStoreStaff[P]>
  }




  export type StoreStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStaffWhereInput
    orderBy?: StoreStaffOrderByWithAggregationInput | StoreStaffOrderByWithAggregationInput[]
    by: StoreStaffScalarFieldEnum[] | StoreStaffScalarFieldEnum
    having?: StoreStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreStaffCountAggregateInputType | true
    _min?: StoreStaffMinAggregateInputType
    _max?: StoreStaffMaxAggregateInputType
  }

  export type StoreStaffGroupByOutputType = {
    id: string
    userId: string
    storeId: string
    position: string | null
    isManager: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreStaffCountAggregateOutputType | null
    _min: StoreStaffMinAggregateOutputType | null
    _max: StoreStaffMaxAggregateOutputType | null
  }

  type GetStoreStaffGroupByPayload<T extends StoreStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreStaffGroupByOutputType[P]>
            : GetScalarType<T[P], StoreStaffGroupByOutputType[P]>
        }
      >
    >


  export type StoreStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStaff"]>

  export type StoreStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStaff"]>

  export type StoreStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStaff"]>

  export type StoreStaffSelectScalar = {
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "storeId" | "position" | "isManager" | "createdAt" | "updatedAt", ExtArgs["result"]["storeStaff"]>
  export type StoreStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoreStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StoreStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StoreStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreStaff"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      storeId: string
      position: string | null
      isManager: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeStaff"]>
    composites: {}
  }

  type StoreStaffGetPayload<S extends boolean | null | undefined | StoreStaffDefaultArgs> = $Result.GetResult<Prisma.$StoreStaffPayload, S>

  type StoreStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreStaffCountAggregateInputType | true
    }

  export interface StoreStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreStaff'], meta: { name: 'StoreStaff' } }
    /**
     * Find zero or one StoreStaff that matches the filter.
     * @param {StoreStaffFindUniqueArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreStaffFindUniqueArgs>(args: SelectSubset<T, StoreStaffFindUniqueArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoreStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreStaffFindUniqueOrThrowArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffFindFirstArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreStaffFindFirstArgs>(args?: SelectSubset<T, StoreStaffFindFirstArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffFindFirstOrThrowArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoreStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreStaffs
     * const storeStaffs = await prisma.storeStaff.findMany()
     * 
     * // Get first 10 StoreStaffs
     * const storeStaffs = await prisma.storeStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeStaffWithIdOnly = await prisma.storeStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreStaffFindManyArgs>(args?: SelectSubset<T, StoreStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoreStaff.
     * @param {StoreStaffCreateArgs} args - Arguments to create a StoreStaff.
     * @example
     * // Create one StoreStaff
     * const StoreStaff = await prisma.storeStaff.create({
     *   data: {
     *     // ... data to create a StoreStaff
     *   }
     * })
     * 
     */
    create<T extends StoreStaffCreateArgs>(args: SelectSubset<T, StoreStaffCreateArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoreStaffs.
     * @param {StoreStaffCreateManyArgs} args - Arguments to create many StoreStaffs.
     * @example
     * // Create many StoreStaffs
     * const storeStaff = await prisma.storeStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreStaffCreateManyArgs>(args?: SelectSubset<T, StoreStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreStaffs and returns the data saved in the database.
     * @param {StoreStaffCreateManyAndReturnArgs} args - Arguments to create many StoreStaffs.
     * @example
     * // Create many StoreStaffs
     * const storeStaff = await prisma.storeStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreStaffs and only return the `id`
     * const storeStaffWithIdOnly = await prisma.storeStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoreStaff.
     * @param {StoreStaffDeleteArgs} args - Arguments to delete one StoreStaff.
     * @example
     * // Delete one StoreStaff
     * const StoreStaff = await prisma.storeStaff.delete({
     *   where: {
     *     // ... filter to delete one StoreStaff
     *   }
     * })
     * 
     */
    delete<T extends StoreStaffDeleteArgs>(args: SelectSubset<T, StoreStaffDeleteArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoreStaff.
     * @param {StoreStaffUpdateArgs} args - Arguments to update one StoreStaff.
     * @example
     * // Update one StoreStaff
     * const storeStaff = await prisma.storeStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreStaffUpdateArgs>(args: SelectSubset<T, StoreStaffUpdateArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoreStaffs.
     * @param {StoreStaffDeleteManyArgs} args - Arguments to filter StoreStaffs to delete.
     * @example
     * // Delete a few StoreStaffs
     * const { count } = await prisma.storeStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreStaffDeleteManyArgs>(args?: SelectSubset<T, StoreStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreStaffs
     * const storeStaff = await prisma.storeStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreStaffUpdateManyArgs>(args: SelectSubset<T, StoreStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreStaffs and returns the data updated in the database.
     * @param {StoreStaffUpdateManyAndReturnArgs} args - Arguments to update many StoreStaffs.
     * @example
     * // Update many StoreStaffs
     * const storeStaff = await prisma.storeStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoreStaffs and only return the `id`
     * const storeStaffWithIdOnly = await prisma.storeStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoreStaff.
     * @param {StoreStaffUpsertArgs} args - Arguments to update or create a StoreStaff.
     * @example
     * // Update or create a StoreStaff
     * const storeStaff = await prisma.storeStaff.upsert({
     *   create: {
     *     // ... data to create a StoreStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreStaff we want to update
     *   }
     * })
     */
    upsert<T extends StoreStaffUpsertArgs>(args: SelectSubset<T, StoreStaffUpsertArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoreStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffCountArgs} args - Arguments to filter StoreStaffs to count.
     * @example
     * // Count the number of StoreStaffs
     * const count = await prisma.storeStaff.count({
     *   where: {
     *     // ... the filter for the StoreStaffs we want to count
     *   }
     * })
    **/
    count<T extends StoreStaffCountArgs>(
      args?: Subset<T, StoreStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreStaffAggregateArgs>(args: Subset<T, StoreStaffAggregateArgs>): Prisma.PrismaPromise<GetStoreStaffAggregateType<T>>

    /**
     * Group by StoreStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreStaffGroupByArgs['orderBy'] }
        : { orderBy?: StoreStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreStaff model
   */
  readonly fields: StoreStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreStaff model
   */
  interface StoreStaffFieldRefs {
    readonly id: FieldRef<"StoreStaff", 'String'>
    readonly userId: FieldRef<"StoreStaff", 'String'>
    readonly storeId: FieldRef<"StoreStaff", 'String'>
    readonly position: FieldRef<"StoreStaff", 'String'>
    readonly isManager: FieldRef<"StoreStaff", 'Boolean'>
    readonly createdAt: FieldRef<"StoreStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreStaff findUnique
   */
  export type StoreStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff findUniqueOrThrow
   */
  export type StoreStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff findFirst
   */
  export type StoreStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreStaffs.
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreStaffs.
     */
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * StoreStaff findFirstOrThrow
   */
  export type StoreStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreStaffs.
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreStaffs.
     */
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * StoreStaff findMany
   */
  export type StoreStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaffs to fetch.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreStaffs.
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * StoreStaff create
   */
  export type StoreStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreStaff.
     */
    data: XOR<StoreStaffCreateInput, StoreStaffUncheckedCreateInput>
  }

  /**
   * StoreStaff createMany
   */
  export type StoreStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreStaffs.
     */
    data: StoreStaffCreateManyInput | StoreStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreStaff createManyAndReturn
   */
  export type StoreStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * The data used to create many StoreStaffs.
     */
    data: StoreStaffCreateManyInput | StoreStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreStaff update
   */
  export type StoreStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreStaff.
     */
    data: XOR<StoreStaffUpdateInput, StoreStaffUncheckedUpdateInput>
    /**
     * Choose, which StoreStaff to update.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff updateMany
   */
  export type StoreStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreStaffs.
     */
    data: XOR<StoreStaffUpdateManyMutationInput, StoreStaffUncheckedUpdateManyInput>
    /**
     * Filter which StoreStaffs to update
     */
    where?: StoreStaffWhereInput
    /**
     * Limit how many StoreStaffs to update.
     */
    limit?: number
  }

  /**
   * StoreStaff updateManyAndReturn
   */
  export type StoreStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * The data used to update StoreStaffs.
     */
    data: XOR<StoreStaffUpdateManyMutationInput, StoreStaffUncheckedUpdateManyInput>
    /**
     * Filter which StoreStaffs to update
     */
    where?: StoreStaffWhereInput
    /**
     * Limit how many StoreStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreStaff upsert
   */
  export type StoreStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreStaff to update in case it exists.
     */
    where: StoreStaffWhereUniqueInput
    /**
     * In case the StoreStaff found by the `where` argument doesn't exist, create a new StoreStaff with this data.
     */
    create: XOR<StoreStaffCreateInput, StoreStaffUncheckedCreateInput>
    /**
     * In case the StoreStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreStaffUpdateInput, StoreStaffUncheckedUpdateInput>
  }

  /**
   * StoreStaff delete
   */
  export type StoreStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter which StoreStaff to delete.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff deleteMany
   */
  export type StoreStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreStaffs to delete
     */
    where?: StoreStaffWhereInput
    /**
     * Limit how many StoreStaffs to delete.
     */
    limit?: number
  }

  /**
   * StoreStaff without action
   */
  export type StoreStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    taxId: string | null
    paymentTerms: string | null
    notes: string | null
    isActive: boolean | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    taxId: string | null
    paymentTerms: string | null
    notes: string | null
    isActive: boolean | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    postalCode: number
    country: number
    taxId: number
    paymentTerms: number
    notes: number
    isActive: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    taxId?: true
    paymentTerms?: true
    notes?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    taxId?: true
    paymentTerms?: true
    notes?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    taxId?: true
    paymentTerms?: true
    notes?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    taxId: string | null
    paymentTerms: string | null
    notes: string | null
    isActive: boolean
    createdById: string
    updatedById: string
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Supplier$productsArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    User_Supplier_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Supplier_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    contracts?: boolean | Supplier$contractsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Supplier_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Supplier_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Supplier_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Supplier_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contactPerson" | "email" | "phone" | "address" | "city" | "state" | "postalCode" | "country" | "taxId" | "paymentTerms" | "notes" | "isActive" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Supplier$productsArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    User_Supplier_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Supplier_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    contracts?: boolean | Supplier$contractsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Supplier_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Supplier_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Supplier_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Supplier_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      User_Supplier_createdByIdToUser: Prisma.$UserPayload<ExtArgs>
      User_Supplier_updatedByIdToUser: Prisma.$UserPayload<ExtArgs>
      contracts: Prisma.$SupplierContractPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      taxId: string | null
      paymentTerms: string | null
      notes: string | null
      isActive: boolean
      createdById: string
      updatedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Supplier$productsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User_Supplier_createdByIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User_Supplier_updatedByIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contracts<T extends Supplier$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly city: FieldRef<"Supplier", 'String'>
    readonly state: FieldRef<"Supplier", 'String'>
    readonly postalCode: FieldRef<"Supplier", 'String'>
    readonly country: FieldRef<"Supplier", 'String'>
    readonly taxId: FieldRef<"Supplier", 'String'>
    readonly paymentTerms: FieldRef<"Supplier", 'String'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdById: FieldRef<"Supplier", 'String'>
    readonly updatedById: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.products
   */
  export type Supplier$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier.contracts
   */
  export type Supplier$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    where?: SupplierContractWhereInput
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    cursor?: SupplierContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierContract
   */

  export type AggregateSupplierContract = {
    _count: SupplierContractCountAggregateOutputType | null
    _min: SupplierContractMinAggregateOutputType | null
    _max: SupplierContractMaxAggregateOutputType | null
  }

  export type SupplierContractMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    startDate: Date | null
    endDate: Date | null
    terms: string | null
    attachments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierContractMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    startDate: Date | null
    endDate: Date | null
    terms: string | null
    attachments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierContractCountAggregateOutputType = {
    id: number
    supplierId: number
    startDate: number
    endDate: number
    terms: number
    attachments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierContractMinAggregateInputType = {
    id?: true
    supplierId?: true
    startDate?: true
    endDate?: true
    terms?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierContractMaxAggregateInputType = {
    id?: true
    supplierId?: true
    startDate?: true
    endDate?: true
    terms?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierContractCountAggregateInputType = {
    id?: true
    supplierId?: true
    startDate?: true
    endDate?: true
    terms?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierContract to aggregate.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierContracts
    **/
    _count?: true | SupplierContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierContractMaxAggregateInputType
  }

  export type GetSupplierContractAggregateType<T extends SupplierContractAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierContract[P]>
      : GetScalarType<T[P], AggregateSupplierContract[P]>
  }




  export type SupplierContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierContractWhereInput
    orderBy?: SupplierContractOrderByWithAggregationInput | SupplierContractOrderByWithAggregationInput[]
    by: SupplierContractScalarFieldEnum[] | SupplierContractScalarFieldEnum
    having?: SupplierContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierContractCountAggregateInputType | true
    _min?: SupplierContractMinAggregateInputType
    _max?: SupplierContractMaxAggregateInputType
  }

  export type SupplierContractGroupByOutputType = {
    id: string
    supplierId: string
    startDate: Date
    endDate: Date | null
    terms: string | null
    attachments: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierContractCountAggregateOutputType | null
    _min: SupplierContractMinAggregateOutputType | null
    _max: SupplierContractMaxAggregateOutputType | null
  }

  type GetSupplierContractGroupByPayload<T extends SupplierContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierContractGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierContractGroupByOutputType[P]>
        }
      >
    >


  export type SupplierContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierContract"]>

  export type SupplierContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierContract"]>

  export type SupplierContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierContract"]>

  export type SupplierContractSelectScalar = {
    id?: boolean
    supplierId?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierId" | "startDate" | "endDate" | "terms" | "attachments" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierContract"]>
  export type SupplierContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierContract"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      startDate: Date
      endDate: Date | null
      terms: string | null
      attachments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierContract"]>
    composites: {}
  }

  type SupplierContractGetPayload<S extends boolean | null | undefined | SupplierContractDefaultArgs> = $Result.GetResult<Prisma.$SupplierContractPayload, S>

  type SupplierContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierContractCountAggregateInputType | true
    }

  export interface SupplierContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierContract'], meta: { name: 'SupplierContract' } }
    /**
     * Find zero or one SupplierContract that matches the filter.
     * @param {SupplierContractFindUniqueArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierContractFindUniqueArgs>(args: SelectSubset<T, SupplierContractFindUniqueArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierContract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierContractFindUniqueOrThrowArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierContractFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractFindFirstArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierContractFindFirstArgs>(args?: SelectSubset<T, SupplierContractFindFirstArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractFindFirstOrThrowArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierContractFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierContracts
     * const supplierContracts = await prisma.supplierContract.findMany()
     * 
     * // Get first 10 SupplierContracts
     * const supplierContracts = await prisma.supplierContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierContractWithIdOnly = await prisma.supplierContract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierContractFindManyArgs>(args?: SelectSubset<T, SupplierContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierContract.
     * @param {SupplierContractCreateArgs} args - Arguments to create a SupplierContract.
     * @example
     * // Create one SupplierContract
     * const SupplierContract = await prisma.supplierContract.create({
     *   data: {
     *     // ... data to create a SupplierContract
     *   }
     * })
     * 
     */
    create<T extends SupplierContractCreateArgs>(args: SelectSubset<T, SupplierContractCreateArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierContracts.
     * @param {SupplierContractCreateManyArgs} args - Arguments to create many SupplierContracts.
     * @example
     * // Create many SupplierContracts
     * const supplierContract = await prisma.supplierContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierContractCreateManyArgs>(args?: SelectSubset<T, SupplierContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierContracts and returns the data saved in the database.
     * @param {SupplierContractCreateManyAndReturnArgs} args - Arguments to create many SupplierContracts.
     * @example
     * // Create many SupplierContracts
     * const supplierContract = await prisma.supplierContract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierContracts and only return the `id`
     * const supplierContractWithIdOnly = await prisma.supplierContract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierContractCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierContract.
     * @param {SupplierContractDeleteArgs} args - Arguments to delete one SupplierContract.
     * @example
     * // Delete one SupplierContract
     * const SupplierContract = await prisma.supplierContract.delete({
     *   where: {
     *     // ... filter to delete one SupplierContract
     *   }
     * })
     * 
     */
    delete<T extends SupplierContractDeleteArgs>(args: SelectSubset<T, SupplierContractDeleteArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierContract.
     * @param {SupplierContractUpdateArgs} args - Arguments to update one SupplierContract.
     * @example
     * // Update one SupplierContract
     * const supplierContract = await prisma.supplierContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierContractUpdateArgs>(args: SelectSubset<T, SupplierContractUpdateArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierContracts.
     * @param {SupplierContractDeleteManyArgs} args - Arguments to filter SupplierContracts to delete.
     * @example
     * // Delete a few SupplierContracts
     * const { count } = await prisma.supplierContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierContractDeleteManyArgs>(args?: SelectSubset<T, SupplierContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierContracts
     * const supplierContract = await prisma.supplierContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierContractUpdateManyArgs>(args: SelectSubset<T, SupplierContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierContracts and returns the data updated in the database.
     * @param {SupplierContractUpdateManyAndReturnArgs} args - Arguments to update many SupplierContracts.
     * @example
     * // Update many SupplierContracts
     * const supplierContract = await prisma.supplierContract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierContracts and only return the `id`
     * const supplierContractWithIdOnly = await prisma.supplierContract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierContractUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierContract.
     * @param {SupplierContractUpsertArgs} args - Arguments to update or create a SupplierContract.
     * @example
     * // Update or create a SupplierContract
     * const supplierContract = await prisma.supplierContract.upsert({
     *   create: {
     *     // ... data to create a SupplierContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierContract we want to update
     *   }
     * })
     */
    upsert<T extends SupplierContractUpsertArgs>(args: SelectSubset<T, SupplierContractUpsertArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractCountArgs} args - Arguments to filter SupplierContracts to count.
     * @example
     * // Count the number of SupplierContracts
     * const count = await prisma.supplierContract.count({
     *   where: {
     *     // ... the filter for the SupplierContracts we want to count
     *   }
     * })
    **/
    count<T extends SupplierContractCountArgs>(
      args?: Subset<T, SupplierContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierContractAggregateArgs>(args: Subset<T, SupplierContractAggregateArgs>): Prisma.PrismaPromise<GetSupplierContractAggregateType<T>>

    /**
     * Group by SupplierContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierContractGroupByArgs['orderBy'] }
        : { orderBy?: SupplierContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierContract model
   */
  readonly fields: SupplierContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierContract model
   */
  interface SupplierContractFieldRefs {
    readonly id: FieldRef<"SupplierContract", 'String'>
    readonly supplierId: FieldRef<"SupplierContract", 'String'>
    readonly startDate: FieldRef<"SupplierContract", 'DateTime'>
    readonly endDate: FieldRef<"SupplierContract", 'DateTime'>
    readonly terms: FieldRef<"SupplierContract", 'String'>
    readonly attachments: FieldRef<"SupplierContract", 'String'>
    readonly createdAt: FieldRef<"SupplierContract", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierContract findUnique
   */
  export type SupplierContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract findUniqueOrThrow
   */
  export type SupplierContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract findFirst
   */
  export type SupplierContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierContracts.
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierContracts.
     */
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * SupplierContract findFirstOrThrow
   */
  export type SupplierContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierContracts.
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierContracts.
     */
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * SupplierContract findMany
   */
  export type SupplierContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContracts to fetch.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierContracts.
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * SupplierContract create
   */
  export type SupplierContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierContract.
     */
    data: XOR<SupplierContractCreateInput, SupplierContractUncheckedCreateInput>
  }

  /**
   * SupplierContract createMany
   */
  export type SupplierContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierContracts.
     */
    data: SupplierContractCreateManyInput | SupplierContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierContract createManyAndReturn
   */
  export type SupplierContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierContracts.
     */
    data: SupplierContractCreateManyInput | SupplierContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierContract update
   */
  export type SupplierContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierContract.
     */
    data: XOR<SupplierContractUpdateInput, SupplierContractUncheckedUpdateInput>
    /**
     * Choose, which SupplierContract to update.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract updateMany
   */
  export type SupplierContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierContracts.
     */
    data: XOR<SupplierContractUpdateManyMutationInput, SupplierContractUncheckedUpdateManyInput>
    /**
     * Filter which SupplierContracts to update
     */
    where?: SupplierContractWhereInput
    /**
     * Limit how many SupplierContracts to update.
     */
    limit?: number
  }

  /**
   * SupplierContract updateManyAndReturn
   */
  export type SupplierContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * The data used to update SupplierContracts.
     */
    data: XOR<SupplierContractUpdateManyMutationInput, SupplierContractUncheckedUpdateManyInput>
    /**
     * Filter which SupplierContracts to update
     */
    where?: SupplierContractWhereInput
    /**
     * Limit how many SupplierContracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierContract upsert
   */
  export type SupplierContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierContract to update in case it exists.
     */
    where: SupplierContractWhereUniqueInput
    /**
     * In case the SupplierContract found by the `where` argument doesn't exist, create a new SupplierContract with this data.
     */
    create: XOR<SupplierContractCreateInput, SupplierContractUncheckedCreateInput>
    /**
     * In case the SupplierContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierContractUpdateInput, SupplierContractUncheckedUpdateInput>
  }

  /**
   * SupplierContract delete
   */
  export type SupplierContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter which SupplierContract to delete.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract deleteMany
   */
  export type SupplierContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierContracts to delete
     */
    where?: SupplierContractWhereInput
    /**
     * Limit how many SupplierContracts to delete.
     */
    limit?: number
  }

  /**
   * SupplierContract without action
   */
  export type SupplierContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    shipping: Decimal | null
    discount: Decimal | null
    total: Decimal | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    shipping: Decimal | null
    discount: Decimal | null
    total: Decimal | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    supplierId: string | null
    warehouseId: string | null
    status: string | null
    orderDate: Date | null
    expectedDeliveryDate: Date | null
    deliveredDate: Date | null
    subtotal: Decimal | null
    tax: Decimal | null
    shipping: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    supplierId: string | null
    warehouseId: string | null
    status: string | null
    orderDate: Date | null
    expectedDeliveryDate: Date | null
    deliveredDate: Date | null
    subtotal: Decimal | null
    tax: Decimal | null
    shipping: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    notes: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    supplierId: number
    warehouseId: number
    status: number
    orderDate: number
    expectedDeliveryDate: number
    deliveredDate: number
    subtotal: number
    tax: number
    shipping: number
    discount: number
    total: number
    notes: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    shipping?: true
    discount?: true
    total?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    subtotal?: true
    tax?: true
    shipping?: true
    discount?: true
    total?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    supplierId?: true
    warehouseId?: true
    status?: true
    orderDate?: true
    expectedDeliveryDate?: true
    deliveredDate?: true
    subtotal?: true
    tax?: true
    shipping?: true
    discount?: true
    total?: true
    notes?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    supplierId?: true
    warehouseId?: true
    status?: true
    orderDate?: true
    expectedDeliveryDate?: true
    deliveredDate?: true
    subtotal?: true
    tax?: true
    shipping?: true
    discount?: true
    total?: true
    notes?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    supplierId?: true
    warehouseId?: true
    status?: true
    orderDate?: true
    expectedDeliveryDate?: true
    deliveredDate?: true
    subtotal?: true
    tax?: true
    shipping?: true
    discount?: true
    total?: true
    notes?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status: string
    orderDate: Date
    expectedDeliveryDate: Date | null
    deliveredDate: Date | null
    subtotal: Decimal
    tax: Decimal
    shipping: Decimal
    discount: Decimal
    total: Decimal
    notes: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    deliveredDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_PurchaseOrder_createdByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    User_PurchaseOrder_updatedByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    deliveredDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_PurchaseOrder_createdByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    User_PurchaseOrder_updatedByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    deliveredDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_PurchaseOrder_createdByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    User_PurchaseOrder_updatedByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    status?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    deliveredDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "supplierId" | "warehouseId" | "status" | "orderDate" | "expectedDeliveryDate" | "deliveredDate" | "subtotal" | "tax" | "shipping" | "discount" | "total" | "notes" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_PurchaseOrder_createdByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    User_PurchaseOrder_updatedByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_PurchaseOrder_createdByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    User_PurchaseOrder_updatedByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_PurchaseOrder_createdByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    User_PurchaseOrder_updatedByIdToUser?: boolean | PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      User_PurchaseOrder_createdByIdToUser: Prisma.$UserPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs>
      User_PurchaseOrder_updatedByIdToUser: Prisma.$UserPayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      supplierId: string
      warehouseId: string
      status: string
      orderDate: Date
      expectedDeliveryDate: Date | null
      deliveredDate: Date | null
      subtotal: Prisma.Decimal
      tax: Prisma.Decimal
      shipping: Prisma.Decimal
      discount: Prisma.Decimal
      total: Prisma.Decimal
      notes: string | null
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User_PurchaseOrder_createdByIdToUser<T extends PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User_PurchaseOrder_updatedByIdToUser<T extends PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly orderNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'String'>
    readonly warehouseId: FieldRef<"PurchaseOrder", 'String'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly expectedDeliveryDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly deliveredDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly subtotal: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly tax: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly shipping: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly discount: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly total: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly createdById: FieldRef<"PurchaseOrder", 'String'>
    readonly updatedById: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.User_PurchaseOrder_createdByIdToUser
   */
  export type PurchaseOrder$User_PurchaseOrder_createdByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PurchaseOrder.User_PurchaseOrder_updatedByIdToUser
   */
  export type PurchaseOrder$User_PurchaseOrder_updatedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    orderedQuantity: number | null
    receivedQuantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    subtotal: Decimal | null
    total: Decimal | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    orderedQuantity: number | null
    receivedQuantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    subtotal: Decimal | null
    total: Decimal | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    description: string | null
    orderedQuantity: number | null
    receivedQuantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    subtotal: Decimal | null
    total: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    description: string | null
    orderedQuantity: number | null
    receivedQuantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    subtotal: Decimal | null
    total: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    description: number
    orderedQuantity: number
    receivedQuantity: number
    unitPrice: number
    discount: number
    tax: number
    subtotal: number
    total: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    orderedQuantity?: true
    receivedQuantity?: true
    unitPrice?: true
    discount?: true
    tax?: true
    subtotal?: true
    total?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    orderedQuantity?: true
    receivedQuantity?: true
    unitPrice?: true
    discount?: true
    tax?: true
    subtotal?: true
    total?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    description?: true
    orderedQuantity?: true
    receivedQuantity?: true
    unitPrice?: true
    discount?: true
    tax?: true
    subtotal?: true
    total?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    description?: true
    orderedQuantity?: true
    receivedQuantity?: true
    unitPrice?: true
    discount?: true
    tax?: true
    subtotal?: true
    total?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    description?: true
    orderedQuantity?: true
    receivedQuantity?: true
    unitPrice?: true
    discount?: true
    tax?: true
    subtotal?: true
    total?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    purchaseOrderId: string
    productId: string
    description: string | null
    orderedQuantity: number
    receivedQuantity: number
    unitPrice: Decimal
    discount: Decimal
    tax: Decimal
    subtotal: Decimal
    total: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    description?: boolean
    orderedQuantity?: boolean
    receivedQuantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    tax?: boolean
    subtotal?: boolean
    total?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    description?: boolean
    orderedQuantity?: boolean
    receivedQuantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    tax?: boolean
    subtotal?: boolean
    total?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    description?: boolean
    orderedQuantity?: boolean
    receivedQuantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    tax?: boolean
    subtotal?: boolean
    total?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    description?: boolean
    orderedQuantity?: boolean
    receivedQuantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    tax?: boolean
    subtotal?: boolean
    total?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "productId" | "description" | "orderedQuantity" | "receivedQuantity" | "unitPrice" | "discount" | "tax" | "subtotal" | "total" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrderItem"]>
  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      productId: string
      description: string | null
      orderedQuantity: number
      receivedQuantity: number
      unitPrice: Prisma.Decimal
      discount: Prisma.Decimal
      tax: Prisma.Decimal
      subtotal: Prisma.Decimal
      total: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems and returns the data updated in the database.
     * @param {PurchaseOrderItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderItems.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly productId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly description: FieldRef<"PurchaseOrderItem", 'String'>
    readonly orderedQuantity: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly receivedQuantity: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly unitPrice: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly discount: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly tax: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly subtotal: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly total: FieldRef<"PurchaseOrderItem", 'Decimal'>
    readonly notes: FieldRef<"PurchaseOrderItem", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem updateManyAndReturn
   */
  export type PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    minStockLevel: number | null
    maxStockLevel: number | null
    reorderPoint: number | null
    weight: Decimal | null
    taxRate: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    minStockLevel: number | null
    maxStockLevel: number | null
    reorderPoint: number | null
    weight: Decimal | null
    taxRate: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    supplierId: string | null
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    unit: string | null
    minStockLevel: number | null
    maxStockLevel: number | null
    reorderPoint: number | null
    weight: Decimal | null
    dimensions: string | null
    taxRate: Decimal | null
    isActive: boolean | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    supplierId: string | null
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    unit: string | null
    minStockLevel: number | null
    maxStockLevel: number | null
    reorderPoint: number | null
    weight: Decimal | null
    dimensions: string | null
    taxRate: Decimal | null
    isActive: boolean | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    barcode: number
    name: number
    description: number
    categoryId: number
    supplierId: number
    costPrice: number
    wholesalePrice: number
    retailPrice: number
    unit: number
    minStockLevel: number
    maxStockLevel: number
    reorderPoint: number
    weight: number
    dimensions: number
    taxRate: number
    isActive: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    maxStockLevel?: true
    reorderPoint?: true
    weight?: true
    taxRate?: true
  }

  export type ProductSumAggregateInputType = {
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    maxStockLevel?: true
    reorderPoint?: true
    weight?: true
    taxRate?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    categoryId?: true
    supplierId?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    unit?: true
    minStockLevel?: true
    maxStockLevel?: true
    reorderPoint?: true
    weight?: true
    dimensions?: true
    taxRate?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    categoryId?: true
    supplierId?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    unit?: true
    minStockLevel?: true
    maxStockLevel?: true
    reorderPoint?: true
    weight?: true
    dimensions?: true
    taxRate?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    categoryId?: true
    supplierId?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    unit?: true
    minStockLevel?: true
    maxStockLevel?: true
    reorderPoint?: true
    weight?: true
    dimensions?: true
    taxRate?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    barcode: string | null
    name: string
    description: string | null
    categoryId: string | null
    supplierId: string | null
    costPrice: Decimal
    wholesalePrice: Decimal
    retailPrice: Decimal
    unit: string
    minStockLevel: number
    maxStockLevel: number | null
    reorderPoint: number
    weight: Decimal | null
    dimensions: string | null
    taxRate: Decimal | null
    isActive: boolean
    createdById: string
    updatedById: string
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    unit?: boolean
    minStockLevel?: boolean
    maxStockLevel?: boolean
    reorderPoint?: boolean
    weight?: boolean
    dimensions?: boolean
    taxRate?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditItems?: boolean | Product$auditItemsArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    User_Product_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    User_Product_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    saleItems?: boolean | Product$saleItemsArgs<ExtArgs>
    transferItems?: boolean | Product$transferItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    unit?: boolean
    minStockLevel?: boolean
    maxStockLevel?: boolean
    reorderPoint?: boolean
    weight?: boolean
    dimensions?: boolean
    taxRate?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    User_Product_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    User_Product_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    unit?: boolean
    minStockLevel?: boolean
    maxStockLevel?: boolean
    reorderPoint?: boolean
    weight?: boolean
    dimensions?: boolean
    taxRate?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    User_Product_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    User_Product_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    unit?: boolean
    minStockLevel?: boolean
    maxStockLevel?: boolean
    reorderPoint?: boolean
    weight?: boolean
    dimensions?: boolean
    taxRate?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "barcode" | "name" | "description" | "categoryId" | "supplierId" | "costPrice" | "wholesalePrice" | "retailPrice" | "unit" | "minStockLevel" | "maxStockLevel" | "reorderPoint" | "weight" | "dimensions" | "taxRate" | "isActive" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditItems?: boolean | Product$auditItemsArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    User_Product_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    User_Product_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    saleItems?: boolean | Product$saleItemsArgs<ExtArgs>
    transferItems?: boolean | Product$transferItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    User_Product_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    User_Product_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    User_Product_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    User_Product_updatedByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      auditItems: Prisma.$AuditItemPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      User_Product_createdByIdToUser: Prisma.$UserPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      User_Product_updatedByIdToUser: Prisma.$UserPayload<ExtArgs>
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      transferItems: Prisma.$TransferItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      barcode: string | null
      name: string
      description: string | null
      categoryId: string | null
      supplierId: string | null
      costPrice: Prisma.Decimal
      wholesalePrice: Prisma.Decimal
      retailPrice: Prisma.Decimal
      unit: string
      minStockLevel: number
      maxStockLevel: number | null
      reorderPoint: number
      weight: Prisma.Decimal | null
      dimensions: string | null
      taxRate: Prisma.Decimal | null
      isActive: boolean
      createdById: string
      updatedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditItems<T extends Product$auditItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$auditItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Product$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Product_createdByIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends Product$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Product$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Product_updatedByIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItems<T extends Product$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleItems<T extends Product$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transferItems<T extends Product$transferItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transferItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly supplierId: FieldRef<"Product", 'String'>
    readonly costPrice: FieldRef<"Product", 'Decimal'>
    readonly wholesalePrice: FieldRef<"Product", 'Decimal'>
    readonly retailPrice: FieldRef<"Product", 'Decimal'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly minStockLevel: FieldRef<"Product", 'Int'>
    readonly maxStockLevel: FieldRef<"Product", 'Int'>
    readonly reorderPoint: FieldRef<"Product", 'Int'>
    readonly weight: FieldRef<"Product", 'Decimal'>
    readonly dimensions: FieldRef<"Product", 'String'>
    readonly taxRate: FieldRef<"Product", 'Decimal'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdById: FieldRef<"Product", 'String'>
    readonly updatedById: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.auditItems
   */
  export type Product$auditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    cursor?: AuditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * Product.inventoryItems
   */
  export type Product$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.supplier
   */
  export type Product$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Product.purchaseOrderItems
   */
  export type Product$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Product.saleItems
   */
  export type Product$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Product.transferItems
   */
  export type Product$transferItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | Category$CategoryArgs<ExtArgs>
    other_Category?: boolean | Category$other_CategoryArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | Category$CategoryArgs<ExtArgs>
    other_Category?: boolean | Category$other_CategoryArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | Category$CategoryArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      Category: Prisma.$CategoryPayload<ExtArgs> | null
      other_Category: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Category<T extends Category$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$CategoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_Category<T extends Category$other_CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$other_CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.Category
   */
  export type Category$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.other_Category
   */
  export type Category$other_CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    productId: string | null
    warehouseId: string | null
    storeId: string | null
    binId: string | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    quantity: number | null
    reservedQuantity: number | null
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    status: $Enums.InventoryStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    warehouseId: string | null
    storeId: string | null
    binId: string | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    quantity: number | null
    reservedQuantity: number | null
    costPrice: Decimal | null
    wholesalePrice: Decimal | null
    retailPrice: Decimal | null
    status: $Enums.InventoryStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    productId: number
    warehouseId: number
    storeId: number
    binId: number
    batchNumber: number
    lotNumber: number
    serialNumber: number
    expiryDate: number
    quantity: number
    reservedQuantity: number
    costPrice: number
    wholesalePrice: number
    retailPrice: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    storeId?: true
    binId?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    storeId?: true
    binId?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    productId?: true
    warehouseId?: true
    storeId?: true
    binId?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    productId: string
    warehouseId: string | null
    storeId: string | null
    binId: string | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    quantity: number
    reservedQuantity: number
    costPrice: Decimal
    wholesalePrice: Decimal
    retailPrice: Decimal
    status: $Enums.InventoryStatus
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    storeId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditItems?: boolean | InventoryItem$auditItemsArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    saleItems?: boolean | InventoryItem$saleItemsArgs<ExtArgs>
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | InventoryItem$TransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | InventoryItem$TransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    storeId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    storeId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    productId?: boolean
    warehouseId?: boolean
    storeId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "warehouseId" | "storeId" | "binId" | "batchNumber" | "lotNumber" | "serialNumber" | "expiryDate" | "quantity" | "reservedQuantity" | "costPrice" | "wholesalePrice" | "retailPrice" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditItems?: boolean | InventoryItem$auditItemsArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    saleItems?: boolean | InventoryItem$saleItemsArgs<ExtArgs>
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | InventoryItem$TransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | InventoryItem$TransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      auditItems: Prisma.$AuditItemPayload<ExtArgs>[]
      bin: Prisma.$WarehouseBinPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      TransferItem_TransferItem_destinationInventoryIdToInventoryItem: Prisma.$TransferItemPayload<ExtArgs>[]
      TransferItem_TransferItem_sourceInventoryIdToInventoryItem: Prisma.$TransferItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      warehouseId: string | null
      storeId: string | null
      binId: string | null
      batchNumber: string | null
      lotNumber: string | null
      serialNumber: string | null
      expiryDate: Date | null
      quantity: number
      reservedQuantity: number
      costPrice: Prisma.Decimal
      wholesalePrice: Prisma.Decimal
      retailPrice: Prisma.Decimal
      status: $Enums.InventoryStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditItems<T extends InventoryItem$auditItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$auditItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bin<T extends InventoryItem$binArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$binArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends InventoryItem$storeArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends InventoryItem$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    saleItems<T extends InventoryItem$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem<T extends InventoryItem$TransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$TransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem<T extends InventoryItem$TransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$TransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly productId: FieldRef<"InventoryItem", 'String'>
    readonly warehouseId: FieldRef<"InventoryItem", 'String'>
    readonly storeId: FieldRef<"InventoryItem", 'String'>
    readonly binId: FieldRef<"InventoryItem", 'String'>
    readonly batchNumber: FieldRef<"InventoryItem", 'String'>
    readonly lotNumber: FieldRef<"InventoryItem", 'String'>
    readonly serialNumber: FieldRef<"InventoryItem", 'String'>
    readonly expiryDate: FieldRef<"InventoryItem", 'DateTime'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly reservedQuantity: FieldRef<"InventoryItem", 'Int'>
    readonly costPrice: FieldRef<"InventoryItem", 'Decimal'>
    readonly wholesalePrice: FieldRef<"InventoryItem", 'Decimal'>
    readonly retailPrice: FieldRef<"InventoryItem", 'Decimal'>
    readonly status: FieldRef<"InventoryItem", 'InventoryStatus'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.auditItems
   */
  export type InventoryItem$auditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    cursor?: AuditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * InventoryItem.bin
   */
  export type InventoryItem$binArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    where?: WarehouseBinWhereInput
  }

  /**
   * InventoryItem.store
   */
  export type InventoryItem$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * InventoryItem.warehouse
   */
  export type InventoryItem$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * InventoryItem.saleItems
   */
  export type InventoryItem$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * InventoryItem.TransferItem_TransferItem_destinationInventoryIdToInventoryItem
   */
  export type InventoryItem$TransferItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * InventoryItem.TransferItem_TransferItem_sourceInventoryIdToInventoryItem
   */
  export type InventoryItem$TransferItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    totalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsRedeemed: number | null
  }

  export type SaleSumAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    totalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsRedeemed: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    storeId: string | null
    customerId: string | null
    createdById: string | null
    saleDate: Date | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    totalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsRedeemed: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    storeId: string | null
    customerId: string | null
    createdById: string | null
    saleDate: Date | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    totalAmount: Decimal | null
    loyaltyPointsEarned: number | null
    loyaltyPointsRedeemed: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    receiptNumber: number
    storeId: number
    customerId: number
    createdById: number
    saleDate: number
    subtotal: number
    taxAmount: number
    discountAmount: number
    totalAmount: number
    loyaltyPointsEarned: number
    loyaltyPointsRedeemed: number
    paymentMethod: number
    paymentStatus: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsRedeemed?: true
  }

  export type SaleSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsRedeemed?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    receiptNumber?: true
    storeId?: true
    customerId?: true
    createdById?: true
    saleDate?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsRedeemed?: true
    paymentMethod?: true
    paymentStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    receiptNumber?: true
    storeId?: true
    customerId?: true
    createdById?: true
    saleDate?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsRedeemed?: true
    paymentMethod?: true
    paymentStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    receiptNumber?: true
    storeId?: true
    customerId?: true
    createdById?: true
    saleDate?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    loyaltyPointsEarned?: true
    loyaltyPointsRedeemed?: true
    paymentMethod?: true
    paymentStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    receiptNumber: string
    storeId: string
    customerId: string | null
    createdById: string
    saleDate: Date
    subtotal: Decimal
    taxAmount: Decimal
    discountAmount: Decimal
    totalAmount: Decimal
    loyaltyPointsEarned: number
    loyaltyPointsRedeemed: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus: $Enums.PaymentStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    loyaltyPointsEarned?: boolean
    loyaltyPointsRedeemed?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyTransaction?: boolean | Sale$LoyaltyTransactionArgs<ExtArgs>
    PromotionRedemption?: boolean | Sale$PromotionRedemptionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    loyaltyPointsEarned?: boolean
    loyaltyPointsRedeemed?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    loyaltyPointsEarned?: boolean
    loyaltyPointsRedeemed?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    loyaltyPointsEarned?: boolean
    loyaltyPointsRedeemed?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptNumber" | "storeId" | "customerId" | "createdById" | "saleDate" | "subtotal" | "taxAmount" | "discountAmount" | "totalAmount" | "loyaltyPointsEarned" | "loyaltyPointsRedeemed" | "paymentMethod" | "paymentStatus" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyTransaction?: boolean | Sale$LoyaltyTransactionArgs<ExtArgs>
    PromotionRedemption?: boolean | Sale$PromotionRedemptionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      LoyaltyTransaction: Prisma.$LoyaltyTransactionPayload<ExtArgs>[]
      PromotionRedemption: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      store: Prisma.$StorePayload<ExtArgs>
      items: Prisma.$SaleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptNumber: string
      storeId: string
      customerId: string | null
      createdById: string
      saleDate: Date
      subtotal: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      totalAmount: Prisma.Decimal
      loyaltyPointsEarned: number
      loyaltyPointsRedeemed: number
      paymentMethod: $Enums.PaymentMethod
      paymentStatus: $Enums.PaymentStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    LoyaltyTransaction<T extends Sale$LoyaltyTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Sale$LoyaltyTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PromotionRedemption<T extends Sale$PromotionRedemptionArgs<ExtArgs> = {}>(args?: Subset<T, Sale$PromotionRedemptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Sale$customerArgs<ExtArgs> = {}>(args?: Subset<T, Sale$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Sale$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly receiptNumber: FieldRef<"Sale", 'String'>
    readonly storeId: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly createdById: FieldRef<"Sale", 'String'>
    readonly saleDate: FieldRef<"Sale", 'DateTime'>
    readonly subtotal: FieldRef<"Sale", 'Decimal'>
    readonly taxAmount: FieldRef<"Sale", 'Decimal'>
    readonly discountAmount: FieldRef<"Sale", 'Decimal'>
    readonly totalAmount: FieldRef<"Sale", 'Decimal'>
    readonly loyaltyPointsEarned: FieldRef<"Sale", 'Int'>
    readonly loyaltyPointsRedeemed: FieldRef<"Sale", 'Int'>
    readonly paymentMethod: FieldRef<"Sale", 'PaymentMethod'>
    readonly paymentStatus: FieldRef<"Sale", 'PaymentStatus'>
    readonly notes: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale.LoyaltyTransaction
   */
  export type Sale$LoyaltyTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * Sale.PromotionRedemption
   */
  export type Sale$PromotionRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * Sale.customer
   */
  export type Sale$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Sale.items
   */
  export type Sale$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleItem
   */

  export type AggregateSaleItem = {
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  export type SaleItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleItemMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    inventoryItemId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleItemMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    inventoryItemId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discountAmount: Decimal | null
    taxAmount: Decimal | null
    totalPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleItemCountAggregateOutputType = {
    id: number
    saleId: number
    productId: number
    inventoryItemId: number
    quantity: number
    unitPrice: number
    discountAmount: number
    taxAmount: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
  }

  export type SaleItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
  }

  export type SaleItemMinAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    inventoryItemId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleItemMaxAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    inventoryItemId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleItemCountAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    inventoryItemId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItem to aggregate.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleItems
    **/
    _count?: true | SaleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleItemMaxAggregateInputType
  }

  export type GetSaleItemAggregateType<T extends SaleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleItem[P]>
      : GetScalarType<T[P], AggregateSaleItem[P]>
  }




  export type SaleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithAggregationInput | SaleItemOrderByWithAggregationInput[]
    by: SaleItemScalarFieldEnum[] | SaleItemScalarFieldEnum
    having?: SaleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleItemCountAggregateInputType | true
    _avg?: SaleItemAvgAggregateInputType
    _sum?: SaleItemSumAggregateInputType
    _min?: SaleItemMinAggregateInputType
    _max?: SaleItemMaxAggregateInputType
  }

  export type SaleItemGroupByOutputType = {
    id: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal
    discountAmount: Decimal
    taxAmount: Decimal
    totalPrice: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  type GetSaleItemGroupByPayload<T extends SaleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
            : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
        }
      >
    >


  export type SaleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectScalar = {
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "productId" | "inventoryItemId" | "quantity" | "unitPrice" | "discountAmount" | "taxAmount" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["saleItem"]>
  export type SaleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $SaleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleItem"
    objects: {
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      sale: Prisma.$SalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      productId: string
      inventoryItemId: string
      quantity: number
      unitPrice: Prisma.Decimal
      discountAmount: Prisma.Decimal
      taxAmount: Prisma.Decimal
      totalPrice: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saleItem"]>
    composites: {}
  }

  type SaleItemGetPayload<S extends boolean | null | undefined | SaleItemDefaultArgs> = $Result.GetResult<Prisma.$SaleItemPayload, S>

  type SaleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleItemCountAggregateInputType | true
    }

  export interface SaleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleItem'], meta: { name: 'SaleItem' } }
    /**
     * Find zero or one SaleItem that matches the filter.
     * @param {SaleItemFindUniqueArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleItemFindUniqueArgs>(args: SelectSubset<T, SaleItemFindUniqueArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleItemFindUniqueOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleItemFindFirstArgs>(args?: SelectSubset<T, SaleItemFindFirstArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleItems
     * const saleItems = await prisma.saleItem.findMany()
     * 
     * // Get first 10 SaleItems
     * const saleItems = await prisma.saleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleItemFindManyArgs>(args?: SelectSubset<T, SaleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleItem.
     * @param {SaleItemCreateArgs} args - Arguments to create a SaleItem.
     * @example
     * // Create one SaleItem
     * const SaleItem = await prisma.saleItem.create({
     *   data: {
     *     // ... data to create a SaleItem
     *   }
     * })
     * 
     */
    create<T extends SaleItemCreateArgs>(args: SelectSubset<T, SaleItemCreateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleItems.
     * @param {SaleItemCreateManyArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleItemCreateManyArgs>(args?: SelectSubset<T, SaleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleItems and returns the data saved in the database.
     * @param {SaleItemCreateManyAndReturnArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleItem.
     * @param {SaleItemDeleteArgs} args - Arguments to delete one SaleItem.
     * @example
     * // Delete one SaleItem
     * const SaleItem = await prisma.saleItem.delete({
     *   where: {
     *     // ... filter to delete one SaleItem
     *   }
     * })
     * 
     */
    delete<T extends SaleItemDeleteArgs>(args: SelectSubset<T, SaleItemDeleteArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleItem.
     * @param {SaleItemUpdateArgs} args - Arguments to update one SaleItem.
     * @example
     * // Update one SaleItem
     * const saleItem = await prisma.saleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleItemUpdateArgs>(args: SelectSubset<T, SaleItemUpdateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleItems.
     * @param {SaleItemDeleteManyArgs} args - Arguments to filter SaleItems to delete.
     * @example
     * // Delete a few SaleItems
     * const { count } = await prisma.saleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleItemDeleteManyArgs>(args?: SelectSubset<T, SaleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleItemUpdateManyArgs>(args: SelectSubset<T, SaleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems and returns the data updated in the database.
     * @param {SaleItemUpdateManyAndReturnArgs} args - Arguments to update many SaleItems.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleItem.
     * @param {SaleItemUpsertArgs} args - Arguments to update or create a SaleItem.
     * @example
     * // Update or create a SaleItem
     * const saleItem = await prisma.saleItem.upsert({
     *   create: {
     *     // ... data to create a SaleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleItem we want to update
     *   }
     * })
     */
    upsert<T extends SaleItemUpsertArgs>(args: SelectSubset<T, SaleItemUpsertArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemCountArgs} args - Arguments to filter SaleItems to count.
     * @example
     * // Count the number of SaleItems
     * const count = await prisma.saleItem.count({
     *   where: {
     *     // ... the filter for the SaleItems we want to count
     *   }
     * })
    **/
    count<T extends SaleItemCountArgs>(
      args?: Subset<T, SaleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleItemAggregateArgs>(args: Subset<T, SaleItemAggregateArgs>): Prisma.PrismaPromise<GetSaleItemAggregateType<T>>

    /**
     * Group by SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleItemGroupByArgs['orderBy'] }
        : { orderBy?: SaleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleItem model
   */
  readonly fields: SaleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleItem model
   */
  interface SaleItemFieldRefs {
    readonly id: FieldRef<"SaleItem", 'String'>
    readonly saleId: FieldRef<"SaleItem", 'String'>
    readonly productId: FieldRef<"SaleItem", 'String'>
    readonly inventoryItemId: FieldRef<"SaleItem", 'String'>
    readonly quantity: FieldRef<"SaleItem", 'Int'>
    readonly unitPrice: FieldRef<"SaleItem", 'Decimal'>
    readonly discountAmount: FieldRef<"SaleItem", 'Decimal'>
    readonly taxAmount: FieldRef<"SaleItem", 'Decimal'>
    readonly totalPrice: FieldRef<"SaleItem", 'Decimal'>
    readonly createdAt: FieldRef<"SaleItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleItem findUnique
   */
  export type SaleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findUniqueOrThrow
   */
  export type SaleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findFirst
   */
  export type SaleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findFirstOrThrow
   */
  export type SaleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findMany
   */
  export type SaleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItems to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem create
   */
  export type SaleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleItem.
     */
    data: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
  }

  /**
   * SaleItem createMany
   */
  export type SaleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleItem createManyAndReturn
   */
  export type SaleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem update
   */
  export type SaleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleItem.
     */
    data: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
    /**
     * Choose, which SaleItem to update.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem updateMany
   */
  export type SaleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to update.
     */
    limit?: number
  }

  /**
   * SaleItem updateManyAndReturn
   */
  export type SaleItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem upsert
   */
  export type SaleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleItem to update in case it exists.
     */
    where: SaleItemWhereUniqueInput
    /**
     * In case the SaleItem found by the `where` argument doesn't exist, create a new SaleItem with this data.
     */
    create: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
    /**
     * In case the SaleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
  }

  /**
   * SaleItem delete
   */
  export type SaleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter which SaleItem to delete.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem deleteMany
   */
  export type SaleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItems to delete
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to delete.
     */
    limit?: number
  }

  /**
   * SaleItem without action
   */
  export type SaleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    type: $Enums.TransferType | null
    sourceWarehouseId: string | null
    destinationWarehouseId: string | null
    sourceStoreId: string | null
    destinationStoreId: string | null
    status: $Enums.TransferStatus | null
    requestedDate: Date | null
    approvedDate: Date | null
    shippedDate: Date | null
    receivedDate: Date | null
    notes: string | null
    createdById: string | null
    approvedById: string | null
    receivedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    type: $Enums.TransferType | null
    sourceWarehouseId: string | null
    destinationWarehouseId: string | null
    sourceStoreId: string | null
    destinationStoreId: string | null
    status: $Enums.TransferStatus | null
    requestedDate: Date | null
    approvedDate: Date | null
    shippedDate: Date | null
    receivedDate: Date | null
    notes: string | null
    createdById: string | null
    approvedById: string | null
    receivedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    referenceNumber: number
    type: number
    sourceWarehouseId: number
    destinationWarehouseId: number
    sourceStoreId: number
    destinationStoreId: number
    status: number
    requestedDate: number
    approvedDate: number
    shippedDate: number
    receivedDate: number
    notes: number
    createdById: number
    approvedById: number
    receivedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferMinAggregateInputType = {
    id?: true
    referenceNumber?: true
    type?: true
    sourceWarehouseId?: true
    destinationWarehouseId?: true
    sourceStoreId?: true
    destinationStoreId?: true
    status?: true
    requestedDate?: true
    approvedDate?: true
    shippedDate?: true
    receivedDate?: true
    notes?: true
    createdById?: true
    approvedById?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    referenceNumber?: true
    type?: true
    sourceWarehouseId?: true
    destinationWarehouseId?: true
    sourceStoreId?: true
    destinationStoreId?: true
    status?: true
    requestedDate?: true
    approvedDate?: true
    shippedDate?: true
    receivedDate?: true
    notes?: true
    createdById?: true
    approvedById?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    referenceNumber?: true
    type?: true
    sourceWarehouseId?: true
    destinationWarehouseId?: true
    sourceStoreId?: true
    destinationStoreId?: true
    status?: true
    requestedDate?: true
    approvedDate?: true
    shippedDate?: true
    receivedDate?: true
    notes?: true
    createdById?: true
    approvedById?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId: string | null
    destinationWarehouseId: string | null
    sourceStoreId: string | null
    destinationStoreId: string | null
    status: $Enums.TransferStatus
    requestedDate: Date
    approvedDate: Date | null
    shippedDate: Date | null
    receivedDate: Date | null
    notes: string | null
    createdById: string
    approvedById: string | null
    receivedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferCountAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    sourceWarehouseId?: boolean
    destinationWarehouseId?: boolean
    sourceStoreId?: boolean
    destinationStoreId?: boolean
    status?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    shippedDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Transfer_approvedByIdToUser?: boolean | Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>
    User_Transfer_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Store_Transfer_destinationStoreIdToStore?: boolean | Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    User_Transfer_receivedByIdToUser?: boolean | Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>
    Store_Transfer_sourceStoreIdToStore?: boolean | Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
    items?: boolean | Transfer$itemsArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    sourceWarehouseId?: boolean
    destinationWarehouseId?: boolean
    sourceStoreId?: boolean
    destinationStoreId?: boolean
    status?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    shippedDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Transfer_approvedByIdToUser?: boolean | Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>
    User_Transfer_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Store_Transfer_destinationStoreIdToStore?: boolean | Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    User_Transfer_receivedByIdToUser?: boolean | Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>
    Store_Transfer_sourceStoreIdToStore?: boolean | Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    sourceWarehouseId?: boolean
    destinationWarehouseId?: boolean
    sourceStoreId?: boolean
    destinationStoreId?: boolean
    status?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    shippedDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Transfer_approvedByIdToUser?: boolean | Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>
    User_Transfer_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Store_Transfer_destinationStoreIdToStore?: boolean | Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    User_Transfer_receivedByIdToUser?: boolean | Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>
    Store_Transfer_sourceStoreIdToStore?: boolean | Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    sourceWarehouseId?: boolean
    destinationWarehouseId?: boolean
    sourceStoreId?: boolean
    destinationStoreId?: boolean
    status?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    shippedDate?: boolean
    receivedDate?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceNumber" | "type" | "sourceWarehouseId" | "destinationWarehouseId" | "sourceStoreId" | "destinationStoreId" | "status" | "requestedDate" | "approvedDate" | "shippedDate" | "receivedDate" | "notes" | "createdById" | "approvedById" | "receivedById" | "createdAt" | "updatedAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Transfer_approvedByIdToUser?: boolean | Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>
    User_Transfer_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Store_Transfer_destinationStoreIdToStore?: boolean | Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    User_Transfer_receivedByIdToUser?: boolean | Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>
    Store_Transfer_sourceStoreIdToStore?: boolean | Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
    items?: boolean | Transfer$itemsArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Transfer_approvedByIdToUser?: boolean | Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>
    User_Transfer_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Store_Transfer_destinationStoreIdToStore?: boolean | Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    User_Transfer_receivedByIdToUser?: boolean | Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>
    Store_Transfer_sourceStoreIdToStore?: boolean | Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Transfer_approvedByIdToUser?: boolean | Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>
    User_Transfer_createdByIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Store_Transfer_destinationStoreIdToStore?: boolean | Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>
    User_Transfer_receivedByIdToUser?: boolean | Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>
    Store_Transfer_sourceStoreIdToStore?: boolean | Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: boolean | Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      User_Transfer_approvedByIdToUser: Prisma.$UserPayload<ExtArgs> | null
      User_Transfer_createdByIdToUser: Prisma.$UserPayload<ExtArgs>
      Store_Transfer_destinationStoreIdToStore: Prisma.$StorePayload<ExtArgs> | null
      Warehouse_Transfer_destinationWarehouseIdToWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      User_Transfer_receivedByIdToUser: Prisma.$UserPayload<ExtArgs> | null
      Store_Transfer_sourceStoreIdToStore: Prisma.$StorePayload<ExtArgs> | null
      Warehouse_Transfer_sourceWarehouseIdToWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      items: Prisma.$TransferItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceNumber: string
      type: $Enums.TransferType
      sourceWarehouseId: string | null
      destinationWarehouseId: string | null
      sourceStoreId: string | null
      destinationStoreId: string | null
      status: $Enums.TransferStatus
      requestedDate: Date
      approvedDate: Date | null
      shippedDate: Date | null
      receivedDate: Date | null
      notes: string | null
      createdById: string
      approvedById: string | null
      receivedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User_Transfer_approvedByIdToUser<T extends Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Transfer_createdByIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Store_Transfer_destinationStoreIdToStore<T extends Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Warehouse_Transfer_destinationWarehouseIdToWarehouse<T extends Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Transfer_receivedByIdToUser<T extends Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Store_Transfer_sourceStoreIdToStore<T extends Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Warehouse_Transfer_sourceWarehouseIdToWarehouse<T extends Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Transfer$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly referenceNumber: FieldRef<"Transfer", 'String'>
    readonly type: FieldRef<"Transfer", 'TransferType'>
    readonly sourceWarehouseId: FieldRef<"Transfer", 'String'>
    readonly destinationWarehouseId: FieldRef<"Transfer", 'String'>
    readonly sourceStoreId: FieldRef<"Transfer", 'String'>
    readonly destinationStoreId: FieldRef<"Transfer", 'String'>
    readonly status: FieldRef<"Transfer", 'TransferStatus'>
    readonly requestedDate: FieldRef<"Transfer", 'DateTime'>
    readonly approvedDate: FieldRef<"Transfer", 'DateTime'>
    readonly shippedDate: FieldRef<"Transfer", 'DateTime'>
    readonly receivedDate: FieldRef<"Transfer", 'DateTime'>
    readonly notes: FieldRef<"Transfer", 'String'>
    readonly createdById: FieldRef<"Transfer", 'String'>
    readonly approvedById: FieldRef<"Transfer", 'String'>
    readonly receivedById: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.User_Transfer_approvedByIdToUser
   */
  export type Transfer$User_Transfer_approvedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.Store_Transfer_destinationStoreIdToStore
   */
  export type Transfer$Store_Transfer_destinationStoreIdToStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Transfer.Warehouse_Transfer_destinationWarehouseIdToWarehouse
   */
  export type Transfer$Warehouse_Transfer_destinationWarehouseIdToWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * Transfer.User_Transfer_receivedByIdToUser
   */
  export type Transfer$User_Transfer_receivedByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transfer.Store_Transfer_sourceStoreIdToStore
   */
  export type Transfer$Store_Transfer_sourceStoreIdToStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Transfer.Warehouse_Transfer_sourceWarehouseIdToWarehouse
   */
  export type Transfer$Warehouse_Transfer_sourceWarehouseIdToWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * Transfer.items
   */
  export type Transfer$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model TransferItem
   */

  export type AggregateTransferItem = {
    _count: TransferItemCountAggregateOutputType | null
    _avg: TransferItemAvgAggregateOutputType | null
    _sum: TransferItemSumAggregateOutputType | null
    _min: TransferItemMinAggregateOutputType | null
    _max: TransferItemMaxAggregateOutputType | null
  }

  export type TransferItemAvgAggregateOutputType = {
    requestedQuantity: number | null
    approvedQuantity: number | null
    shippedQuantity: number | null
    receivedQuantity: number | null
    sourceCostPrice: Decimal | null
    sourceWholesalePrice: Decimal | null
    sourceRetailPrice: Decimal | null
    destinationCostPrice: Decimal | null
    destinationWholesalePrice: Decimal | null
    destinationRetailPrice: Decimal | null
  }

  export type TransferItemSumAggregateOutputType = {
    requestedQuantity: number | null
    approvedQuantity: number | null
    shippedQuantity: number | null
    receivedQuantity: number | null
    sourceCostPrice: Decimal | null
    sourceWholesalePrice: Decimal | null
    sourceRetailPrice: Decimal | null
    destinationCostPrice: Decimal | null
    destinationWholesalePrice: Decimal | null
    destinationRetailPrice: Decimal | null
  }

  export type TransferItemMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    sourceInventoryId: string | null
    destinationInventoryId: string | null
    requestedQuantity: number | null
    approvedQuantity: number | null
    shippedQuantity: number | null
    receivedQuantity: number | null
    sourceCostPrice: Decimal | null
    sourceWholesalePrice: Decimal | null
    sourceRetailPrice: Decimal | null
    destinationCostPrice: Decimal | null
    destinationWholesalePrice: Decimal | null
    destinationRetailPrice: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferItemMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    sourceInventoryId: string | null
    destinationInventoryId: string | null
    requestedQuantity: number | null
    approvedQuantity: number | null
    shippedQuantity: number | null
    receivedQuantity: number | null
    sourceCostPrice: Decimal | null
    sourceWholesalePrice: Decimal | null
    sourceRetailPrice: Decimal | null
    destinationCostPrice: Decimal | null
    destinationWholesalePrice: Decimal | null
    destinationRetailPrice: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferItemCountAggregateOutputType = {
    id: number
    transferId: number
    productId: number
    sourceInventoryId: number
    destinationInventoryId: number
    requestedQuantity: number
    approvedQuantity: number
    shippedQuantity: number
    receivedQuantity: number
    sourceCostPrice: number
    sourceWholesalePrice: number
    sourceRetailPrice: number
    destinationCostPrice: number
    destinationWholesalePrice: number
    destinationRetailPrice: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferItemAvgAggregateInputType = {
    requestedQuantity?: true
    approvedQuantity?: true
    shippedQuantity?: true
    receivedQuantity?: true
    sourceCostPrice?: true
    sourceWholesalePrice?: true
    sourceRetailPrice?: true
    destinationCostPrice?: true
    destinationWholesalePrice?: true
    destinationRetailPrice?: true
  }

  export type TransferItemSumAggregateInputType = {
    requestedQuantity?: true
    approvedQuantity?: true
    shippedQuantity?: true
    receivedQuantity?: true
    sourceCostPrice?: true
    sourceWholesalePrice?: true
    sourceRetailPrice?: true
    destinationCostPrice?: true
    destinationWholesalePrice?: true
    destinationRetailPrice?: true
  }

  export type TransferItemMinAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    sourceInventoryId?: true
    destinationInventoryId?: true
    requestedQuantity?: true
    approvedQuantity?: true
    shippedQuantity?: true
    receivedQuantity?: true
    sourceCostPrice?: true
    sourceWholesalePrice?: true
    sourceRetailPrice?: true
    destinationCostPrice?: true
    destinationWholesalePrice?: true
    destinationRetailPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferItemMaxAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    sourceInventoryId?: true
    destinationInventoryId?: true
    requestedQuantity?: true
    approvedQuantity?: true
    shippedQuantity?: true
    receivedQuantity?: true
    sourceCostPrice?: true
    sourceWholesalePrice?: true
    sourceRetailPrice?: true
    destinationCostPrice?: true
    destinationWholesalePrice?: true
    destinationRetailPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferItemCountAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    sourceInventoryId?: true
    destinationInventoryId?: true
    requestedQuantity?: true
    approvedQuantity?: true
    shippedQuantity?: true
    receivedQuantity?: true
    sourceCostPrice?: true
    sourceWholesalePrice?: true
    sourceRetailPrice?: true
    destinationCostPrice?: true
    destinationWholesalePrice?: true
    destinationRetailPrice?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferItem to aggregate.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferItems
    **/
    _count?: true | TransferItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferItemMaxAggregateInputType
  }

  export type GetTransferItemAggregateType<T extends TransferItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferItem[P]>
      : GetScalarType<T[P], AggregateTransferItem[P]>
  }




  export type TransferItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithAggregationInput | TransferItemOrderByWithAggregationInput[]
    by: TransferItemScalarFieldEnum[] | TransferItemScalarFieldEnum
    having?: TransferItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferItemCountAggregateInputType | true
    _avg?: TransferItemAvgAggregateInputType
    _sum?: TransferItemSumAggregateInputType
    _min?: TransferItemMinAggregateInputType
    _max?: TransferItemMaxAggregateInputType
  }

  export type TransferItemGroupByOutputType = {
    id: string
    transferId: string
    productId: string
    sourceInventoryId: string | null
    destinationInventoryId: string | null
    requestedQuantity: number
    approvedQuantity: number | null
    shippedQuantity: number | null
    receivedQuantity: number | null
    sourceCostPrice: Decimal
    sourceWholesalePrice: Decimal
    sourceRetailPrice: Decimal
    destinationCostPrice: Decimal
    destinationWholesalePrice: Decimal
    destinationRetailPrice: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferItemCountAggregateOutputType | null
    _avg: TransferItemAvgAggregateOutputType | null
    _sum: TransferItemSumAggregateOutputType | null
    _min: TransferItemMinAggregateOutputType | null
    _max: TransferItemMaxAggregateOutputType | null
  }

  type GetTransferItemGroupByPayload<T extends TransferItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransferItemGroupByOutputType[P]>
        }
      >
    >


  export type TransferItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    sourceInventoryId?: boolean
    destinationInventoryId?: boolean
    requestedQuantity?: boolean
    approvedQuantity?: boolean
    shippedQuantity?: boolean
    receivedQuantity?: boolean
    sourceCostPrice?: boolean
    sourceWholesalePrice?: boolean
    sourceRetailPrice?: boolean
    destinationCostPrice?: boolean
    destinationWholesalePrice?: boolean
    destinationRetailPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>

  export type TransferItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    sourceInventoryId?: boolean
    destinationInventoryId?: boolean
    requestedQuantity?: boolean
    approvedQuantity?: boolean
    shippedQuantity?: boolean
    receivedQuantity?: boolean
    sourceCostPrice?: boolean
    sourceWholesalePrice?: boolean
    sourceRetailPrice?: boolean
    destinationCostPrice?: boolean
    destinationWholesalePrice?: boolean
    destinationRetailPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>

  export type TransferItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    sourceInventoryId?: boolean
    destinationInventoryId?: boolean
    requestedQuantity?: boolean
    approvedQuantity?: boolean
    shippedQuantity?: boolean
    receivedQuantity?: boolean
    sourceCostPrice?: boolean
    sourceWholesalePrice?: boolean
    sourceRetailPrice?: boolean
    destinationCostPrice?: boolean
    destinationWholesalePrice?: boolean
    destinationRetailPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>

  export type TransferItemSelectScalar = {
    id?: boolean
    transferId?: boolean
    productId?: boolean
    sourceInventoryId?: boolean
    destinationInventoryId?: boolean
    requestedQuantity?: boolean
    approvedQuantity?: boolean
    shippedQuantity?: boolean
    receivedQuantity?: boolean
    sourceCostPrice?: boolean
    sourceWholesalePrice?: boolean
    sourceRetailPrice?: boolean
    destinationCostPrice?: boolean
    destinationWholesalePrice?: boolean
    destinationRetailPrice?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "productId" | "sourceInventoryId" | "destinationInventoryId" | "requestedQuantity" | "approvedQuantity" | "shippedQuantity" | "receivedQuantity" | "sourceCostPrice" | "sourceWholesalePrice" | "sourceRetailPrice" | "destinationCostPrice" | "destinationWholesalePrice" | "destinationRetailPrice" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["transferItem"]>
  export type TransferItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }
  export type TransferItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }
  export type TransferItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: boolean | TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }

  export type $TransferItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferItem"
    objects: {
      InventoryItem_TransferItem_destinationInventoryIdToInventoryItem: Prisma.$InventoryItemPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs>
      InventoryItem_TransferItem_sourceInventoryIdToInventoryItem: Prisma.$InventoryItemPayload<ExtArgs> | null
      transfer: Prisma.$TransferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      productId: string
      sourceInventoryId: string | null
      destinationInventoryId: string | null
      requestedQuantity: number
      approvedQuantity: number | null
      shippedQuantity: number | null
      receivedQuantity: number | null
      sourceCostPrice: Prisma.Decimal
      sourceWholesalePrice: Prisma.Decimal
      sourceRetailPrice: Prisma.Decimal
      destinationCostPrice: Prisma.Decimal
      destinationWholesalePrice: Prisma.Decimal
      destinationRetailPrice: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferItem"]>
    composites: {}
  }

  type TransferItemGetPayload<S extends boolean | null | undefined | TransferItemDefaultArgs> = $Result.GetResult<Prisma.$TransferItemPayload, S>

  type TransferItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferItemCountAggregateInputType | true
    }

  export interface TransferItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferItem'], meta: { name: 'TransferItem' } }
    /**
     * Find zero or one TransferItem that matches the filter.
     * @param {TransferItemFindUniqueArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferItemFindUniqueArgs>(args: SelectSubset<T, TransferItemFindUniqueArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferItemFindUniqueOrThrowArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindFirstArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferItemFindFirstArgs>(args?: SelectSubset<T, TransferItemFindFirstArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindFirstOrThrowArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferItems
     * const transferItems = await prisma.transferItem.findMany()
     * 
     * // Get first 10 TransferItems
     * const transferItems = await prisma.transferItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferItemFindManyArgs>(args?: SelectSubset<T, TransferItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferItem.
     * @param {TransferItemCreateArgs} args - Arguments to create a TransferItem.
     * @example
     * // Create one TransferItem
     * const TransferItem = await prisma.transferItem.create({
     *   data: {
     *     // ... data to create a TransferItem
     *   }
     * })
     * 
     */
    create<T extends TransferItemCreateArgs>(args: SelectSubset<T, TransferItemCreateArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferItems.
     * @param {TransferItemCreateManyArgs} args - Arguments to create many TransferItems.
     * @example
     * // Create many TransferItems
     * const transferItem = await prisma.transferItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferItemCreateManyArgs>(args?: SelectSubset<T, TransferItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferItems and returns the data saved in the database.
     * @param {TransferItemCreateManyAndReturnArgs} args - Arguments to create many TransferItems.
     * @example
     * // Create many TransferItems
     * const transferItem = await prisma.transferItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferItems and only return the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransferItem.
     * @param {TransferItemDeleteArgs} args - Arguments to delete one TransferItem.
     * @example
     * // Delete one TransferItem
     * const TransferItem = await prisma.transferItem.delete({
     *   where: {
     *     // ... filter to delete one TransferItem
     *   }
     * })
     * 
     */
    delete<T extends TransferItemDeleteArgs>(args: SelectSubset<T, TransferItemDeleteArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferItem.
     * @param {TransferItemUpdateArgs} args - Arguments to update one TransferItem.
     * @example
     * // Update one TransferItem
     * const transferItem = await prisma.transferItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferItemUpdateArgs>(args: SelectSubset<T, TransferItemUpdateArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferItems.
     * @param {TransferItemDeleteManyArgs} args - Arguments to filter TransferItems to delete.
     * @example
     * // Delete a few TransferItems
     * const { count } = await prisma.transferItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferItemDeleteManyArgs>(args?: SelectSubset<T, TransferItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferItems
     * const transferItem = await prisma.transferItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferItemUpdateManyArgs>(args: SelectSubset<T, TransferItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferItems and returns the data updated in the database.
     * @param {TransferItemUpdateManyAndReturnArgs} args - Arguments to update many TransferItems.
     * @example
     * // Update many TransferItems
     * const transferItem = await prisma.transferItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransferItems and only return the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransferItem.
     * @param {TransferItemUpsertArgs} args - Arguments to update or create a TransferItem.
     * @example
     * // Update or create a TransferItem
     * const transferItem = await prisma.transferItem.upsert({
     *   create: {
     *     // ... data to create a TransferItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferItem we want to update
     *   }
     * })
     */
    upsert<T extends TransferItemUpsertArgs>(args: SelectSubset<T, TransferItemUpsertArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemCountArgs} args - Arguments to filter TransferItems to count.
     * @example
     * // Count the number of TransferItems
     * const count = await prisma.transferItem.count({
     *   where: {
     *     // ... the filter for the TransferItems we want to count
     *   }
     * })
    **/
    count<T extends TransferItemCountArgs>(
      args?: Subset<T, TransferItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferItemAggregateArgs>(args: Subset<T, TransferItemAggregateArgs>): Prisma.PrismaPromise<GetTransferItemAggregateType<T>>

    /**
     * Group by TransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferItemGroupByArgs['orderBy'] }
        : { orderBy?: TransferItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferItem model
   */
  readonly fields: TransferItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem<T extends TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem<T extends TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferItem model
   */
  interface TransferItemFieldRefs {
    readonly id: FieldRef<"TransferItem", 'String'>
    readonly transferId: FieldRef<"TransferItem", 'String'>
    readonly productId: FieldRef<"TransferItem", 'String'>
    readonly sourceInventoryId: FieldRef<"TransferItem", 'String'>
    readonly destinationInventoryId: FieldRef<"TransferItem", 'String'>
    readonly requestedQuantity: FieldRef<"TransferItem", 'Int'>
    readonly approvedQuantity: FieldRef<"TransferItem", 'Int'>
    readonly shippedQuantity: FieldRef<"TransferItem", 'Int'>
    readonly receivedQuantity: FieldRef<"TransferItem", 'Int'>
    readonly sourceCostPrice: FieldRef<"TransferItem", 'Decimal'>
    readonly sourceWholesalePrice: FieldRef<"TransferItem", 'Decimal'>
    readonly sourceRetailPrice: FieldRef<"TransferItem", 'Decimal'>
    readonly destinationCostPrice: FieldRef<"TransferItem", 'Decimal'>
    readonly destinationWholesalePrice: FieldRef<"TransferItem", 'Decimal'>
    readonly destinationRetailPrice: FieldRef<"TransferItem", 'Decimal'>
    readonly notes: FieldRef<"TransferItem", 'String'>
    readonly createdAt: FieldRef<"TransferItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferItem findUnique
   */
  export type TransferItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem findUniqueOrThrow
   */
  export type TransferItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem findFirst
   */
  export type TransferItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferItems.
     */
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem findFirstOrThrow
   */
  export type TransferItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferItems.
     */
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem findMany
   */
  export type TransferItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItems to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem create
   */
  export type TransferItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferItem.
     */
    data: XOR<TransferItemCreateInput, TransferItemUncheckedCreateInput>
  }

  /**
   * TransferItem createMany
   */
  export type TransferItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferItems.
     */
    data: TransferItemCreateManyInput | TransferItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferItem createManyAndReturn
   */
  export type TransferItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * The data used to create many TransferItems.
     */
    data: TransferItemCreateManyInput | TransferItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferItem update
   */
  export type TransferItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferItem.
     */
    data: XOR<TransferItemUpdateInput, TransferItemUncheckedUpdateInput>
    /**
     * Choose, which TransferItem to update.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem updateMany
   */
  export type TransferItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferItems.
     */
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferItems to update
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to update.
     */
    limit?: number
  }

  /**
   * TransferItem updateManyAndReturn
   */
  export type TransferItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * The data used to update TransferItems.
     */
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferItems to update
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferItem upsert
   */
  export type TransferItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferItem to update in case it exists.
     */
    where: TransferItemWhereUniqueInput
    /**
     * In case the TransferItem found by the `where` argument doesn't exist, create a new TransferItem with this data.
     */
    create: XOR<TransferItemCreateInput, TransferItemUncheckedCreateInput>
    /**
     * In case the TransferItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferItemUpdateInput, TransferItemUncheckedUpdateInput>
  }

  /**
   * TransferItem delete
   */
  export type TransferItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter which TransferItem to delete.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem deleteMany
   */
  export type TransferItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferItems to delete
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to delete.
     */
    limit?: number
  }

  /**
   * TransferItem.InventoryItem_TransferItem_destinationInventoryIdToInventoryItem
   */
  export type TransferItem$InventoryItem_TransferItem_destinationInventoryIdToInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
  }

  /**
   * TransferItem.InventoryItem_TransferItem_sourceInventoryIdToInventoryItem
   */
  export type TransferItem$InventoryItem_TransferItem_sourceInventoryIdToInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
  }

  /**
   * TransferItem without action
   */
  export type TransferItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerSumAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    birthDate: Date | null
    gender: string | null
    loyaltyPoints: number | null
    loyaltyTier: $Enums.LoyaltyTier | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    birthDate: Date | null
    gender: string | null
    loyaltyPoints: number | null
    loyaltyTier: $Enums.LoyaltyTier | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    birthDate: number
    gender: number
    loyaltyPoints: number
    loyaltyTier: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerSumAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birthDate?: true
    gender?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birthDate?: true
    gender?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birthDate?: true
    gender?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    birthDate: Date | null
    gender: string | null
    loyaltyPoints: number
    loyaltyTier: $Enums.LoyaltyTier
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthDate?: boolean
    gender?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerAddresses?: boolean | Customer$customerAddressesArgs<ExtArgs>
    CustomerNote?: boolean | Customer$CustomerNoteArgs<ExtArgs>
    CustomerToGroup?: boolean | Customer$CustomerToGroupArgs<ExtArgs>
    loyaltyTransactions?: boolean | Customer$loyaltyTransactionsArgs<ExtArgs>
    PromotionRedemption?: boolean | Customer$PromotionRedemptionArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthDate?: boolean
    gender?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthDate?: boolean
    gender?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birthDate?: boolean
    gender?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "birthDate" | "gender" | "loyaltyPoints" | "loyaltyTier" | "notes" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerAddresses?: boolean | Customer$customerAddressesArgs<ExtArgs>
    CustomerNote?: boolean | Customer$CustomerNoteArgs<ExtArgs>
    CustomerToGroup?: boolean | Customer$CustomerToGroupArgs<ExtArgs>
    loyaltyTransactions?: boolean | Customer$loyaltyTransactionsArgs<ExtArgs>
    PromotionRedemption?: boolean | Customer$PromotionRedemptionArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      customerAddresses: Prisma.$CustomerAddressPayload<ExtArgs>[]
      CustomerNote: Prisma.$CustomerNotePayload<ExtArgs>[]
      CustomerToGroup: Prisma.$CustomerToGroupPayload<ExtArgs>[]
      loyaltyTransactions: Prisma.$LoyaltyTransactionPayload<ExtArgs>[]
      PromotionRedemption: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      birthDate: Date | null
      gender: string | null
      loyaltyPoints: number
      loyaltyTier: $Enums.LoyaltyTier
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerAddresses<T extends Customer$customerAddressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerAddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerNote<T extends Customer$CustomerNoteArgs<ExtArgs> = {}>(args?: Subset<T, Customer$CustomerNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerToGroup<T extends Customer$CustomerToGroupArgs<ExtArgs> = {}>(args?: Subset<T, Customer$CustomerToGroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loyaltyTransactions<T extends Customer$loyaltyTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$loyaltyTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PromotionRedemption<T extends Customer$PromotionRedemptionArgs<ExtArgs> = {}>(args?: Subset<T, Customer$PromotionRedemptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly birthDate: FieldRef<"Customer", 'DateTime'>
    readonly gender: FieldRef<"Customer", 'String'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly loyaltyTier: FieldRef<"Customer", 'LoyaltyTier'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.customerAddresses
   */
  export type Customer$customerAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.CustomerNote
   */
  export type Customer$CustomerNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    where?: CustomerNoteWhereInput
    orderBy?: CustomerNoteOrderByWithRelationInput | CustomerNoteOrderByWithRelationInput[]
    cursor?: CustomerNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerNoteScalarFieldEnum | CustomerNoteScalarFieldEnum[]
  }

  /**
   * Customer.CustomerToGroup
   */
  export type Customer$CustomerToGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    where?: CustomerToGroupWhereInput
    orderBy?: CustomerToGroupOrderByWithRelationInput | CustomerToGroupOrderByWithRelationInput[]
    cursor?: CustomerToGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerToGroupScalarFieldEnum | CustomerToGroupScalarFieldEnum[]
  }

  /**
   * Customer.loyaltyTransactions
   */
  export type Customer$loyaltyTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * Customer.PromotionRedemption
   */
  export type Customer$PromotionRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    addressType: string | null
    isDefault: boolean | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    addressType: string | null
    isDefault: boolean | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customerId: number
    addressType: number
    isDefault: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customerId?: true
    addressType?: true
    isDefault?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    addressType?: true
    isDefault?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customerId?: true
    addressType?: true
    isDefault?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: string
    customerId: string
    addressType: string
    isDefault: boolean
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string | null
    postalCode: string
    country: string
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerAddressCountAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    addressType?: boolean
    isDefault?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    addressType?: boolean
    isDefault?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    addressType?: boolean
    isDefault?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    addressType?: boolean
    isDefault?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "addressType" | "isDefault" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "country" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["customerAddress"]>
  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      addressType: string
      isDefault: boolean
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string | null
      postalCode: string
      country: string
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses and returns the data updated in the database.
     * @param {CustomerAddressUpdateManyAndReturnArgs} args - Arguments to update many CustomerAddresses.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'String'>
    readonly customerId: FieldRef<"CustomerAddress", 'String'>
    readonly addressType: FieldRef<"CustomerAddress", 'String'>
    readonly isDefault: FieldRef<"CustomerAddress", 'Boolean'>
    readonly addressLine1: FieldRef<"CustomerAddress", 'String'>
    readonly addressLine2: FieldRef<"CustomerAddress", 'String'>
    readonly city: FieldRef<"CustomerAddress", 'String'>
    readonly state: FieldRef<"CustomerAddress", 'String'>
    readonly postalCode: FieldRef<"CustomerAddress", 'String'>
    readonly country: FieldRef<"CustomerAddress", 'String'>
    readonly phone: FieldRef<"CustomerAddress", 'String'>
    readonly createdAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
  }

  /**
   * CustomerAddress updateManyAndReturn
   */
  export type CustomerAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to delete.
     */
    limit?: number
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyProgram
   */

  export type AggregateLoyaltyProgram = {
    _count: LoyaltyProgramCountAggregateOutputType | null
    _avg: LoyaltyProgramAvgAggregateOutputType | null
    _sum: LoyaltyProgramSumAggregateOutputType | null
    _min: LoyaltyProgramMinAggregateOutputType | null
    _max: LoyaltyProgramMaxAggregateOutputType | null
  }

  export type LoyaltyProgramAvgAggregateOutputType = {
    pointsPerCurrency: Decimal | null
    minimumPurchase: Decimal | null
  }

  export type LoyaltyProgramSumAggregateOutputType = {
    pointsPerCurrency: Decimal | null
    minimumPurchase: Decimal | null
  }

  export type LoyaltyProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsPerCurrency: Decimal | null
    minimumPurchase: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsPerCurrency: Decimal | null
    minimumPurchase: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pointsPerCurrency: number
    minimumPurchase: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyProgramAvgAggregateInputType = {
    pointsPerCurrency?: true
    minimumPurchase?: true
  }

  export type LoyaltyProgramSumAggregateInputType = {
    pointsPerCurrency?: true
    minimumPurchase?: true
  }

  export type LoyaltyProgramMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsPerCurrency?: true
    minimumPurchase?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsPerCurrency?: true
    minimumPurchase?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsPerCurrency?: true
    minimumPurchase?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgram to aggregate.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyPrograms
    **/
    _count?: true | LoyaltyProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyProgramMaxAggregateInputType
  }

  export type GetLoyaltyProgramAggregateType<T extends LoyaltyProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyProgram[P]>
      : GetScalarType<T[P], AggregateLoyaltyProgram[P]>
  }




  export type LoyaltyProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramWhereInput
    orderBy?: LoyaltyProgramOrderByWithAggregationInput | LoyaltyProgramOrderByWithAggregationInput[]
    by: LoyaltyProgramScalarFieldEnum[] | LoyaltyProgramScalarFieldEnum
    having?: LoyaltyProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyProgramCountAggregateInputType | true
    _avg?: LoyaltyProgramAvgAggregateInputType
    _sum?: LoyaltyProgramSumAggregateInputType
    _min?: LoyaltyProgramMinAggregateInputType
    _max?: LoyaltyProgramMaxAggregateInputType
  }

  export type LoyaltyProgramGroupByOutputType = {
    id: string
    name: string
    description: string | null
    pointsPerCurrency: Decimal
    minimumPurchase: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyProgramCountAggregateOutputType | null
    _avg: LoyaltyProgramAvgAggregateOutputType | null
    _sum: LoyaltyProgramSumAggregateOutputType | null
    _min: LoyaltyProgramMinAggregateOutputType | null
    _max: LoyaltyProgramMaxAggregateOutputType | null
  }

  type GetLoyaltyProgramGroupByPayload<T extends LoyaltyProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyProgramGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyProgramGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerCurrency?: boolean
    minimumPurchase?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CustomerPromotion?: boolean | LoyaltyProgram$CustomerPromotionArgs<ExtArgs>
    LoyaltyProgramRule?: boolean | LoyaltyProgram$LoyaltyProgramRuleArgs<ExtArgs>
    tiers?: boolean | LoyaltyProgram$tiersArgs<ExtArgs>
    transactions?: boolean | LoyaltyProgram$transactionsArgs<ExtArgs>
    _count?: boolean | LoyaltyProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgram"]>

  export type LoyaltyProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerCurrency?: boolean
    minimumPurchase?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loyaltyProgram"]>

  export type LoyaltyProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerCurrency?: boolean
    minimumPurchase?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loyaltyProgram"]>

  export type LoyaltyProgramSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerCurrency?: boolean
    minimumPurchase?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "pointsPerCurrency" | "minimumPurchase" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["loyaltyProgram"]>
  export type LoyaltyProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerPromotion?: boolean | LoyaltyProgram$CustomerPromotionArgs<ExtArgs>
    LoyaltyProgramRule?: boolean | LoyaltyProgram$LoyaltyProgramRuleArgs<ExtArgs>
    tiers?: boolean | LoyaltyProgram$tiersArgs<ExtArgs>
    transactions?: boolean | LoyaltyProgram$transactionsArgs<ExtArgs>
    _count?: boolean | LoyaltyProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LoyaltyProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LoyaltyProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyProgram"
    objects: {
      CustomerPromotion: Prisma.$CustomerPromotionPayload<ExtArgs>[]
      LoyaltyProgramRule: Prisma.$LoyaltyProgramRulePayload<ExtArgs>[]
      tiers: Prisma.$LoyaltyProgramTierPayload<ExtArgs>[]
      transactions: Prisma.$LoyaltyTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      pointsPerCurrency: Prisma.Decimal
      minimumPurchase: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyProgram"]>
    composites: {}
  }

  type LoyaltyProgramGetPayload<S extends boolean | null | undefined | LoyaltyProgramDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyProgramPayload, S>

  type LoyaltyProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyProgramCountAggregateInputType | true
    }

  export interface LoyaltyProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyProgram'], meta: { name: 'LoyaltyProgram' } }
    /**
     * Find zero or one LoyaltyProgram that matches the filter.
     * @param {LoyaltyProgramFindUniqueArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyProgramFindUniqueArgs>(args: SelectSubset<T, LoyaltyProgramFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyProgramFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramFindFirstArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyProgramFindFirstArgs>(args?: SelectSubset<T, LoyaltyProgramFindFirstArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramFindFirstOrThrowArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyPrograms
     * const loyaltyPrograms = await prisma.loyaltyProgram.findMany()
     * 
     * // Get first 10 LoyaltyPrograms
     * const loyaltyPrograms = await prisma.loyaltyProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyProgramWithIdOnly = await prisma.loyaltyProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyProgramFindManyArgs>(args?: SelectSubset<T, LoyaltyProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyProgram.
     * @param {LoyaltyProgramCreateArgs} args - Arguments to create a LoyaltyProgram.
     * @example
     * // Create one LoyaltyProgram
     * const LoyaltyProgram = await prisma.loyaltyProgram.create({
     *   data: {
     *     // ... data to create a LoyaltyProgram
     *   }
     * })
     * 
     */
    create<T extends LoyaltyProgramCreateArgs>(args: SelectSubset<T, LoyaltyProgramCreateArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyPrograms.
     * @param {LoyaltyProgramCreateManyArgs} args - Arguments to create many LoyaltyPrograms.
     * @example
     * // Create many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyProgramCreateManyArgs>(args?: SelectSubset<T, LoyaltyProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyPrograms and returns the data saved in the database.
     * @param {LoyaltyProgramCreateManyAndReturnArgs} args - Arguments to create many LoyaltyPrograms.
     * @example
     * // Create many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyPrograms and only return the `id`
     * const loyaltyProgramWithIdOnly = await prisma.loyaltyProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyProgram.
     * @param {LoyaltyProgramDeleteArgs} args - Arguments to delete one LoyaltyProgram.
     * @example
     * // Delete one LoyaltyProgram
     * const LoyaltyProgram = await prisma.loyaltyProgram.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyProgram
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyProgramDeleteArgs>(args: SelectSubset<T, LoyaltyProgramDeleteArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyProgram.
     * @param {LoyaltyProgramUpdateArgs} args - Arguments to update one LoyaltyProgram.
     * @example
     * // Update one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyProgramUpdateArgs>(args: SelectSubset<T, LoyaltyProgramUpdateArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyPrograms.
     * @param {LoyaltyProgramDeleteManyArgs} args - Arguments to filter LoyaltyPrograms to delete.
     * @example
     * // Delete a few LoyaltyPrograms
     * const { count } = await prisma.loyaltyProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyProgramDeleteManyArgs>(args?: SelectSubset<T, LoyaltyProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyProgramUpdateManyArgs>(args: SelectSubset<T, LoyaltyProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyPrograms and returns the data updated in the database.
     * @param {LoyaltyProgramUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyPrograms.
     * @example
     * // Update many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyPrograms and only return the `id`
     * const loyaltyProgramWithIdOnly = await prisma.loyaltyProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyProgram.
     * @param {LoyaltyProgramUpsertArgs} args - Arguments to update or create a LoyaltyProgram.
     * @example
     * // Update or create a LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.upsert({
     *   create: {
     *     // ... data to create a LoyaltyProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyProgram we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyProgramUpsertArgs>(args: SelectSubset<T, LoyaltyProgramUpsertArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramCountArgs} args - Arguments to filter LoyaltyPrograms to count.
     * @example
     * // Count the number of LoyaltyPrograms
     * const count = await prisma.loyaltyProgram.count({
     *   where: {
     *     // ... the filter for the LoyaltyPrograms we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyProgramCountArgs>(
      args?: Subset<T, LoyaltyProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyProgramAggregateArgs>(args: Subset<T, LoyaltyProgramAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyProgramAggregateType<T>>

    /**
     * Group by LoyaltyProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyProgramGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyProgram model
   */
  readonly fields: LoyaltyProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CustomerPromotion<T extends LoyaltyProgram$CustomerPromotionArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgram$CustomerPromotionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LoyaltyProgramRule<T extends LoyaltyProgram$LoyaltyProgramRuleArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgram$LoyaltyProgramRuleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tiers<T extends LoyaltyProgram$tiersArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgram$tiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends LoyaltyProgram$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgram$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyProgram model
   */
  interface LoyaltyProgramFieldRefs {
    readonly id: FieldRef<"LoyaltyProgram", 'String'>
    readonly name: FieldRef<"LoyaltyProgram", 'String'>
    readonly description: FieldRef<"LoyaltyProgram", 'String'>
    readonly pointsPerCurrency: FieldRef<"LoyaltyProgram", 'Decimal'>
    readonly minimumPurchase: FieldRef<"LoyaltyProgram", 'Decimal'>
    readonly isActive: FieldRef<"LoyaltyProgram", 'Boolean'>
    readonly createdAt: FieldRef<"LoyaltyProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyProgram findUnique
   */
  export type LoyaltyProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram findUniqueOrThrow
   */
  export type LoyaltyProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram findFirst
   */
  export type LoyaltyProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyPrograms.
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyPrograms.
     */
    distinct?: LoyaltyProgramScalarFieldEnum | LoyaltyProgramScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram findFirstOrThrow
   */
  export type LoyaltyProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyPrograms.
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyPrograms.
     */
    distinct?: LoyaltyProgramScalarFieldEnum | LoyaltyProgramScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram findMany
   */
  export type LoyaltyProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyPrograms to fetch.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyPrograms.
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    distinct?: LoyaltyProgramScalarFieldEnum | LoyaltyProgramScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram create
   */
  export type LoyaltyProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyProgram.
     */
    data: XOR<LoyaltyProgramCreateInput, LoyaltyProgramUncheckedCreateInput>
  }

  /**
   * LoyaltyProgram createMany
   */
  export type LoyaltyProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyPrograms.
     */
    data: LoyaltyProgramCreateManyInput | LoyaltyProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgram createManyAndReturn
   */
  export type LoyaltyProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyPrograms.
     */
    data: LoyaltyProgramCreateManyInput | LoyaltyProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgram update
   */
  export type LoyaltyProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyProgram.
     */
    data: XOR<LoyaltyProgramUpdateInput, LoyaltyProgramUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyProgram to update.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram updateMany
   */
  export type LoyaltyProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyPrograms.
     */
    data: XOR<LoyaltyProgramUpdateManyMutationInput, LoyaltyProgramUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyPrograms to update
     */
    where?: LoyaltyProgramWhereInput
    /**
     * Limit how many LoyaltyPrograms to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgram updateManyAndReturn
   */
  export type LoyaltyProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyPrograms.
     */
    data: XOR<LoyaltyProgramUpdateManyMutationInput, LoyaltyProgramUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyPrograms to update
     */
    where?: LoyaltyProgramWhereInput
    /**
     * Limit how many LoyaltyPrograms to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgram upsert
   */
  export type LoyaltyProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyProgram to update in case it exists.
     */
    where: LoyaltyProgramWhereUniqueInput
    /**
     * In case the LoyaltyProgram found by the `where` argument doesn't exist, create a new LoyaltyProgram with this data.
     */
    create: XOR<LoyaltyProgramCreateInput, LoyaltyProgramUncheckedCreateInput>
    /**
     * In case the LoyaltyProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyProgramUpdateInput, LoyaltyProgramUncheckedUpdateInput>
  }

  /**
   * LoyaltyProgram delete
   */
  export type LoyaltyProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyProgram to delete.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram deleteMany
   */
  export type LoyaltyProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyPrograms to delete
     */
    where?: LoyaltyProgramWhereInput
    /**
     * Limit how many LoyaltyPrograms to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyProgram.CustomerPromotion
   */
  export type LoyaltyProgram$CustomerPromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    where?: CustomerPromotionWhereInput
    orderBy?: CustomerPromotionOrderByWithRelationInput | CustomerPromotionOrderByWithRelationInput[]
    cursor?: CustomerPromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPromotionScalarFieldEnum | CustomerPromotionScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram.LoyaltyProgramRule
   */
  export type LoyaltyProgram$LoyaltyProgramRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    where?: LoyaltyProgramRuleWhereInput
    orderBy?: LoyaltyProgramRuleOrderByWithRelationInput | LoyaltyProgramRuleOrderByWithRelationInput[]
    cursor?: LoyaltyProgramRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyProgramRuleScalarFieldEnum | LoyaltyProgramRuleScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram.tiers
   */
  export type LoyaltyProgram$tiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    where?: LoyaltyProgramTierWhereInput
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    cursor?: LoyaltyProgramTierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram.transactions
   */
  export type LoyaltyProgram$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram without action
   */
  export type LoyaltyProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyProgramTier
   */

  export type AggregateLoyaltyProgramTier = {
    _count: LoyaltyProgramTierCountAggregateOutputType | null
    _avg: LoyaltyProgramTierAvgAggregateOutputType | null
    _sum: LoyaltyProgramTierSumAggregateOutputType | null
    _min: LoyaltyProgramTierMinAggregateOutputType | null
    _max: LoyaltyProgramTierMaxAggregateOutputType | null
  }

  export type LoyaltyProgramTierAvgAggregateOutputType = {
    requiredPoints: number | null
    pointsMultiplier: Decimal | null
  }

  export type LoyaltyProgramTierSumAggregateOutputType = {
    requiredPoints: number | null
    pointsMultiplier: Decimal | null
  }

  export type LoyaltyProgramTierMinAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    description: string | null
    requiredPoints: number | null
    pointsMultiplier: Decimal | null
    benefits: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramTierMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    description: string | null
    requiredPoints: number | null
    pointsMultiplier: Decimal | null
    benefits: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramTierCountAggregateOutputType = {
    id: number
    programId: number
    name: number
    description: number
    requiredPoints: number
    pointsMultiplier: number
    benefits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyProgramTierAvgAggregateInputType = {
    requiredPoints?: true
    pointsMultiplier?: true
  }

  export type LoyaltyProgramTierSumAggregateInputType = {
    requiredPoints?: true
    pointsMultiplier?: true
  }

  export type LoyaltyProgramTierMinAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    requiredPoints?: true
    pointsMultiplier?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramTierMaxAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    requiredPoints?: true
    pointsMultiplier?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramTierCountAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    requiredPoints?: true
    pointsMultiplier?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyProgramTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgramTier to aggregate.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyProgramTiers
    **/
    _count?: true | LoyaltyProgramTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyProgramTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyProgramTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyProgramTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyProgramTierMaxAggregateInputType
  }

  export type GetLoyaltyProgramTierAggregateType<T extends LoyaltyProgramTierAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyProgramTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyProgramTier[P]>
      : GetScalarType<T[P], AggregateLoyaltyProgramTier[P]>
  }




  export type LoyaltyProgramTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramTierWhereInput
    orderBy?: LoyaltyProgramTierOrderByWithAggregationInput | LoyaltyProgramTierOrderByWithAggregationInput[]
    by: LoyaltyProgramTierScalarFieldEnum[] | LoyaltyProgramTierScalarFieldEnum
    having?: LoyaltyProgramTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyProgramTierCountAggregateInputType | true
    _avg?: LoyaltyProgramTierAvgAggregateInputType
    _sum?: LoyaltyProgramTierSumAggregateInputType
    _min?: LoyaltyProgramTierMinAggregateInputType
    _max?: LoyaltyProgramTierMaxAggregateInputType
  }

  export type LoyaltyProgramTierGroupByOutputType = {
    id: string
    programId: string
    name: string
    description: string | null
    requiredPoints: number
    pointsMultiplier: Decimal
    benefits: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyProgramTierCountAggregateOutputType | null
    _avg: LoyaltyProgramTierAvgAggregateOutputType | null
    _sum: LoyaltyProgramTierSumAggregateOutputType | null
    _min: LoyaltyProgramTierMinAggregateOutputType | null
    _max: LoyaltyProgramTierMaxAggregateOutputType | null
  }

  type GetLoyaltyProgramTierGroupByPayload<T extends LoyaltyProgramTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyProgramTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyProgramTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyProgramTierGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyProgramTierGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyProgramTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramTier"]>

  export type LoyaltyProgramTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramTier"]>

  export type LoyaltyProgramTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramTier"]>

  export type LoyaltyProgramTierSelectScalar = {
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyProgramTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "programId" | "name" | "description" | "requiredPoints" | "pointsMultiplier" | "benefits" | "createdAt" | "updatedAt", ExtArgs["result"]["loyaltyProgramTier"]>
  export type LoyaltyProgramTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramTierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }

  export type $LoyaltyProgramTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyProgramTier"
    objects: {
      program: Prisma.$LoyaltyProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      name: string
      description: string | null
      requiredPoints: number
      pointsMultiplier: Prisma.Decimal
      benefits: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyProgramTier"]>
    composites: {}
  }

  type LoyaltyProgramTierGetPayload<S extends boolean | null | undefined | LoyaltyProgramTierDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyProgramTierPayload, S>

  type LoyaltyProgramTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyProgramTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyProgramTierCountAggregateInputType | true
    }

  export interface LoyaltyProgramTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyProgramTier'], meta: { name: 'LoyaltyProgramTier' } }
    /**
     * Find zero or one LoyaltyProgramTier that matches the filter.
     * @param {LoyaltyProgramTierFindUniqueArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyProgramTierFindUniqueArgs>(args: SelectSubset<T, LoyaltyProgramTierFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyProgramTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyProgramTierFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyProgramTierFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyProgramTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgramTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierFindFirstArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyProgramTierFindFirstArgs>(args?: SelectSubset<T, LoyaltyProgramTierFindFirstArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgramTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierFindFirstOrThrowArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyProgramTierFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyProgramTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyProgramTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyProgramTiers
     * const loyaltyProgramTiers = await prisma.loyaltyProgramTier.findMany()
     * 
     * // Get first 10 LoyaltyProgramTiers
     * const loyaltyProgramTiers = await prisma.loyaltyProgramTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyProgramTierWithIdOnly = await prisma.loyaltyProgramTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyProgramTierFindManyArgs>(args?: SelectSubset<T, LoyaltyProgramTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyProgramTier.
     * @param {LoyaltyProgramTierCreateArgs} args - Arguments to create a LoyaltyProgramTier.
     * @example
     * // Create one LoyaltyProgramTier
     * const LoyaltyProgramTier = await prisma.loyaltyProgramTier.create({
     *   data: {
     *     // ... data to create a LoyaltyProgramTier
     *   }
     * })
     * 
     */
    create<T extends LoyaltyProgramTierCreateArgs>(args: SelectSubset<T, LoyaltyProgramTierCreateArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyProgramTiers.
     * @param {LoyaltyProgramTierCreateManyArgs} args - Arguments to create many LoyaltyProgramTiers.
     * @example
     * // Create many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyProgramTierCreateManyArgs>(args?: SelectSubset<T, LoyaltyProgramTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyProgramTiers and returns the data saved in the database.
     * @param {LoyaltyProgramTierCreateManyAndReturnArgs} args - Arguments to create many LoyaltyProgramTiers.
     * @example
     * // Create many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyProgramTiers and only return the `id`
     * const loyaltyProgramTierWithIdOnly = await prisma.loyaltyProgramTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyProgramTierCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyProgramTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyProgramTier.
     * @param {LoyaltyProgramTierDeleteArgs} args - Arguments to delete one LoyaltyProgramTier.
     * @example
     * // Delete one LoyaltyProgramTier
     * const LoyaltyProgramTier = await prisma.loyaltyProgramTier.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyProgramTier
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyProgramTierDeleteArgs>(args: SelectSubset<T, LoyaltyProgramTierDeleteArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyProgramTier.
     * @param {LoyaltyProgramTierUpdateArgs} args - Arguments to update one LoyaltyProgramTier.
     * @example
     * // Update one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyProgramTierUpdateArgs>(args: SelectSubset<T, LoyaltyProgramTierUpdateArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyProgramTiers.
     * @param {LoyaltyProgramTierDeleteManyArgs} args - Arguments to filter LoyaltyProgramTiers to delete.
     * @example
     * // Delete a few LoyaltyProgramTiers
     * const { count } = await prisma.loyaltyProgramTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyProgramTierDeleteManyArgs>(args?: SelectSubset<T, LoyaltyProgramTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyProgramTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyProgramTierUpdateManyArgs>(args: SelectSubset<T, LoyaltyProgramTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyProgramTiers and returns the data updated in the database.
     * @param {LoyaltyProgramTierUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyProgramTiers.
     * @example
     * // Update many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyProgramTiers and only return the `id`
     * const loyaltyProgramTierWithIdOnly = await prisma.loyaltyProgramTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyProgramTierUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyProgramTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyProgramTier.
     * @param {LoyaltyProgramTierUpsertArgs} args - Arguments to update or create a LoyaltyProgramTier.
     * @example
     * // Update or create a LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.upsert({
     *   create: {
     *     // ... data to create a LoyaltyProgramTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyProgramTier we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyProgramTierUpsertArgs>(args: SelectSubset<T, LoyaltyProgramTierUpsertArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyProgramTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierCountArgs} args - Arguments to filter LoyaltyProgramTiers to count.
     * @example
     * // Count the number of LoyaltyProgramTiers
     * const count = await prisma.loyaltyProgramTier.count({
     *   where: {
     *     // ... the filter for the LoyaltyProgramTiers we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyProgramTierCountArgs>(
      args?: Subset<T, LoyaltyProgramTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyProgramTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyProgramTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyProgramTierAggregateArgs>(args: Subset<T, LoyaltyProgramTierAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyProgramTierAggregateType<T>>

    /**
     * Group by LoyaltyProgramTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyProgramTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyProgramTierGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyProgramTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyProgramTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyProgramTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyProgramTier model
   */
  readonly fields: LoyaltyProgramTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyProgramTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyProgramTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends LoyaltyProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgramDefaultArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyProgramTier model
   */
  interface LoyaltyProgramTierFieldRefs {
    readonly id: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly programId: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly name: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly description: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly requiredPoints: FieldRef<"LoyaltyProgramTier", 'Int'>
    readonly pointsMultiplier: FieldRef<"LoyaltyProgramTier", 'Decimal'>
    readonly benefits: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly createdAt: FieldRef<"LoyaltyProgramTier", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyProgramTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyProgramTier findUnique
   */
  export type LoyaltyProgramTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier findUniqueOrThrow
   */
  export type LoyaltyProgramTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier findFirst
   */
  export type LoyaltyProgramTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyProgramTiers.
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyProgramTiers.
     */
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramTier findFirstOrThrow
   */
  export type LoyaltyProgramTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyProgramTiers.
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyProgramTiers.
     */
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramTier findMany
   */
  export type LoyaltyProgramTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTiers to fetch.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyProgramTiers.
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramTier create
   */
  export type LoyaltyProgramTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyProgramTier.
     */
    data: XOR<LoyaltyProgramTierCreateInput, LoyaltyProgramTierUncheckedCreateInput>
  }

  /**
   * LoyaltyProgramTier createMany
   */
  export type LoyaltyProgramTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyProgramTiers.
     */
    data: LoyaltyProgramTierCreateManyInput | LoyaltyProgramTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgramTier createManyAndReturn
   */
  export type LoyaltyProgramTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyProgramTiers.
     */
    data: LoyaltyProgramTierCreateManyInput | LoyaltyProgramTierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyProgramTier update
   */
  export type LoyaltyProgramTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyProgramTier.
     */
    data: XOR<LoyaltyProgramTierUpdateInput, LoyaltyProgramTierUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyProgramTier to update.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier updateMany
   */
  export type LoyaltyProgramTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyProgramTiers.
     */
    data: XOR<LoyaltyProgramTierUpdateManyMutationInput, LoyaltyProgramTierUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyProgramTiers to update
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * Limit how many LoyaltyProgramTiers to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgramTier updateManyAndReturn
   */
  export type LoyaltyProgramTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyProgramTiers.
     */
    data: XOR<LoyaltyProgramTierUpdateManyMutationInput, LoyaltyProgramTierUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyProgramTiers to update
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * Limit how many LoyaltyProgramTiers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyProgramTier upsert
   */
  export type LoyaltyProgramTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyProgramTier to update in case it exists.
     */
    where: LoyaltyProgramTierWhereUniqueInput
    /**
     * In case the LoyaltyProgramTier found by the `where` argument doesn't exist, create a new LoyaltyProgramTier with this data.
     */
    create: XOR<LoyaltyProgramTierCreateInput, LoyaltyProgramTierUncheckedCreateInput>
    /**
     * In case the LoyaltyProgramTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyProgramTierUpdateInput, LoyaltyProgramTierUncheckedUpdateInput>
  }

  /**
   * LoyaltyProgramTier delete
   */
  export type LoyaltyProgramTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyProgramTier to delete.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier deleteMany
   */
  export type LoyaltyProgramTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgramTiers to delete
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * Limit how many LoyaltyProgramTiers to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyProgramTier without action
   */
  export type LoyaltyProgramTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyTransaction
   */

  export type AggregateLoyaltyTransaction = {
    _count: LoyaltyTransactionCountAggregateOutputType | null
    _avg: LoyaltyTransactionAvgAggregateOutputType | null
    _sum: LoyaltyTransactionSumAggregateOutputType | null
    _min: LoyaltyTransactionMinAggregateOutputType | null
    _max: LoyaltyTransactionMaxAggregateOutputType | null
  }

  export type LoyaltyTransactionAvgAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyTransactionSumAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyTransactionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    programId: string | null
    points: number | null
    type: $Enums.LoyaltyTransactionType | null
    description: string | null
    referenceId: string | null
    expiryDate: Date | null
    createdAt: Date | null
  }

  export type LoyaltyTransactionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    programId: string | null
    points: number | null
    type: $Enums.LoyaltyTransactionType | null
    description: string | null
    referenceId: string | null
    expiryDate: Date | null
    createdAt: Date | null
  }

  export type LoyaltyTransactionCountAggregateOutputType = {
    id: number
    customerId: number
    programId: number
    points: number
    type: number
    description: number
    referenceId: number
    expiryDate: number
    createdAt: number
    _all: number
  }


  export type LoyaltyTransactionAvgAggregateInputType = {
    points?: true
  }

  export type LoyaltyTransactionSumAggregateInputType = {
    points?: true
  }

  export type LoyaltyTransactionMinAggregateInputType = {
    id?: true
    customerId?: true
    programId?: true
    points?: true
    type?: true
    description?: true
    referenceId?: true
    expiryDate?: true
    createdAt?: true
  }

  export type LoyaltyTransactionMaxAggregateInputType = {
    id?: true
    customerId?: true
    programId?: true
    points?: true
    type?: true
    description?: true
    referenceId?: true
    expiryDate?: true
    createdAt?: true
  }

  export type LoyaltyTransactionCountAggregateInputType = {
    id?: true
    customerId?: true
    programId?: true
    points?: true
    type?: true
    description?: true
    referenceId?: true
    expiryDate?: true
    createdAt?: true
    _all?: true
  }

  export type LoyaltyTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTransaction to aggregate.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyTransactions
    **/
    _count?: true | LoyaltyTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyTransactionMaxAggregateInputType
  }

  export type GetLoyaltyTransactionAggregateType<T extends LoyaltyTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
      : GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
  }




  export type LoyaltyTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithAggregationInput | LoyaltyTransactionOrderByWithAggregationInput[]
    by: LoyaltyTransactionScalarFieldEnum[] | LoyaltyTransactionScalarFieldEnum
    having?: LoyaltyTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyTransactionCountAggregateInputType | true
    _avg?: LoyaltyTransactionAvgAggregateInputType
    _sum?: LoyaltyTransactionSumAggregateInputType
    _min?: LoyaltyTransactionMinAggregateInputType
    _max?: LoyaltyTransactionMaxAggregateInputType
  }

  export type LoyaltyTransactionGroupByOutputType = {
    id: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description: string | null
    referenceId: string | null
    expiryDate: Date | null
    createdAt: Date
    _count: LoyaltyTransactionCountAggregateOutputType | null
    _avg: LoyaltyTransactionAvgAggregateOutputType | null
    _sum: LoyaltyTransactionSumAggregateOutputType | null
    _min: LoyaltyTransactionMinAggregateOutputType | null
    _max: LoyaltyTransactionMaxAggregateOutputType | null
  }

  type GetLoyaltyTransactionGroupByPayload<T extends LoyaltyTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
    Sale?: boolean | LoyaltyTransaction$SaleArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
    Sale?: boolean | LoyaltyTransaction$SaleArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
    Sale?: boolean | LoyaltyTransaction$SaleArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectScalar = {
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    expiryDate?: boolean
    createdAt?: boolean
  }

  export type LoyaltyTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "programId" | "points" | "type" | "description" | "referenceId" | "expiryDate" | "createdAt", ExtArgs["result"]["loyaltyTransaction"]>
  export type LoyaltyTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
    Sale?: boolean | LoyaltyTransaction$SaleArgs<ExtArgs>
  }
  export type LoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
    Sale?: boolean | LoyaltyTransaction$SaleArgs<ExtArgs>
  }
  export type LoyaltyTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
    Sale?: boolean | LoyaltyTransaction$SaleArgs<ExtArgs>
  }

  export type $LoyaltyTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyTransaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      program: Prisma.$LoyaltyProgramPayload<ExtArgs>
      Sale: Prisma.$SalePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      programId: string
      points: number
      type: $Enums.LoyaltyTransactionType
      description: string | null
      referenceId: string | null
      expiryDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["loyaltyTransaction"]>
    composites: {}
  }

  type LoyaltyTransactionGetPayload<S extends boolean | null | undefined | LoyaltyTransactionDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyTransactionPayload, S>

  type LoyaltyTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyTransactionCountAggregateInputType | true
    }

  export interface LoyaltyTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyTransaction'], meta: { name: 'LoyaltyTransaction' } }
    /**
     * Find zero or one LoyaltyTransaction that matches the filter.
     * @param {LoyaltyTransactionFindUniqueArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyTransactionFindUniqueArgs>(args: SelectSubset<T, LoyaltyTransactionFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyTransactionFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindFirstArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyTransactionFindFirstArgs>(args?: SelectSubset<T, LoyaltyTransactionFindFirstArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindFirstOrThrowArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyTransactions
     * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
     * 
     * // Get first 10 LoyaltyTransactions
     * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyTransactionFindManyArgs>(args?: SelectSubset<T, LoyaltyTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyTransaction.
     * @param {LoyaltyTransactionCreateArgs} args - Arguments to create a LoyaltyTransaction.
     * @example
     * // Create one LoyaltyTransaction
     * const LoyaltyTransaction = await prisma.loyaltyTransaction.create({
     *   data: {
     *     // ... data to create a LoyaltyTransaction
     *   }
     * })
     * 
     */
    create<T extends LoyaltyTransactionCreateArgs>(args: SelectSubset<T, LoyaltyTransactionCreateArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyTransactions.
     * @param {LoyaltyTransactionCreateManyArgs} args - Arguments to create many LoyaltyTransactions.
     * @example
     * // Create many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyTransactionCreateManyArgs>(args?: SelectSubset<T, LoyaltyTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyTransactions and returns the data saved in the database.
     * @param {LoyaltyTransactionCreateManyAndReturnArgs} args - Arguments to create many LoyaltyTransactions.
     * @example
     * // Create many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyTransactions and only return the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyTransaction.
     * @param {LoyaltyTransactionDeleteArgs} args - Arguments to delete one LoyaltyTransaction.
     * @example
     * // Delete one LoyaltyTransaction
     * const LoyaltyTransaction = await prisma.loyaltyTransaction.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyTransaction
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyTransactionDeleteArgs>(args: SelectSubset<T, LoyaltyTransactionDeleteArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyTransaction.
     * @param {LoyaltyTransactionUpdateArgs} args - Arguments to update one LoyaltyTransaction.
     * @example
     * // Update one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyTransactionUpdateArgs>(args: SelectSubset<T, LoyaltyTransactionUpdateArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyTransactions.
     * @param {LoyaltyTransactionDeleteManyArgs} args - Arguments to filter LoyaltyTransactions to delete.
     * @example
     * // Delete a few LoyaltyTransactions
     * const { count } = await prisma.loyaltyTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyTransactionDeleteManyArgs>(args?: SelectSubset<T, LoyaltyTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyTransactionUpdateManyArgs>(args: SelectSubset<T, LoyaltyTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyTransactions and returns the data updated in the database.
     * @param {LoyaltyTransactionUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyTransactions.
     * @example
     * // Update many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyTransactions and only return the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyTransaction.
     * @param {LoyaltyTransactionUpsertArgs} args - Arguments to update or create a LoyaltyTransaction.
     * @example
     * // Update or create a LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.upsert({
     *   create: {
     *     // ... data to create a LoyaltyTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyTransaction we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyTransactionUpsertArgs>(args: SelectSubset<T, LoyaltyTransactionUpsertArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionCountArgs} args - Arguments to filter LoyaltyTransactions to count.
     * @example
     * // Count the number of LoyaltyTransactions
     * const count = await prisma.loyaltyTransaction.count({
     *   where: {
     *     // ... the filter for the LoyaltyTransactions we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyTransactionCountArgs>(
      args?: Subset<T, LoyaltyTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyTransactionAggregateArgs>(args: Subset<T, LoyaltyTransactionAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyTransactionAggregateType<T>>

    /**
     * Group by LoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyTransactionGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyTransaction model
   */
  readonly fields: LoyaltyTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends LoyaltyProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgramDefaultArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Sale<T extends LoyaltyTransaction$SaleArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyTransaction$SaleArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyTransaction model
   */
  interface LoyaltyTransactionFieldRefs {
    readonly id: FieldRef<"LoyaltyTransaction", 'String'>
    readonly customerId: FieldRef<"LoyaltyTransaction", 'String'>
    readonly programId: FieldRef<"LoyaltyTransaction", 'String'>
    readonly points: FieldRef<"LoyaltyTransaction", 'Int'>
    readonly type: FieldRef<"LoyaltyTransaction", 'LoyaltyTransactionType'>
    readonly description: FieldRef<"LoyaltyTransaction", 'String'>
    readonly referenceId: FieldRef<"LoyaltyTransaction", 'String'>
    readonly expiryDate: FieldRef<"LoyaltyTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"LoyaltyTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyTransaction findUnique
   */
  export type LoyaltyTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction findUniqueOrThrow
   */
  export type LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction findFirst
   */
  export type LoyaltyTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTransactions.
     */
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyTransaction findFirstOrThrow
   */
  export type LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTransactions.
     */
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyTransaction findMany
   */
  export type LoyaltyTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransactions to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyTransaction create
   */
  export type LoyaltyTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyTransaction.
     */
    data: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
  }

  /**
   * LoyaltyTransaction createMany
   */
  export type LoyaltyTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyTransactions.
     */
    data: LoyaltyTransactionCreateManyInput | LoyaltyTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyTransaction createManyAndReturn
   */
  export type LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyTransactions.
     */
    data: LoyaltyTransactionCreateManyInput | LoyaltyTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyTransaction update
   */
  export type LoyaltyTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyTransaction.
     */
    data: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyTransaction to update.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction updateMany
   */
  export type LoyaltyTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyTransactions.
     */
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyTransactions to update
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * Limit how many LoyaltyTransactions to update.
     */
    limit?: number
  }

  /**
   * LoyaltyTransaction updateManyAndReturn
   */
  export type LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyTransactions.
     */
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyTransactions to update
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * Limit how many LoyaltyTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyTransaction upsert
   */
  export type LoyaltyTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyTransaction to update in case it exists.
     */
    where: LoyaltyTransactionWhereUniqueInput
    /**
     * In case the LoyaltyTransaction found by the `where` argument doesn't exist, create a new LoyaltyTransaction with this data.
     */
    create: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
    /**
     * In case the LoyaltyTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
  }

  /**
   * LoyaltyTransaction delete
   */
  export type LoyaltyTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyTransaction to delete.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction deleteMany
   */
  export type LoyaltyTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTransactions to delete
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * Limit how many LoyaltyTransactions to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyTransaction.Sale
   */
  export type LoyaltyTransaction$SaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
  }

  /**
   * LoyaltyTransaction without action
   */
  export type LoyaltyTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Audit
   */

  export type AggregateAudit = {
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  export type AuditMinAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    warehouseId: string | null
    status: $Enums.AuditStatus | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditMaxAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    warehouseId: string | null
    status: $Enums.AuditStatus | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditCountAggregateOutputType = {
    id: number
    referenceNumber: number
    warehouseId: number
    status: number
    startDate: number
    endDate: number
    notes: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditMinAggregateInputType = {
    id?: true
    referenceNumber?: true
    warehouseId?: true
    status?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditMaxAggregateInputType = {
    id?: true
    referenceNumber?: true
    warehouseId?: true
    status?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditCountAggregateInputType = {
    id?: true
    referenceNumber?: true
    warehouseId?: true
    status?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audit to aggregate.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audits
    **/
    _count?: true | AuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditMaxAggregateInputType
  }

  export type GetAuditAggregateType<T extends AuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit[P]>
      : GetScalarType<T[P], AggregateAudit[P]>
  }




  export type AuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithAggregationInput | AuditOrderByWithAggregationInput[]
    by: AuditScalarFieldEnum[] | AuditScalarFieldEnum
    having?: AuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditCountAggregateInputType | true
    _min?: AuditMinAggregateInputType
    _max?: AuditMaxAggregateInputType
  }

  export type AuditGroupByOutputType = {
    id: string
    referenceNumber: string
    warehouseId: string
    status: $Enums.AuditStatus
    startDate: Date
    endDate: Date | null
    notes: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  type GetAuditGroupByPayload<T extends AuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditGroupByOutputType[P]>
            : GetScalarType<T[P], AuditGroupByOutputType[P]>
        }
      >
    >


  export type AuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    assignments?: boolean | Audit$assignmentsArgs<ExtArgs>
    items?: boolean | Audit$itemsArgs<ExtArgs>
    _count?: boolean | AuditCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectScalar = {
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceNumber" | "warehouseId" | "status" | "startDate" | "endDate" | "notes" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["audit"]>
  export type AuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    assignments?: boolean | Audit$assignmentsArgs<ExtArgs>
    items?: boolean | Audit$itemsArgs<ExtArgs>
    _count?: boolean | AuditCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type AuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $AuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Audit"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      assignments: Prisma.$AuditAssignmentPayload<ExtArgs>[]
      items: Prisma.$AuditItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceNumber: string
      warehouseId: string
      status: $Enums.AuditStatus
      startDate: Date
      endDate: Date | null
      notes: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audit"]>
    composites: {}
  }

  type AuditGetPayload<S extends boolean | null | undefined | AuditDefaultArgs> = $Result.GetResult<Prisma.$AuditPayload, S>

  type AuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditCountAggregateInputType | true
    }

  export interface AuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Audit'], meta: { name: 'Audit' } }
    /**
     * Find zero or one Audit that matches the filter.
     * @param {AuditFindUniqueArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditFindUniqueArgs>(args: SelectSubset<T, AuditFindUniqueArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditFindUniqueOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditFindFirstArgs>(args?: SelectSubset<T, AuditFindFirstArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audit.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWithIdOnly = await prisma.audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditFindManyArgs>(args?: SelectSubset<T, AuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit.
     * @param {AuditCreateArgs} args - Arguments to create a Audit.
     * @example
     * // Create one Audit
     * const Audit = await prisma.audit.create({
     *   data: {
     *     // ... data to create a Audit
     *   }
     * })
     * 
     */
    create<T extends AuditCreateArgs>(args: SelectSubset<T, AuditCreateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audits.
     * @param {AuditCreateManyArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditCreateManyArgs>(args?: SelectSubset<T, AuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audits and returns the data saved in the database.
     * @param {AuditCreateManyAndReturnArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit.
     * @param {AuditDeleteArgs} args - Arguments to delete one Audit.
     * @example
     * // Delete one Audit
     * const Audit = await prisma.audit.delete({
     *   where: {
     *     // ... filter to delete one Audit
     *   }
     * })
     * 
     */
    delete<T extends AuditDeleteArgs>(args: SelectSubset<T, AuditDeleteArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit.
     * @param {AuditUpdateArgs} args - Arguments to update one Audit.
     * @example
     * // Update one Audit
     * const audit = await prisma.audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditUpdateArgs>(args: SelectSubset<T, AuditUpdateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audits.
     * @param {AuditDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditDeleteManyArgs>(args?: SelectSubset<T, AuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditUpdateManyArgs>(args: SelectSubset<T, AuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits and returns the data updated in the database.
     * @param {AuditUpdateManyAndReturnArgs} args - Arguments to update many Audits.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit.
     * @param {AuditUpsertArgs} args - Arguments to update or create a Audit.
     * @example
     * // Update or create a Audit
     * const audit = await prisma.audit.upsert({
     *   create: {
     *     // ... data to create a Audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit we want to update
     *   }
     * })
     */
    upsert<T extends AuditUpsertArgs>(args: SelectSubset<T, AuditUpsertArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audit.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends AuditCountArgs>(
      args?: Subset<T, AuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAggregateArgs>(args: Subset<T, AuditAggregateArgs>): Prisma.PrismaPromise<GetAuditAggregateType<T>>

    /**
     * Group by Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditGroupByArgs['orderBy'] }
        : { orderBy?: AuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Audit model
   */
  readonly fields: AuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends Audit$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Audit$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Audit model
   */
  interface AuditFieldRefs {
    readonly id: FieldRef<"Audit", 'String'>
    readonly referenceNumber: FieldRef<"Audit", 'String'>
    readonly warehouseId: FieldRef<"Audit", 'String'>
    readonly status: FieldRef<"Audit", 'AuditStatus'>
    readonly startDate: FieldRef<"Audit", 'DateTime'>
    readonly endDate: FieldRef<"Audit", 'DateTime'>
    readonly notes: FieldRef<"Audit", 'String'>
    readonly createdById: FieldRef<"Audit", 'String'>
    readonly createdAt: FieldRef<"Audit", 'DateTime'>
    readonly updatedAt: FieldRef<"Audit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Audit findUnique
   */
  export type AuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findUniqueOrThrow
   */
  export type AuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findFirst
   */
  export type AuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findFirstOrThrow
   */
  export type AuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findMany
   */
  export type AuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit create
   */
  export type AuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to create a Audit.
     */
    data: XOR<AuditCreateInput, AuditUncheckedCreateInput>
  }

  /**
   * Audit createMany
   */
  export type AuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Audit createManyAndReturn
   */
  export type AuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Audit update
   */
  export type AuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to update a Audit.
     */
    data: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
    /**
     * Choose, which Audit to update.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit updateMany
   */
  export type AuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
  }

  /**
   * Audit updateManyAndReturn
   */
  export type AuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Audit upsert
   */
  export type AuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The filter to search for the Audit to update in case it exists.
     */
    where: AuditWhereUniqueInput
    /**
     * In case the Audit found by the `where` argument doesn't exist, create a new Audit with this data.
     */
    create: XOR<AuditCreateInput, AuditUncheckedCreateInput>
    /**
     * In case the Audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
  }

  /**
   * Audit delete
   */
  export type AuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter which Audit to delete.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit deleteMany
   */
  export type AuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audits to delete
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to delete.
     */
    limit?: number
  }

  /**
   * Audit.assignments
   */
  export type Audit$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    where?: AuditAssignmentWhereInput
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    cursor?: AuditAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * Audit.items
   */
  export type Audit$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    cursor?: AuditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * Audit without action
   */
  export type AuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
  }


  /**
   * Model AuditItem
   */

  export type AggregateAuditItem = {
    _count: AuditItemCountAggregateOutputType | null
    _avg: AuditItemAvgAggregateOutputType | null
    _sum: AuditItemSumAggregateOutputType | null
    _min: AuditItemMinAggregateOutputType | null
    _max: AuditItemMaxAggregateOutputType | null
  }

  export type AuditItemAvgAggregateOutputType = {
    expectedQuantity: number | null
    actualQuantity: number | null
    variance: number | null
  }

  export type AuditItemSumAggregateOutputType = {
    expectedQuantity: number | null
    actualQuantity: number | null
    variance: number | null
  }

  export type AuditItemMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    productId: string | null
    inventoryItemId: string | null
    expectedQuantity: number | null
    actualQuantity: number | null
    variance: number | null
    notes: string | null
    status: $Enums.AuditItemStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditItemMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    productId: string | null
    inventoryItemId: string | null
    expectedQuantity: number | null
    actualQuantity: number | null
    variance: number | null
    notes: string | null
    status: $Enums.AuditItemStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditItemCountAggregateOutputType = {
    id: number
    auditId: number
    productId: number
    inventoryItemId: number
    expectedQuantity: number
    actualQuantity: number
    variance: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditItemAvgAggregateInputType = {
    expectedQuantity?: true
    actualQuantity?: true
    variance?: true
  }

  export type AuditItemSumAggregateInputType = {
    expectedQuantity?: true
    actualQuantity?: true
    variance?: true
  }

  export type AuditItemMinAggregateInputType = {
    id?: true
    auditId?: true
    productId?: true
    inventoryItemId?: true
    expectedQuantity?: true
    actualQuantity?: true
    variance?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditItemMaxAggregateInputType = {
    id?: true
    auditId?: true
    productId?: true
    inventoryItemId?: true
    expectedQuantity?: true
    actualQuantity?: true
    variance?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditItemCountAggregateInputType = {
    id?: true
    auditId?: true
    productId?: true
    inventoryItemId?: true
    expectedQuantity?: true
    actualQuantity?: true
    variance?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditItem to aggregate.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditItems
    **/
    _count?: true | AuditItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditItemMaxAggregateInputType
  }

  export type GetAuditItemAggregateType<T extends AuditItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditItem[P]>
      : GetScalarType<T[P], AggregateAuditItem[P]>
  }




  export type AuditItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithAggregationInput | AuditItemOrderByWithAggregationInput[]
    by: AuditItemScalarFieldEnum[] | AuditItemScalarFieldEnum
    having?: AuditItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditItemCountAggregateInputType | true
    _avg?: AuditItemAvgAggregateInputType
    _sum?: AuditItemSumAggregateInputType
    _min?: AuditItemMinAggregateInputType
    _max?: AuditItemMaxAggregateInputType
  }

  export type AuditItemGroupByOutputType = {
    id: string
    auditId: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity: number | null
    variance: number | null
    notes: string | null
    status: $Enums.AuditItemStatus
    createdAt: Date
    updatedAt: Date
    _count: AuditItemCountAggregateOutputType | null
    _avg: AuditItemAvgAggregateOutputType | null
    _sum: AuditItemSumAggregateOutputType | null
    _min: AuditItemMinAggregateOutputType | null
    _max: AuditItemMaxAggregateOutputType | null
  }

  type GetAuditItemGroupByPayload<T extends AuditItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditItemGroupByOutputType[P]>
            : GetScalarType<T[P], AuditItemGroupByOutputType[P]>
        }
      >
    >


  export type AuditItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    actualQuantity?: boolean
    variance?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditItem"]>

  export type AuditItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    actualQuantity?: boolean
    variance?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditItem"]>

  export type AuditItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    actualQuantity?: boolean
    variance?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditItem"]>

  export type AuditItemSelectScalar = {
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    actualQuantity?: boolean
    variance?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "productId" | "inventoryItemId" | "expectedQuantity" | "actualQuantity" | "variance" | "notes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["auditItem"]>
  export type AuditItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AuditItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AuditItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $AuditItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditItem"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      productId: string
      inventoryItemId: string
      expectedQuantity: number
      actualQuantity: number | null
      variance: number | null
      notes: string | null
      status: $Enums.AuditItemStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditItem"]>
    composites: {}
  }

  type AuditItemGetPayload<S extends boolean | null | undefined | AuditItemDefaultArgs> = $Result.GetResult<Prisma.$AuditItemPayload, S>

  type AuditItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditItemCountAggregateInputType | true
    }

  export interface AuditItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditItem'], meta: { name: 'AuditItem' } }
    /**
     * Find zero or one AuditItem that matches the filter.
     * @param {AuditItemFindUniqueArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditItemFindUniqueArgs>(args: SelectSubset<T, AuditItemFindUniqueArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditItemFindUniqueOrThrowArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemFindFirstArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditItemFindFirstArgs>(args?: SelectSubset<T, AuditItemFindFirstArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemFindFirstOrThrowArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditItems
     * const auditItems = await prisma.auditItem.findMany()
     * 
     * // Get first 10 AuditItems
     * const auditItems = await prisma.auditItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditItemWithIdOnly = await prisma.auditItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditItemFindManyArgs>(args?: SelectSubset<T, AuditItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditItem.
     * @param {AuditItemCreateArgs} args - Arguments to create a AuditItem.
     * @example
     * // Create one AuditItem
     * const AuditItem = await prisma.auditItem.create({
     *   data: {
     *     // ... data to create a AuditItem
     *   }
     * })
     * 
     */
    create<T extends AuditItemCreateArgs>(args: SelectSubset<T, AuditItemCreateArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditItems.
     * @param {AuditItemCreateManyArgs} args - Arguments to create many AuditItems.
     * @example
     * // Create many AuditItems
     * const auditItem = await prisma.auditItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditItemCreateManyArgs>(args?: SelectSubset<T, AuditItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditItems and returns the data saved in the database.
     * @param {AuditItemCreateManyAndReturnArgs} args - Arguments to create many AuditItems.
     * @example
     * // Create many AuditItems
     * const auditItem = await prisma.auditItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditItems and only return the `id`
     * const auditItemWithIdOnly = await prisma.auditItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditItem.
     * @param {AuditItemDeleteArgs} args - Arguments to delete one AuditItem.
     * @example
     * // Delete one AuditItem
     * const AuditItem = await prisma.auditItem.delete({
     *   where: {
     *     // ... filter to delete one AuditItem
     *   }
     * })
     * 
     */
    delete<T extends AuditItemDeleteArgs>(args: SelectSubset<T, AuditItemDeleteArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditItem.
     * @param {AuditItemUpdateArgs} args - Arguments to update one AuditItem.
     * @example
     * // Update one AuditItem
     * const auditItem = await prisma.auditItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditItemUpdateArgs>(args: SelectSubset<T, AuditItemUpdateArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditItems.
     * @param {AuditItemDeleteManyArgs} args - Arguments to filter AuditItems to delete.
     * @example
     * // Delete a few AuditItems
     * const { count } = await prisma.auditItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditItemDeleteManyArgs>(args?: SelectSubset<T, AuditItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditItems
     * const auditItem = await prisma.auditItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditItemUpdateManyArgs>(args: SelectSubset<T, AuditItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditItems and returns the data updated in the database.
     * @param {AuditItemUpdateManyAndReturnArgs} args - Arguments to update many AuditItems.
     * @example
     * // Update many AuditItems
     * const auditItem = await prisma.auditItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditItems and only return the `id`
     * const auditItemWithIdOnly = await prisma.auditItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditItem.
     * @param {AuditItemUpsertArgs} args - Arguments to update or create a AuditItem.
     * @example
     * // Update or create a AuditItem
     * const auditItem = await prisma.auditItem.upsert({
     *   create: {
     *     // ... data to create a AuditItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditItem we want to update
     *   }
     * })
     */
    upsert<T extends AuditItemUpsertArgs>(args: SelectSubset<T, AuditItemUpsertArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemCountArgs} args - Arguments to filter AuditItems to count.
     * @example
     * // Count the number of AuditItems
     * const count = await prisma.auditItem.count({
     *   where: {
     *     // ... the filter for the AuditItems we want to count
     *   }
     * })
    **/
    count<T extends AuditItemCountArgs>(
      args?: Subset<T, AuditItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditItemAggregateArgs>(args: Subset<T, AuditItemAggregateArgs>): Prisma.PrismaPromise<GetAuditItemAggregateType<T>>

    /**
     * Group by AuditItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditItemGroupByArgs['orderBy'] }
        : { orderBy?: AuditItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditItem model
   */
  readonly fields: AuditItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditItem model
   */
  interface AuditItemFieldRefs {
    readonly id: FieldRef<"AuditItem", 'String'>
    readonly auditId: FieldRef<"AuditItem", 'String'>
    readonly productId: FieldRef<"AuditItem", 'String'>
    readonly inventoryItemId: FieldRef<"AuditItem", 'String'>
    readonly expectedQuantity: FieldRef<"AuditItem", 'Int'>
    readonly actualQuantity: FieldRef<"AuditItem", 'Int'>
    readonly variance: FieldRef<"AuditItem", 'Int'>
    readonly notes: FieldRef<"AuditItem", 'String'>
    readonly status: FieldRef<"AuditItem", 'AuditItemStatus'>
    readonly createdAt: FieldRef<"AuditItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditItem findUnique
   */
  export type AuditItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem findUniqueOrThrow
   */
  export type AuditItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem findFirst
   */
  export type AuditItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditItems.
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditItems.
     */
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * AuditItem findFirstOrThrow
   */
  export type AuditItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditItems.
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditItems.
     */
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * AuditItem findMany
   */
  export type AuditItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItems to fetch.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditItems.
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * AuditItem create
   */
  export type AuditItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditItem.
     */
    data: XOR<AuditItemCreateInput, AuditItemUncheckedCreateInput>
  }

  /**
   * AuditItem createMany
   */
  export type AuditItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditItems.
     */
    data: AuditItemCreateManyInput | AuditItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditItem createManyAndReturn
   */
  export type AuditItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * The data used to create many AuditItems.
     */
    data: AuditItemCreateManyInput | AuditItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditItem update
   */
  export type AuditItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditItem.
     */
    data: XOR<AuditItemUpdateInput, AuditItemUncheckedUpdateInput>
    /**
     * Choose, which AuditItem to update.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem updateMany
   */
  export type AuditItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditItems.
     */
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyInput>
    /**
     * Filter which AuditItems to update
     */
    where?: AuditItemWhereInput
    /**
     * Limit how many AuditItems to update.
     */
    limit?: number
  }

  /**
   * AuditItem updateManyAndReturn
   */
  export type AuditItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * The data used to update AuditItems.
     */
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyInput>
    /**
     * Filter which AuditItems to update
     */
    where?: AuditItemWhereInput
    /**
     * Limit how many AuditItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditItem upsert
   */
  export type AuditItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditItem to update in case it exists.
     */
    where: AuditItemWhereUniqueInput
    /**
     * In case the AuditItem found by the `where` argument doesn't exist, create a new AuditItem with this data.
     */
    create: XOR<AuditItemCreateInput, AuditItemUncheckedCreateInput>
    /**
     * In case the AuditItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditItemUpdateInput, AuditItemUncheckedUpdateInput>
  }

  /**
   * AuditItem delete
   */
  export type AuditItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter which AuditItem to delete.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem deleteMany
   */
  export type AuditItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditItems to delete
     */
    where?: AuditItemWhereInput
    /**
     * Limit how many AuditItems to delete.
     */
    limit?: number
  }

  /**
   * AuditItem without action
   */
  export type AuditItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
  }


  /**
   * Model AuditAssignment
   */

  export type AggregateAuditAssignment = {
    _count: AuditAssignmentCountAggregateOutputType | null
    _min: AuditAssignmentMinAggregateOutputType | null
    _max: AuditAssignmentMaxAggregateOutputType | null
  }

  export type AuditAssignmentMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    userId: string | null
    assignedZones: string | null
    assignedAisles: string | null
    assignedShelves: string | null
    assignedBins: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditAssignmentMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    userId: string | null
    assignedZones: string | null
    assignedAisles: string | null
    assignedShelves: string | null
    assignedBins: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditAssignmentCountAggregateOutputType = {
    id: number
    auditId: number
    userId: number
    assignedZones: number
    assignedAisles: number
    assignedShelves: number
    assignedBins: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditAssignmentMinAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    assignedZones?: true
    assignedAisles?: true
    assignedShelves?: true
    assignedBins?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditAssignmentMaxAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    assignedZones?: true
    assignedAisles?: true
    assignedShelves?: true
    assignedBins?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditAssignmentCountAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    assignedZones?: true
    assignedAisles?: true
    assignedShelves?: true
    assignedBins?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditAssignment to aggregate.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditAssignments
    **/
    _count?: true | AuditAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditAssignmentMaxAggregateInputType
  }

  export type GetAuditAssignmentAggregateType<T extends AuditAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditAssignment[P]>
      : GetScalarType<T[P], AggregateAuditAssignment[P]>
  }




  export type AuditAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAssignmentWhereInput
    orderBy?: AuditAssignmentOrderByWithAggregationInput | AuditAssignmentOrderByWithAggregationInput[]
    by: AuditAssignmentScalarFieldEnum[] | AuditAssignmentScalarFieldEnum
    having?: AuditAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditAssignmentCountAggregateInputType | true
    _min?: AuditAssignmentMinAggregateInputType
    _max?: AuditAssignmentMaxAggregateInputType
  }

  export type AuditAssignmentGroupByOutputType = {
    id: string
    auditId: string
    userId: string
    assignedZones: string | null
    assignedAisles: string | null
    assignedShelves: string | null
    assignedBins: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuditAssignmentCountAggregateOutputType | null
    _min: AuditAssignmentMinAggregateOutputType | null
    _max: AuditAssignmentMaxAggregateOutputType | null
  }

  type GetAuditAssignmentGroupByPayload<T extends AuditAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AuditAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AuditAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    assignedAisles?: boolean
    assignedShelves?: boolean
    assignedBins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAssignment"]>

  export type AuditAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    assignedAisles?: boolean
    assignedShelves?: boolean
    assignedBins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAssignment"]>

  export type AuditAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    assignedAisles?: boolean
    assignedShelves?: boolean
    assignedBins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAssignment"]>

  export type AuditAssignmentSelectScalar = {
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    assignedAisles?: boolean
    assignedShelves?: boolean
    assignedBins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "userId" | "assignedZones" | "assignedAisles" | "assignedShelves" | "assignedBins" | "createdAt" | "updatedAt", ExtArgs["result"]["auditAssignment"]>
  export type AuditAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditAssignment"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      userId: string
      assignedZones: string | null
      assignedAisles: string | null
      assignedShelves: string | null
      assignedBins: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditAssignment"]>
    composites: {}
  }

  type AuditAssignmentGetPayload<S extends boolean | null | undefined | AuditAssignmentDefaultArgs> = $Result.GetResult<Prisma.$AuditAssignmentPayload, S>

  type AuditAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditAssignmentCountAggregateInputType | true
    }

  export interface AuditAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditAssignment'], meta: { name: 'AuditAssignment' } }
    /**
     * Find zero or one AuditAssignment that matches the filter.
     * @param {AuditAssignmentFindUniqueArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditAssignmentFindUniqueArgs>(args: SelectSubset<T, AuditAssignmentFindUniqueArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditAssignmentFindUniqueOrThrowArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentFindFirstArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditAssignmentFindFirstArgs>(args?: SelectSubset<T, AuditAssignmentFindFirstArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentFindFirstOrThrowArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditAssignments
     * const auditAssignments = await prisma.auditAssignment.findMany()
     * 
     * // Get first 10 AuditAssignments
     * const auditAssignments = await prisma.auditAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditAssignmentWithIdOnly = await prisma.auditAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditAssignmentFindManyArgs>(args?: SelectSubset<T, AuditAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditAssignment.
     * @param {AuditAssignmentCreateArgs} args - Arguments to create a AuditAssignment.
     * @example
     * // Create one AuditAssignment
     * const AuditAssignment = await prisma.auditAssignment.create({
     *   data: {
     *     // ... data to create a AuditAssignment
     *   }
     * })
     * 
     */
    create<T extends AuditAssignmentCreateArgs>(args: SelectSubset<T, AuditAssignmentCreateArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditAssignments.
     * @param {AuditAssignmentCreateManyArgs} args - Arguments to create many AuditAssignments.
     * @example
     * // Create many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditAssignmentCreateManyArgs>(args?: SelectSubset<T, AuditAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditAssignments and returns the data saved in the database.
     * @param {AuditAssignmentCreateManyAndReturnArgs} args - Arguments to create many AuditAssignments.
     * @example
     * // Create many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditAssignments and only return the `id`
     * const auditAssignmentWithIdOnly = await prisma.auditAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditAssignment.
     * @param {AuditAssignmentDeleteArgs} args - Arguments to delete one AuditAssignment.
     * @example
     * // Delete one AuditAssignment
     * const AuditAssignment = await prisma.auditAssignment.delete({
     *   where: {
     *     // ... filter to delete one AuditAssignment
     *   }
     * })
     * 
     */
    delete<T extends AuditAssignmentDeleteArgs>(args: SelectSubset<T, AuditAssignmentDeleteArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditAssignment.
     * @param {AuditAssignmentUpdateArgs} args - Arguments to update one AuditAssignment.
     * @example
     * // Update one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditAssignmentUpdateArgs>(args: SelectSubset<T, AuditAssignmentUpdateArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditAssignments.
     * @param {AuditAssignmentDeleteManyArgs} args - Arguments to filter AuditAssignments to delete.
     * @example
     * // Delete a few AuditAssignments
     * const { count } = await prisma.auditAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditAssignmentDeleteManyArgs>(args?: SelectSubset<T, AuditAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditAssignmentUpdateManyArgs>(args: SelectSubset<T, AuditAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditAssignments and returns the data updated in the database.
     * @param {AuditAssignmentUpdateManyAndReturnArgs} args - Arguments to update many AuditAssignments.
     * @example
     * // Update many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditAssignments and only return the `id`
     * const auditAssignmentWithIdOnly = await prisma.auditAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditAssignment.
     * @param {AuditAssignmentUpsertArgs} args - Arguments to update or create a AuditAssignment.
     * @example
     * // Update or create a AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.upsert({
     *   create: {
     *     // ... data to create a AuditAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditAssignment we want to update
     *   }
     * })
     */
    upsert<T extends AuditAssignmentUpsertArgs>(args: SelectSubset<T, AuditAssignmentUpsertArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentCountArgs} args - Arguments to filter AuditAssignments to count.
     * @example
     * // Count the number of AuditAssignments
     * const count = await prisma.auditAssignment.count({
     *   where: {
     *     // ... the filter for the AuditAssignments we want to count
     *   }
     * })
    **/
    count<T extends AuditAssignmentCountArgs>(
      args?: Subset<T, AuditAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAssignmentAggregateArgs>(args: Subset<T, AuditAssignmentAggregateArgs>): Prisma.PrismaPromise<GetAuditAssignmentAggregateType<T>>

    /**
     * Group by AuditAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AuditAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditAssignment model
   */
  readonly fields: AuditAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditAssignment model
   */
  interface AuditAssignmentFieldRefs {
    readonly id: FieldRef<"AuditAssignment", 'String'>
    readonly auditId: FieldRef<"AuditAssignment", 'String'>
    readonly userId: FieldRef<"AuditAssignment", 'String'>
    readonly assignedZones: FieldRef<"AuditAssignment", 'String'>
    readonly assignedAisles: FieldRef<"AuditAssignment", 'String'>
    readonly assignedShelves: FieldRef<"AuditAssignment", 'String'>
    readonly assignedBins: FieldRef<"AuditAssignment", 'String'>
    readonly createdAt: FieldRef<"AuditAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditAssignment findUnique
   */
  export type AuditAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment findUniqueOrThrow
   */
  export type AuditAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment findFirst
   */
  export type AuditAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditAssignments.
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditAssignments.
     */
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * AuditAssignment findFirstOrThrow
   */
  export type AuditAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditAssignments.
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditAssignments.
     */
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * AuditAssignment findMany
   */
  export type AuditAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignments to fetch.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditAssignments.
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * AuditAssignment create
   */
  export type AuditAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditAssignment.
     */
    data: XOR<AuditAssignmentCreateInput, AuditAssignmentUncheckedCreateInput>
  }

  /**
   * AuditAssignment createMany
   */
  export type AuditAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditAssignments.
     */
    data: AuditAssignmentCreateManyInput | AuditAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditAssignment createManyAndReturn
   */
  export type AuditAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many AuditAssignments.
     */
    data: AuditAssignmentCreateManyInput | AuditAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditAssignment update
   */
  export type AuditAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditAssignment.
     */
    data: XOR<AuditAssignmentUpdateInput, AuditAssignmentUncheckedUpdateInput>
    /**
     * Choose, which AuditAssignment to update.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment updateMany
   */
  export type AuditAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditAssignments.
     */
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AuditAssignments to update
     */
    where?: AuditAssignmentWhereInput
    /**
     * Limit how many AuditAssignments to update.
     */
    limit?: number
  }

  /**
   * AuditAssignment updateManyAndReturn
   */
  export type AuditAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update AuditAssignments.
     */
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AuditAssignments to update
     */
    where?: AuditAssignmentWhereInput
    /**
     * Limit how many AuditAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditAssignment upsert
   */
  export type AuditAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditAssignment to update in case it exists.
     */
    where: AuditAssignmentWhereUniqueInput
    /**
     * In case the AuditAssignment found by the `where` argument doesn't exist, create a new AuditAssignment with this data.
     */
    create: XOR<AuditAssignmentCreateInput, AuditAssignmentUncheckedCreateInput>
    /**
     * In case the AuditAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditAssignmentUpdateInput, AuditAssignmentUncheckedUpdateInput>
  }

  /**
   * AuditAssignment delete
   */
  export type AuditAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter which AuditAssignment to delete.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment deleteMany
   */
  export type AuditAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditAssignments to delete
     */
    where?: AuditAssignmentWhereInput
    /**
     * Limit how many AuditAssignments to delete.
     */
    limit?: number
  }

  /**
   * AuditAssignment without action
   */
  export type AuditAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model CustomerGroup
   */

  export type AggregateCustomerGroup = {
    _count: CustomerGroupCountAggregateOutputType | null
    _min: CustomerGroupMinAggregateOutputType | null
    _max: CustomerGroupMaxAggregateOutputType | null
  }

  export type CustomerGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroup to aggregate.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerGroups
    **/
    _count?: true | CustomerGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerGroupMaxAggregateInputType
  }

  export type GetCustomerGroupAggregateType<T extends CustomerGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerGroup[P]>
      : GetScalarType<T[P], AggregateCustomerGroup[P]>
  }




  export type CustomerGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupWhereInput
    orderBy?: CustomerGroupOrderByWithAggregationInput | CustomerGroupOrderByWithAggregationInput[]
    by: CustomerGroupScalarFieldEnum[] | CustomerGroupScalarFieldEnum
    having?: CustomerGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerGroupCountAggregateInputType | true
    _min?: CustomerGroupMinAggregateInputType
    _max?: CustomerGroupMaxAggregateInputType
  }

  export type CustomerGroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerGroupCountAggregateOutputType | null
    _min: CustomerGroupMinAggregateOutputType | null
    _max: CustomerGroupMaxAggregateOutputType | null
  }

  type GetCustomerGroupGroupByPayload<T extends CustomerGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupGroupByOutputType[P]>
        }
      >
    >


  export type CustomerGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CustomerToGroup?: boolean | CustomerGroup$CustomerToGroupArgs<ExtArgs>
    _count?: boolean | CustomerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["customerGroup"]>
  export type CustomerGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerToGroup?: boolean | CustomerGroup$CustomerToGroupArgs<ExtArgs>
    _count?: boolean | CustomerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerGroup"
    objects: {
      CustomerToGroup: Prisma.$CustomerToGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerGroup"]>
    composites: {}
  }

  type CustomerGroupGetPayload<S extends boolean | null | undefined | CustomerGroupDefaultArgs> = $Result.GetResult<Prisma.$CustomerGroupPayload, S>

  type CustomerGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerGroupCountAggregateInputType | true
    }

  export interface CustomerGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerGroup'], meta: { name: 'CustomerGroup' } }
    /**
     * Find zero or one CustomerGroup that matches the filter.
     * @param {CustomerGroupFindUniqueArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerGroupFindUniqueArgs>(args: SelectSubset<T, CustomerGroupFindUniqueArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerGroupFindUniqueOrThrowArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindFirstArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerGroupFindFirstArgs>(args?: SelectSubset<T, CustomerGroupFindFirstArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindFirstOrThrowArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerGroups
     * const customerGroups = await prisma.customerGroup.findMany()
     * 
     * // Get first 10 CustomerGroups
     * const customerGroups = await prisma.customerGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerGroupFindManyArgs>(args?: SelectSubset<T, CustomerGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerGroup.
     * @param {CustomerGroupCreateArgs} args - Arguments to create a CustomerGroup.
     * @example
     * // Create one CustomerGroup
     * const CustomerGroup = await prisma.customerGroup.create({
     *   data: {
     *     // ... data to create a CustomerGroup
     *   }
     * })
     * 
     */
    create<T extends CustomerGroupCreateArgs>(args: SelectSubset<T, CustomerGroupCreateArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerGroups.
     * @param {CustomerGroupCreateManyArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroup = await prisma.customerGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerGroupCreateManyArgs>(args?: SelectSubset<T, CustomerGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerGroups and returns the data saved in the database.
     * @param {CustomerGroupCreateManyAndReturnArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroup = await prisma.customerGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerGroups and only return the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerGroup.
     * @param {CustomerGroupDeleteArgs} args - Arguments to delete one CustomerGroup.
     * @example
     * // Delete one CustomerGroup
     * const CustomerGroup = await prisma.customerGroup.delete({
     *   where: {
     *     // ... filter to delete one CustomerGroup
     *   }
     * })
     * 
     */
    delete<T extends CustomerGroupDeleteArgs>(args: SelectSubset<T, CustomerGroupDeleteArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerGroup.
     * @param {CustomerGroupUpdateArgs} args - Arguments to update one CustomerGroup.
     * @example
     * // Update one CustomerGroup
     * const customerGroup = await prisma.customerGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerGroupUpdateArgs>(args: SelectSubset<T, CustomerGroupUpdateArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerGroups.
     * @param {CustomerGroupDeleteManyArgs} args - Arguments to filter CustomerGroups to delete.
     * @example
     * // Delete a few CustomerGroups
     * const { count } = await prisma.customerGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerGroupDeleteManyArgs>(args?: SelectSubset<T, CustomerGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerGroups
     * const customerGroup = await prisma.customerGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerGroupUpdateManyArgs>(args: SelectSubset<T, CustomerGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups and returns the data updated in the database.
     * @param {CustomerGroupUpdateManyAndReturnArgs} args - Arguments to update many CustomerGroups.
     * @example
     * // Update many CustomerGroups
     * const customerGroup = await prisma.customerGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerGroups and only return the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerGroup.
     * @param {CustomerGroupUpsertArgs} args - Arguments to update or create a CustomerGroup.
     * @example
     * // Update or create a CustomerGroup
     * const customerGroup = await prisma.customerGroup.upsert({
     *   create: {
     *     // ... data to create a CustomerGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerGroup we want to update
     *   }
     * })
     */
    upsert<T extends CustomerGroupUpsertArgs>(args: SelectSubset<T, CustomerGroupUpsertArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupCountArgs} args - Arguments to filter CustomerGroups to count.
     * @example
     * // Count the number of CustomerGroups
     * const count = await prisma.customerGroup.count({
     *   where: {
     *     // ... the filter for the CustomerGroups we want to count
     *   }
     * })
    **/
    count<T extends CustomerGroupCountArgs>(
      args?: Subset<T, CustomerGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerGroupAggregateArgs>(args: Subset<T, CustomerGroupAggregateArgs>): Prisma.PrismaPromise<GetCustomerGroupAggregateType<T>>

    /**
     * Group by CustomerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerGroup model
   */
  readonly fields: CustomerGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CustomerToGroup<T extends CustomerGroup$CustomerToGroupArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroup$CustomerToGroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerGroup model
   */
  interface CustomerGroupFieldRefs {
    readonly id: FieldRef<"CustomerGroup", 'String'>
    readonly name: FieldRef<"CustomerGroup", 'String'>
    readonly description: FieldRef<"CustomerGroup", 'String'>
    readonly createdAt: FieldRef<"CustomerGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerGroup findUnique
   */
  export type CustomerGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup findUniqueOrThrow
   */
  export type CustomerGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup findFirst
   */
  export type CustomerGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup findFirstOrThrow
   */
  export type CustomerGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup findMany
   */
  export type CustomerGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup create
   */
  export type CustomerGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerGroup.
     */
    data: XOR<CustomerGroupCreateInput, CustomerGroupUncheckedCreateInput>
  }

  /**
   * CustomerGroup createMany
   */
  export type CustomerGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupCreateManyInput | CustomerGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerGroup createManyAndReturn
   */
  export type CustomerGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupCreateManyInput | CustomerGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerGroup update
   */
  export type CustomerGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerGroup.
     */
    data: XOR<CustomerGroupUpdateInput, CustomerGroupUncheckedUpdateInput>
    /**
     * Choose, which CustomerGroup to update.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup updateMany
   */
  export type CustomerGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupUpdateManyMutationInput, CustomerGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroup updateManyAndReturn
   */
  export type CustomerGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupUpdateManyMutationInput, CustomerGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroup upsert
   */
  export type CustomerGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerGroup to update in case it exists.
     */
    where: CustomerGroupWhereUniqueInput
    /**
     * In case the CustomerGroup found by the `where` argument doesn't exist, create a new CustomerGroup with this data.
     */
    create: XOR<CustomerGroupCreateInput, CustomerGroupUncheckedCreateInput>
    /**
     * In case the CustomerGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerGroupUpdateInput, CustomerGroupUncheckedUpdateInput>
  }

  /**
   * CustomerGroup delete
   */
  export type CustomerGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter which CustomerGroup to delete.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup deleteMany
   */
  export type CustomerGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroups to delete
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to delete.
     */
    limit?: number
  }

  /**
   * CustomerGroup.CustomerToGroup
   */
  export type CustomerGroup$CustomerToGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    where?: CustomerToGroupWhereInput
    orderBy?: CustomerToGroupOrderByWithRelationInput | CustomerToGroupOrderByWithRelationInput[]
    cursor?: CustomerToGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerToGroupScalarFieldEnum | CustomerToGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup without action
   */
  export type CustomerGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
  }


  /**
   * Model CustomerNote
   */

  export type AggregateCustomerNote = {
    _count: CustomerNoteCountAggregateOutputType | null
    _min: CustomerNoteMinAggregateOutputType | null
    _max: CustomerNoteMaxAggregateOutputType | null
  }

  export type CustomerNoteMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    note: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerNoteMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    note: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerNoteCountAggregateOutputType = {
    id: number
    customerId: number
    note: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerNoteMinAggregateInputType = {
    id?: true
    customerId?: true
    note?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerNoteMaxAggregateInputType = {
    id?: true
    customerId?: true
    note?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerNoteCountAggregateInputType = {
    id?: true
    customerId?: true
    note?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerNote to aggregate.
     */
    where?: CustomerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotes to fetch.
     */
    orderBy?: CustomerNoteOrderByWithRelationInput | CustomerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerNotes
    **/
    _count?: true | CustomerNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerNoteMaxAggregateInputType
  }

  export type GetCustomerNoteAggregateType<T extends CustomerNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerNote[P]>
      : GetScalarType<T[P], AggregateCustomerNote[P]>
  }




  export type CustomerNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerNoteWhereInput
    orderBy?: CustomerNoteOrderByWithAggregationInput | CustomerNoteOrderByWithAggregationInput[]
    by: CustomerNoteScalarFieldEnum[] | CustomerNoteScalarFieldEnum
    having?: CustomerNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerNoteCountAggregateInputType | true
    _min?: CustomerNoteMinAggregateInputType
    _max?: CustomerNoteMaxAggregateInputType
  }

  export type CustomerNoteGroupByOutputType = {
    id: string
    customerId: string
    note: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerNoteCountAggregateOutputType | null
    _min: CustomerNoteMinAggregateOutputType | null
    _max: CustomerNoteMaxAggregateOutputType | null
  }

  type GetCustomerNoteGroupByPayload<T extends CustomerNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerNoteGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerNoteGroupByOutputType[P]>
        }
      >
    >


  export type CustomerNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    note?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerNote"]>

  export type CustomerNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    note?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerNote"]>

  export type CustomerNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    note?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerNote"]>

  export type CustomerNoteSelectScalar = {
    id?: boolean
    customerId?: boolean
    note?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "note" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["customerNote"]>
  export type CustomerNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomerNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CustomerNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomerNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerNote"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      note: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerNote"]>
    composites: {}
  }

  type CustomerNoteGetPayload<S extends boolean | null | undefined | CustomerNoteDefaultArgs> = $Result.GetResult<Prisma.$CustomerNotePayload, S>

  type CustomerNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerNoteCountAggregateInputType | true
    }

  export interface CustomerNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerNote'], meta: { name: 'CustomerNote' } }
    /**
     * Find zero or one CustomerNote that matches the filter.
     * @param {CustomerNoteFindUniqueArgs} args - Arguments to find a CustomerNote
     * @example
     * // Get one CustomerNote
     * const customerNote = await prisma.customerNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerNoteFindUniqueArgs>(args: SelectSubset<T, CustomerNoteFindUniqueArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerNoteFindUniqueOrThrowArgs} args - Arguments to find a CustomerNote
     * @example
     * // Get one CustomerNote
     * const customerNote = await prisma.customerNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteFindFirstArgs} args - Arguments to find a CustomerNote
     * @example
     * // Get one CustomerNote
     * const customerNote = await prisma.customerNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerNoteFindFirstArgs>(args?: SelectSubset<T, CustomerNoteFindFirstArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteFindFirstOrThrowArgs} args - Arguments to find a CustomerNote
     * @example
     * // Get one CustomerNote
     * const customerNote = await prisma.customerNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerNotes
     * const customerNotes = await prisma.customerNote.findMany()
     * 
     * // Get first 10 CustomerNotes
     * const customerNotes = await prisma.customerNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerNoteWithIdOnly = await prisma.customerNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerNoteFindManyArgs>(args?: SelectSubset<T, CustomerNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerNote.
     * @param {CustomerNoteCreateArgs} args - Arguments to create a CustomerNote.
     * @example
     * // Create one CustomerNote
     * const CustomerNote = await prisma.customerNote.create({
     *   data: {
     *     // ... data to create a CustomerNote
     *   }
     * })
     * 
     */
    create<T extends CustomerNoteCreateArgs>(args: SelectSubset<T, CustomerNoteCreateArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerNotes.
     * @param {CustomerNoteCreateManyArgs} args - Arguments to create many CustomerNotes.
     * @example
     * // Create many CustomerNotes
     * const customerNote = await prisma.customerNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerNoteCreateManyArgs>(args?: SelectSubset<T, CustomerNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerNotes and returns the data saved in the database.
     * @param {CustomerNoteCreateManyAndReturnArgs} args - Arguments to create many CustomerNotes.
     * @example
     * // Create many CustomerNotes
     * const customerNote = await prisma.customerNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerNotes and only return the `id`
     * const customerNoteWithIdOnly = await prisma.customerNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerNote.
     * @param {CustomerNoteDeleteArgs} args - Arguments to delete one CustomerNote.
     * @example
     * // Delete one CustomerNote
     * const CustomerNote = await prisma.customerNote.delete({
     *   where: {
     *     // ... filter to delete one CustomerNote
     *   }
     * })
     * 
     */
    delete<T extends CustomerNoteDeleteArgs>(args: SelectSubset<T, CustomerNoteDeleteArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerNote.
     * @param {CustomerNoteUpdateArgs} args - Arguments to update one CustomerNote.
     * @example
     * // Update one CustomerNote
     * const customerNote = await prisma.customerNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerNoteUpdateArgs>(args: SelectSubset<T, CustomerNoteUpdateArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerNotes.
     * @param {CustomerNoteDeleteManyArgs} args - Arguments to filter CustomerNotes to delete.
     * @example
     * // Delete a few CustomerNotes
     * const { count } = await prisma.customerNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerNoteDeleteManyArgs>(args?: SelectSubset<T, CustomerNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerNotes
     * const customerNote = await prisma.customerNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerNoteUpdateManyArgs>(args: SelectSubset<T, CustomerNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerNotes and returns the data updated in the database.
     * @param {CustomerNoteUpdateManyAndReturnArgs} args - Arguments to update many CustomerNotes.
     * @example
     * // Update many CustomerNotes
     * const customerNote = await prisma.customerNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerNotes and only return the `id`
     * const customerNoteWithIdOnly = await prisma.customerNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerNote.
     * @param {CustomerNoteUpsertArgs} args - Arguments to update or create a CustomerNote.
     * @example
     * // Update or create a CustomerNote
     * const customerNote = await prisma.customerNote.upsert({
     *   create: {
     *     // ... data to create a CustomerNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerNote we want to update
     *   }
     * })
     */
    upsert<T extends CustomerNoteUpsertArgs>(args: SelectSubset<T, CustomerNoteUpsertArgs<ExtArgs>>): Prisma__CustomerNoteClient<$Result.GetResult<Prisma.$CustomerNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteCountArgs} args - Arguments to filter CustomerNotes to count.
     * @example
     * // Count the number of CustomerNotes
     * const count = await prisma.customerNote.count({
     *   where: {
     *     // ... the filter for the CustomerNotes we want to count
     *   }
     * })
    **/
    count<T extends CustomerNoteCountArgs>(
      args?: Subset<T, CustomerNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerNoteAggregateArgs>(args: Subset<T, CustomerNoteAggregateArgs>): Prisma.PrismaPromise<GetCustomerNoteAggregateType<T>>

    /**
     * Group by CustomerNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerNoteGroupByArgs['orderBy'] }
        : { orderBy?: CustomerNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerNote model
   */
  readonly fields: CustomerNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerNote model
   */
  interface CustomerNoteFieldRefs {
    readonly id: FieldRef<"CustomerNote", 'String'>
    readonly customerId: FieldRef<"CustomerNote", 'String'>
    readonly note: FieldRef<"CustomerNote", 'String'>
    readonly createdById: FieldRef<"CustomerNote", 'String'>
    readonly createdAt: FieldRef<"CustomerNote", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerNote findUnique
   */
  export type CustomerNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNote to fetch.
     */
    where: CustomerNoteWhereUniqueInput
  }

  /**
   * CustomerNote findUniqueOrThrow
   */
  export type CustomerNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNote to fetch.
     */
    where: CustomerNoteWhereUniqueInput
  }

  /**
   * CustomerNote findFirst
   */
  export type CustomerNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNote to fetch.
     */
    where?: CustomerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotes to fetch.
     */
    orderBy?: CustomerNoteOrderByWithRelationInput | CustomerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerNotes.
     */
    cursor?: CustomerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerNotes.
     */
    distinct?: CustomerNoteScalarFieldEnum | CustomerNoteScalarFieldEnum[]
  }

  /**
   * CustomerNote findFirstOrThrow
   */
  export type CustomerNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNote to fetch.
     */
    where?: CustomerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotes to fetch.
     */
    orderBy?: CustomerNoteOrderByWithRelationInput | CustomerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerNotes.
     */
    cursor?: CustomerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerNotes.
     */
    distinct?: CustomerNoteScalarFieldEnum | CustomerNoteScalarFieldEnum[]
  }

  /**
   * CustomerNote findMany
   */
  export type CustomerNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * Filter, which CustomerNotes to fetch.
     */
    where?: CustomerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNotes to fetch.
     */
    orderBy?: CustomerNoteOrderByWithRelationInput | CustomerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerNotes.
     */
    cursor?: CustomerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNotes.
     */
    skip?: number
    distinct?: CustomerNoteScalarFieldEnum | CustomerNoteScalarFieldEnum[]
  }

  /**
   * CustomerNote create
   */
  export type CustomerNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerNote.
     */
    data: XOR<CustomerNoteCreateInput, CustomerNoteUncheckedCreateInput>
  }

  /**
   * CustomerNote createMany
   */
  export type CustomerNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerNotes.
     */
    data: CustomerNoteCreateManyInput | CustomerNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerNote createManyAndReturn
   */
  export type CustomerNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerNotes.
     */
    data: CustomerNoteCreateManyInput | CustomerNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerNote update
   */
  export type CustomerNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerNote.
     */
    data: XOR<CustomerNoteUpdateInput, CustomerNoteUncheckedUpdateInput>
    /**
     * Choose, which CustomerNote to update.
     */
    where: CustomerNoteWhereUniqueInput
  }

  /**
   * CustomerNote updateMany
   */
  export type CustomerNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerNotes.
     */
    data: XOR<CustomerNoteUpdateManyMutationInput, CustomerNoteUncheckedUpdateManyInput>
    /**
     * Filter which CustomerNotes to update
     */
    where?: CustomerNoteWhereInput
    /**
     * Limit how many CustomerNotes to update.
     */
    limit?: number
  }

  /**
   * CustomerNote updateManyAndReturn
   */
  export type CustomerNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * The data used to update CustomerNotes.
     */
    data: XOR<CustomerNoteUpdateManyMutationInput, CustomerNoteUncheckedUpdateManyInput>
    /**
     * Filter which CustomerNotes to update
     */
    where?: CustomerNoteWhereInput
    /**
     * Limit how many CustomerNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerNote upsert
   */
  export type CustomerNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerNote to update in case it exists.
     */
    where: CustomerNoteWhereUniqueInput
    /**
     * In case the CustomerNote found by the `where` argument doesn't exist, create a new CustomerNote with this data.
     */
    create: XOR<CustomerNoteCreateInput, CustomerNoteUncheckedCreateInput>
    /**
     * In case the CustomerNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerNoteUpdateInput, CustomerNoteUncheckedUpdateInput>
  }

  /**
   * CustomerNote delete
   */
  export type CustomerNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
    /**
     * Filter which CustomerNote to delete.
     */
    where: CustomerNoteWhereUniqueInput
  }

  /**
   * CustomerNote deleteMany
   */
  export type CustomerNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerNotes to delete
     */
    where?: CustomerNoteWhereInput
    /**
     * Limit how many CustomerNotes to delete.
     */
    limit?: number
  }

  /**
   * CustomerNote without action
   */
  export type CustomerNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerNote
     */
    select?: CustomerNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerNote
     */
    omit?: CustomerNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerNoteInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPromotion
   */

  export type AggregateCustomerPromotion = {
    _count: CustomerPromotionCountAggregateOutputType | null
    _avg: CustomerPromotionAvgAggregateOutputType | null
    _sum: CustomerPromotionSumAggregateOutputType | null
    _min: CustomerPromotionMinAggregateOutputType | null
    _max: CustomerPromotionMaxAggregateOutputType | null
  }

  export type CustomerPromotionAvgAggregateOutputType = {
    discountValue: Decimal | null
    minimumPurchase: Decimal | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type CustomerPromotionSumAggregateOutputType = {
    discountValue: Decimal | null
    minimumPurchase: Decimal | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type CustomerPromotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.PromotionType | null
    discountValue: Decimal | null
    isPercentage: boolean | null
    code: string | null
    minimumPurchase: Decimal | null
    programId: string | null
    requiredLoyaltyTier: $Enums.LoyaltyTier | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    usageLimit: number | null
    usageCount: number | null
    applicableProducts: string | null
    applicableCategories: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPromotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.PromotionType | null
    discountValue: Decimal | null
    isPercentage: boolean | null
    code: string | null
    minimumPurchase: Decimal | null
    programId: string | null
    requiredLoyaltyTier: $Enums.LoyaltyTier | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    usageLimit: number | null
    usageCount: number | null
    applicableProducts: string | null
    applicableCategories: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPromotionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    discountValue: number
    isPercentage: number
    code: number
    minimumPurchase: number
    programId: number
    requiredLoyaltyTier: number
    startDate: number
    endDate: number
    isActive: number
    usageLimit: number
    usageCount: number
    applicableProducts: number
    applicableCategories: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerPromotionAvgAggregateInputType = {
    discountValue?: true
    minimumPurchase?: true
    usageLimit?: true
    usageCount?: true
  }

  export type CustomerPromotionSumAggregateInputType = {
    discountValue?: true
    minimumPurchase?: true
    usageLimit?: true
    usageCount?: true
  }

  export type CustomerPromotionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    discountValue?: true
    isPercentage?: true
    code?: true
    minimumPurchase?: true
    programId?: true
    requiredLoyaltyTier?: true
    startDate?: true
    endDate?: true
    isActive?: true
    usageLimit?: true
    usageCount?: true
    applicableProducts?: true
    applicableCategories?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPromotionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    discountValue?: true
    isPercentage?: true
    code?: true
    minimumPurchase?: true
    programId?: true
    requiredLoyaltyTier?: true
    startDate?: true
    endDate?: true
    isActive?: true
    usageLimit?: true
    usageCount?: true
    applicableProducts?: true
    applicableCategories?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPromotionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    discountValue?: true
    isPercentage?: true
    code?: true
    minimumPurchase?: true
    programId?: true
    requiredLoyaltyTier?: true
    startDate?: true
    endDate?: true
    isActive?: true
    usageLimit?: true
    usageCount?: true
    applicableProducts?: true
    applicableCategories?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerPromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPromotion to aggregate.
     */
    where?: CustomerPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPromotions to fetch.
     */
    orderBy?: CustomerPromotionOrderByWithRelationInput | CustomerPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPromotions
    **/
    _count?: true | CustomerPromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPromotionMaxAggregateInputType
  }

  export type GetCustomerPromotionAggregateType<T extends CustomerPromotionAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPromotion[P]>
      : GetScalarType<T[P], AggregateCustomerPromotion[P]>
  }




  export type CustomerPromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPromotionWhereInput
    orderBy?: CustomerPromotionOrderByWithAggregationInput | CustomerPromotionOrderByWithAggregationInput[]
    by: CustomerPromotionScalarFieldEnum[] | CustomerPromotionScalarFieldEnum
    having?: CustomerPromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPromotionCountAggregateInputType | true
    _avg?: CustomerPromotionAvgAggregateInputType
    _sum?: CustomerPromotionSumAggregateInputType
    _min?: CustomerPromotionMinAggregateInputType
    _max?: CustomerPromotionMaxAggregateInputType
  }

  export type CustomerPromotionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.PromotionType
    discountValue: Decimal
    isPercentage: boolean
    code: string | null
    minimumPurchase: Decimal | null
    programId: string | null
    requiredLoyaltyTier: $Enums.LoyaltyTier | null
    startDate: Date
    endDate: Date
    isActive: boolean
    usageLimit: number | null
    usageCount: number
    applicableProducts: string | null
    applicableCategories: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerPromotionCountAggregateOutputType | null
    _avg: CustomerPromotionAvgAggregateOutputType | null
    _sum: CustomerPromotionSumAggregateOutputType | null
    _min: CustomerPromotionMinAggregateOutputType | null
    _max: CustomerPromotionMaxAggregateOutputType | null
  }

  type GetCustomerPromotionGroupByPayload<T extends CustomerPromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPromotionGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPromotionGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    isPercentage?: boolean
    code?: boolean
    minimumPurchase?: boolean
    programId?: boolean
    requiredLoyaltyTier?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    applicableProducts?: boolean
    applicableCategories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyProgram?: boolean | CustomerPromotion$LoyaltyProgramArgs<ExtArgs>
    PromotionRedemption?: boolean | CustomerPromotion$PromotionRedemptionArgs<ExtArgs>
    _count?: boolean | CustomerPromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPromotion"]>

  export type CustomerPromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    isPercentage?: boolean
    code?: boolean
    minimumPurchase?: boolean
    programId?: boolean
    requiredLoyaltyTier?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    applicableProducts?: boolean
    applicableCategories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyProgram?: boolean | CustomerPromotion$LoyaltyProgramArgs<ExtArgs>
  }, ExtArgs["result"]["customerPromotion"]>

  export type CustomerPromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    isPercentage?: boolean
    code?: boolean
    minimumPurchase?: boolean
    programId?: boolean
    requiredLoyaltyTier?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    applicableProducts?: boolean
    applicableCategories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyProgram?: boolean | CustomerPromotion$LoyaltyProgramArgs<ExtArgs>
  }, ExtArgs["result"]["customerPromotion"]>

  export type CustomerPromotionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    isPercentage?: boolean
    code?: boolean
    minimumPurchase?: boolean
    programId?: boolean
    requiredLoyaltyTier?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    applicableProducts?: boolean
    applicableCategories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerPromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "discountValue" | "isPercentage" | "code" | "minimumPurchase" | "programId" | "requiredLoyaltyTier" | "startDate" | "endDate" | "isActive" | "usageLimit" | "usageCount" | "applicableProducts" | "applicableCategories" | "createdAt" | "updatedAt", ExtArgs["result"]["customerPromotion"]>
  export type CustomerPromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyProgram?: boolean | CustomerPromotion$LoyaltyProgramArgs<ExtArgs>
    PromotionRedemption?: boolean | CustomerPromotion$PromotionRedemptionArgs<ExtArgs>
    _count?: boolean | CustomerPromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerPromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyProgram?: boolean | CustomerPromotion$LoyaltyProgramArgs<ExtArgs>
  }
  export type CustomerPromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyProgram?: boolean | CustomerPromotion$LoyaltyProgramArgs<ExtArgs>
  }

  export type $CustomerPromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPromotion"
    objects: {
      LoyaltyProgram: Prisma.$LoyaltyProgramPayload<ExtArgs> | null
      PromotionRedemption: Prisma.$PromotionRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.PromotionType
      discountValue: Prisma.Decimal
      isPercentage: boolean
      code: string | null
      minimumPurchase: Prisma.Decimal | null
      programId: string | null
      requiredLoyaltyTier: $Enums.LoyaltyTier | null
      startDate: Date
      endDate: Date
      isActive: boolean
      usageLimit: number | null
      usageCount: number
      applicableProducts: string | null
      applicableCategories: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerPromotion"]>
    composites: {}
  }

  type CustomerPromotionGetPayload<S extends boolean | null | undefined | CustomerPromotionDefaultArgs> = $Result.GetResult<Prisma.$CustomerPromotionPayload, S>

  type CustomerPromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPromotionCountAggregateInputType | true
    }

  export interface CustomerPromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPromotion'], meta: { name: 'CustomerPromotion' } }
    /**
     * Find zero or one CustomerPromotion that matches the filter.
     * @param {CustomerPromotionFindUniqueArgs} args - Arguments to find a CustomerPromotion
     * @example
     * // Get one CustomerPromotion
     * const customerPromotion = await prisma.customerPromotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPromotionFindUniqueArgs>(args: SelectSubset<T, CustomerPromotionFindUniqueArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPromotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPromotionFindUniqueOrThrowArgs} args - Arguments to find a CustomerPromotion
     * @example
     * // Get one CustomerPromotion
     * const customerPromotion = await prisma.customerPromotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPromotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionFindFirstArgs} args - Arguments to find a CustomerPromotion
     * @example
     * // Get one CustomerPromotion
     * const customerPromotion = await prisma.customerPromotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPromotionFindFirstArgs>(args?: SelectSubset<T, CustomerPromotionFindFirstArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPromotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionFindFirstOrThrowArgs} args - Arguments to find a CustomerPromotion
     * @example
     * // Get one CustomerPromotion
     * const customerPromotion = await prisma.customerPromotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPromotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPromotions
     * const customerPromotions = await prisma.customerPromotion.findMany()
     * 
     * // Get first 10 CustomerPromotions
     * const customerPromotions = await prisma.customerPromotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPromotionWithIdOnly = await prisma.customerPromotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPromotionFindManyArgs>(args?: SelectSubset<T, CustomerPromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPromotion.
     * @param {CustomerPromotionCreateArgs} args - Arguments to create a CustomerPromotion.
     * @example
     * // Create one CustomerPromotion
     * const CustomerPromotion = await prisma.customerPromotion.create({
     *   data: {
     *     // ... data to create a CustomerPromotion
     *   }
     * })
     * 
     */
    create<T extends CustomerPromotionCreateArgs>(args: SelectSubset<T, CustomerPromotionCreateArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPromotions.
     * @param {CustomerPromotionCreateManyArgs} args - Arguments to create many CustomerPromotions.
     * @example
     * // Create many CustomerPromotions
     * const customerPromotion = await prisma.customerPromotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPromotionCreateManyArgs>(args?: SelectSubset<T, CustomerPromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPromotions and returns the data saved in the database.
     * @param {CustomerPromotionCreateManyAndReturnArgs} args - Arguments to create many CustomerPromotions.
     * @example
     * // Create many CustomerPromotions
     * const customerPromotion = await prisma.customerPromotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPromotions and only return the `id`
     * const customerPromotionWithIdOnly = await prisma.customerPromotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPromotion.
     * @param {CustomerPromotionDeleteArgs} args - Arguments to delete one CustomerPromotion.
     * @example
     * // Delete one CustomerPromotion
     * const CustomerPromotion = await prisma.customerPromotion.delete({
     *   where: {
     *     // ... filter to delete one CustomerPromotion
     *   }
     * })
     * 
     */
    delete<T extends CustomerPromotionDeleteArgs>(args: SelectSubset<T, CustomerPromotionDeleteArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPromotion.
     * @param {CustomerPromotionUpdateArgs} args - Arguments to update one CustomerPromotion.
     * @example
     * // Update one CustomerPromotion
     * const customerPromotion = await prisma.customerPromotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPromotionUpdateArgs>(args: SelectSubset<T, CustomerPromotionUpdateArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPromotions.
     * @param {CustomerPromotionDeleteManyArgs} args - Arguments to filter CustomerPromotions to delete.
     * @example
     * // Delete a few CustomerPromotions
     * const { count } = await prisma.customerPromotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPromotionDeleteManyArgs>(args?: SelectSubset<T, CustomerPromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPromotions
     * const customerPromotion = await prisma.customerPromotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPromotionUpdateManyArgs>(args: SelectSubset<T, CustomerPromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPromotions and returns the data updated in the database.
     * @param {CustomerPromotionUpdateManyAndReturnArgs} args - Arguments to update many CustomerPromotions.
     * @example
     * // Update many CustomerPromotions
     * const customerPromotion = await prisma.customerPromotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPromotions and only return the `id`
     * const customerPromotionWithIdOnly = await prisma.customerPromotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPromotion.
     * @param {CustomerPromotionUpsertArgs} args - Arguments to update or create a CustomerPromotion.
     * @example
     * // Update or create a CustomerPromotion
     * const customerPromotion = await prisma.customerPromotion.upsert({
     *   create: {
     *     // ... data to create a CustomerPromotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPromotion we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPromotionUpsertArgs>(args: SelectSubset<T, CustomerPromotionUpsertArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPromotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionCountArgs} args - Arguments to filter CustomerPromotions to count.
     * @example
     * // Count the number of CustomerPromotions
     * const count = await prisma.customerPromotion.count({
     *   where: {
     *     // ... the filter for the CustomerPromotions we want to count
     *   }
     * })
    **/
    count<T extends CustomerPromotionCountArgs>(
      args?: Subset<T, CustomerPromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPromotionAggregateArgs>(args: Subset<T, CustomerPromotionAggregateArgs>): Prisma.PrismaPromise<GetCustomerPromotionAggregateType<T>>

    /**
     * Group by CustomerPromotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPromotionGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPromotion model
   */
  readonly fields: CustomerPromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPromotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    LoyaltyProgram<T extends CustomerPromotion$LoyaltyProgramArgs<ExtArgs> = {}>(args?: Subset<T, CustomerPromotion$LoyaltyProgramArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    PromotionRedemption<T extends CustomerPromotion$PromotionRedemptionArgs<ExtArgs> = {}>(args?: Subset<T, CustomerPromotion$PromotionRedemptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPromotion model
   */
  interface CustomerPromotionFieldRefs {
    readonly id: FieldRef<"CustomerPromotion", 'String'>
    readonly name: FieldRef<"CustomerPromotion", 'String'>
    readonly description: FieldRef<"CustomerPromotion", 'String'>
    readonly type: FieldRef<"CustomerPromotion", 'PromotionType'>
    readonly discountValue: FieldRef<"CustomerPromotion", 'Decimal'>
    readonly isPercentage: FieldRef<"CustomerPromotion", 'Boolean'>
    readonly code: FieldRef<"CustomerPromotion", 'String'>
    readonly minimumPurchase: FieldRef<"CustomerPromotion", 'Decimal'>
    readonly programId: FieldRef<"CustomerPromotion", 'String'>
    readonly requiredLoyaltyTier: FieldRef<"CustomerPromotion", 'LoyaltyTier'>
    readonly startDate: FieldRef<"CustomerPromotion", 'DateTime'>
    readonly endDate: FieldRef<"CustomerPromotion", 'DateTime'>
    readonly isActive: FieldRef<"CustomerPromotion", 'Boolean'>
    readonly usageLimit: FieldRef<"CustomerPromotion", 'Int'>
    readonly usageCount: FieldRef<"CustomerPromotion", 'Int'>
    readonly applicableProducts: FieldRef<"CustomerPromotion", 'String'>
    readonly applicableCategories: FieldRef<"CustomerPromotion", 'String'>
    readonly createdAt: FieldRef<"CustomerPromotion", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerPromotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPromotion findUnique
   */
  export type CustomerPromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPromotion to fetch.
     */
    where: CustomerPromotionWhereUniqueInput
  }

  /**
   * CustomerPromotion findUniqueOrThrow
   */
  export type CustomerPromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPromotion to fetch.
     */
    where: CustomerPromotionWhereUniqueInput
  }

  /**
   * CustomerPromotion findFirst
   */
  export type CustomerPromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPromotion to fetch.
     */
    where?: CustomerPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPromotions to fetch.
     */
    orderBy?: CustomerPromotionOrderByWithRelationInput | CustomerPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPromotions.
     */
    cursor?: CustomerPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPromotions.
     */
    distinct?: CustomerPromotionScalarFieldEnum | CustomerPromotionScalarFieldEnum[]
  }

  /**
   * CustomerPromotion findFirstOrThrow
   */
  export type CustomerPromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPromotion to fetch.
     */
    where?: CustomerPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPromotions to fetch.
     */
    orderBy?: CustomerPromotionOrderByWithRelationInput | CustomerPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPromotions.
     */
    cursor?: CustomerPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPromotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPromotions.
     */
    distinct?: CustomerPromotionScalarFieldEnum | CustomerPromotionScalarFieldEnum[]
  }

  /**
   * CustomerPromotion findMany
   */
  export type CustomerPromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPromotions to fetch.
     */
    where?: CustomerPromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPromotions to fetch.
     */
    orderBy?: CustomerPromotionOrderByWithRelationInput | CustomerPromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPromotions.
     */
    cursor?: CustomerPromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPromotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPromotions.
     */
    skip?: number
    distinct?: CustomerPromotionScalarFieldEnum | CustomerPromotionScalarFieldEnum[]
  }

  /**
   * CustomerPromotion create
   */
  export type CustomerPromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPromotion.
     */
    data: XOR<CustomerPromotionCreateInput, CustomerPromotionUncheckedCreateInput>
  }

  /**
   * CustomerPromotion createMany
   */
  export type CustomerPromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPromotions.
     */
    data: CustomerPromotionCreateManyInput | CustomerPromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPromotion createManyAndReturn
   */
  export type CustomerPromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPromotions.
     */
    data: CustomerPromotionCreateManyInput | CustomerPromotionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPromotion update
   */
  export type CustomerPromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPromotion.
     */
    data: XOR<CustomerPromotionUpdateInput, CustomerPromotionUncheckedUpdateInput>
    /**
     * Choose, which CustomerPromotion to update.
     */
    where: CustomerPromotionWhereUniqueInput
  }

  /**
   * CustomerPromotion updateMany
   */
  export type CustomerPromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPromotions.
     */
    data: XOR<CustomerPromotionUpdateManyMutationInput, CustomerPromotionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPromotions to update
     */
    where?: CustomerPromotionWhereInput
    /**
     * Limit how many CustomerPromotions to update.
     */
    limit?: number
  }

  /**
   * CustomerPromotion updateManyAndReturn
   */
  export type CustomerPromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPromotions.
     */
    data: XOR<CustomerPromotionUpdateManyMutationInput, CustomerPromotionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPromotions to update
     */
    where?: CustomerPromotionWhereInput
    /**
     * Limit how many CustomerPromotions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPromotion upsert
   */
  export type CustomerPromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPromotion to update in case it exists.
     */
    where: CustomerPromotionWhereUniqueInput
    /**
     * In case the CustomerPromotion found by the `where` argument doesn't exist, create a new CustomerPromotion with this data.
     */
    create: XOR<CustomerPromotionCreateInput, CustomerPromotionUncheckedCreateInput>
    /**
     * In case the CustomerPromotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPromotionUpdateInput, CustomerPromotionUncheckedUpdateInput>
  }

  /**
   * CustomerPromotion delete
   */
  export type CustomerPromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
    /**
     * Filter which CustomerPromotion to delete.
     */
    where: CustomerPromotionWhereUniqueInput
  }

  /**
   * CustomerPromotion deleteMany
   */
  export type CustomerPromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPromotions to delete
     */
    where?: CustomerPromotionWhereInput
    /**
     * Limit how many CustomerPromotions to delete.
     */
    limit?: number
  }

  /**
   * CustomerPromotion.LoyaltyProgram
   */
  export type CustomerPromotion$LoyaltyProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    where?: LoyaltyProgramWhereInput
  }

  /**
   * CustomerPromotion.PromotionRedemption
   */
  export type CustomerPromotion$PromotionRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    cursor?: PromotionRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * CustomerPromotion without action
   */
  export type CustomerPromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPromotion
     */
    select?: CustomerPromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPromotion
     */
    omit?: CustomerPromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPromotionInclude<ExtArgs> | null
  }


  /**
   * Model CustomerToGroup
   */

  export type AggregateCustomerToGroup = {
    _count: CustomerToGroupCountAggregateOutputType | null
    _min: CustomerToGroupMinAggregateOutputType | null
    _max: CustomerToGroupMaxAggregateOutputType | null
  }

  export type CustomerToGroupMinAggregateOutputType = {
    customerId: string | null
    groupId: string | null
    createdAt: Date | null
  }

  export type CustomerToGroupMaxAggregateOutputType = {
    customerId: string | null
    groupId: string | null
    createdAt: Date | null
  }

  export type CustomerToGroupCountAggregateOutputType = {
    customerId: number
    groupId: number
    createdAt: number
    _all: number
  }


  export type CustomerToGroupMinAggregateInputType = {
    customerId?: true
    groupId?: true
    createdAt?: true
  }

  export type CustomerToGroupMaxAggregateInputType = {
    customerId?: true
    groupId?: true
    createdAt?: true
  }

  export type CustomerToGroupCountAggregateInputType = {
    customerId?: true
    groupId?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerToGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerToGroup to aggregate.
     */
    where?: CustomerToGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerToGroups to fetch.
     */
    orderBy?: CustomerToGroupOrderByWithRelationInput | CustomerToGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerToGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerToGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerToGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerToGroups
    **/
    _count?: true | CustomerToGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerToGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerToGroupMaxAggregateInputType
  }

  export type GetCustomerToGroupAggregateType<T extends CustomerToGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerToGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerToGroup[P]>
      : GetScalarType<T[P], AggregateCustomerToGroup[P]>
  }




  export type CustomerToGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerToGroupWhereInput
    orderBy?: CustomerToGroupOrderByWithAggregationInput | CustomerToGroupOrderByWithAggregationInput[]
    by: CustomerToGroupScalarFieldEnum[] | CustomerToGroupScalarFieldEnum
    having?: CustomerToGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerToGroupCountAggregateInputType | true
    _min?: CustomerToGroupMinAggregateInputType
    _max?: CustomerToGroupMaxAggregateInputType
  }

  export type CustomerToGroupGroupByOutputType = {
    customerId: string
    groupId: string
    createdAt: Date
    _count: CustomerToGroupCountAggregateOutputType | null
    _min: CustomerToGroupMinAggregateOutputType | null
    _max: CustomerToGroupMaxAggregateOutputType | null
  }

  type GetCustomerToGroupGroupByPayload<T extends CustomerToGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerToGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerToGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerToGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerToGroupGroupByOutputType[P]>
        }
      >
    >


  export type CustomerToGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    groupId?: boolean
    createdAt?: boolean
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerGroup?: boolean | CustomerGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerToGroup"]>

  export type CustomerToGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    groupId?: boolean
    createdAt?: boolean
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerGroup?: boolean | CustomerGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerToGroup"]>

  export type CustomerToGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    groupId?: boolean
    createdAt?: boolean
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerGroup?: boolean | CustomerGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerToGroup"]>

  export type CustomerToGroupSelectScalar = {
    customerId?: boolean
    groupId?: boolean
    createdAt?: boolean
  }

  export type CustomerToGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customerId" | "groupId" | "createdAt", ExtArgs["result"]["customerToGroup"]>
  export type CustomerToGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerGroup?: boolean | CustomerGroupDefaultArgs<ExtArgs>
  }
  export type CustomerToGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerGroup?: boolean | CustomerGroupDefaultArgs<ExtArgs>
  }
  export type CustomerToGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerGroup?: boolean | CustomerGroupDefaultArgs<ExtArgs>
  }

  export type $CustomerToGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerToGroup"
    objects: {
      Customer: Prisma.$CustomerPayload<ExtArgs>
      CustomerGroup: Prisma.$CustomerGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      customerId: string
      groupId: string
      createdAt: Date
    }, ExtArgs["result"]["customerToGroup"]>
    composites: {}
  }

  type CustomerToGroupGetPayload<S extends boolean | null | undefined | CustomerToGroupDefaultArgs> = $Result.GetResult<Prisma.$CustomerToGroupPayload, S>

  type CustomerToGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerToGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerToGroupCountAggregateInputType | true
    }

  export interface CustomerToGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerToGroup'], meta: { name: 'CustomerToGroup' } }
    /**
     * Find zero or one CustomerToGroup that matches the filter.
     * @param {CustomerToGroupFindUniqueArgs} args - Arguments to find a CustomerToGroup
     * @example
     * // Get one CustomerToGroup
     * const customerToGroup = await prisma.customerToGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerToGroupFindUniqueArgs>(args: SelectSubset<T, CustomerToGroupFindUniqueArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerToGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerToGroupFindUniqueOrThrowArgs} args - Arguments to find a CustomerToGroup
     * @example
     * // Get one CustomerToGroup
     * const customerToGroup = await prisma.customerToGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerToGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerToGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerToGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupFindFirstArgs} args - Arguments to find a CustomerToGroup
     * @example
     * // Get one CustomerToGroup
     * const customerToGroup = await prisma.customerToGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerToGroupFindFirstArgs>(args?: SelectSubset<T, CustomerToGroupFindFirstArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerToGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupFindFirstOrThrowArgs} args - Arguments to find a CustomerToGroup
     * @example
     * // Get one CustomerToGroup
     * const customerToGroup = await prisma.customerToGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerToGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerToGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerToGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerToGroups
     * const customerToGroups = await prisma.customerToGroup.findMany()
     * 
     * // Get first 10 CustomerToGroups
     * const customerToGroups = await prisma.customerToGroup.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const customerToGroupWithCustomerIdOnly = await prisma.customerToGroup.findMany({ select: { customerId: true } })
     * 
     */
    findMany<T extends CustomerToGroupFindManyArgs>(args?: SelectSubset<T, CustomerToGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerToGroup.
     * @param {CustomerToGroupCreateArgs} args - Arguments to create a CustomerToGroup.
     * @example
     * // Create one CustomerToGroup
     * const CustomerToGroup = await prisma.customerToGroup.create({
     *   data: {
     *     // ... data to create a CustomerToGroup
     *   }
     * })
     * 
     */
    create<T extends CustomerToGroupCreateArgs>(args: SelectSubset<T, CustomerToGroupCreateArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerToGroups.
     * @param {CustomerToGroupCreateManyArgs} args - Arguments to create many CustomerToGroups.
     * @example
     * // Create many CustomerToGroups
     * const customerToGroup = await prisma.customerToGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerToGroupCreateManyArgs>(args?: SelectSubset<T, CustomerToGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerToGroups and returns the data saved in the database.
     * @param {CustomerToGroupCreateManyAndReturnArgs} args - Arguments to create many CustomerToGroups.
     * @example
     * // Create many CustomerToGroups
     * const customerToGroup = await prisma.customerToGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerToGroups and only return the `customerId`
     * const customerToGroupWithCustomerIdOnly = await prisma.customerToGroup.createManyAndReturn({
     *   select: { customerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerToGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerToGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerToGroup.
     * @param {CustomerToGroupDeleteArgs} args - Arguments to delete one CustomerToGroup.
     * @example
     * // Delete one CustomerToGroup
     * const CustomerToGroup = await prisma.customerToGroup.delete({
     *   where: {
     *     // ... filter to delete one CustomerToGroup
     *   }
     * })
     * 
     */
    delete<T extends CustomerToGroupDeleteArgs>(args: SelectSubset<T, CustomerToGroupDeleteArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerToGroup.
     * @param {CustomerToGroupUpdateArgs} args - Arguments to update one CustomerToGroup.
     * @example
     * // Update one CustomerToGroup
     * const customerToGroup = await prisma.customerToGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerToGroupUpdateArgs>(args: SelectSubset<T, CustomerToGroupUpdateArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerToGroups.
     * @param {CustomerToGroupDeleteManyArgs} args - Arguments to filter CustomerToGroups to delete.
     * @example
     * // Delete a few CustomerToGroups
     * const { count } = await prisma.customerToGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerToGroupDeleteManyArgs>(args?: SelectSubset<T, CustomerToGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerToGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerToGroups
     * const customerToGroup = await prisma.customerToGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerToGroupUpdateManyArgs>(args: SelectSubset<T, CustomerToGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerToGroups and returns the data updated in the database.
     * @param {CustomerToGroupUpdateManyAndReturnArgs} args - Arguments to update many CustomerToGroups.
     * @example
     * // Update many CustomerToGroups
     * const customerToGroup = await prisma.customerToGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerToGroups and only return the `customerId`
     * const customerToGroupWithCustomerIdOnly = await prisma.customerToGroup.updateManyAndReturn({
     *   select: { customerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerToGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerToGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerToGroup.
     * @param {CustomerToGroupUpsertArgs} args - Arguments to update or create a CustomerToGroup.
     * @example
     * // Update or create a CustomerToGroup
     * const customerToGroup = await prisma.customerToGroup.upsert({
     *   create: {
     *     // ... data to create a CustomerToGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerToGroup we want to update
     *   }
     * })
     */
    upsert<T extends CustomerToGroupUpsertArgs>(args: SelectSubset<T, CustomerToGroupUpsertArgs<ExtArgs>>): Prisma__CustomerToGroupClient<$Result.GetResult<Prisma.$CustomerToGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerToGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupCountArgs} args - Arguments to filter CustomerToGroups to count.
     * @example
     * // Count the number of CustomerToGroups
     * const count = await prisma.customerToGroup.count({
     *   where: {
     *     // ... the filter for the CustomerToGroups we want to count
     *   }
     * })
    **/
    count<T extends CustomerToGroupCountArgs>(
      args?: Subset<T, CustomerToGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerToGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerToGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerToGroupAggregateArgs>(args: Subset<T, CustomerToGroupAggregateArgs>): Prisma.PrismaPromise<GetCustomerToGroupAggregateType<T>>

    /**
     * Group by CustomerToGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerToGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerToGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerToGroupGroupByArgs['orderBy'] }
        : { orderBy?: CustomerToGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerToGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerToGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerToGroup model
   */
  readonly fields: CustomerToGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerToGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerToGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CustomerGroup<T extends CustomerGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroupDefaultArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerToGroup model
   */
  interface CustomerToGroupFieldRefs {
    readonly customerId: FieldRef<"CustomerToGroup", 'String'>
    readonly groupId: FieldRef<"CustomerToGroup", 'String'>
    readonly createdAt: FieldRef<"CustomerToGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerToGroup findUnique
   */
  export type CustomerToGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerToGroup to fetch.
     */
    where: CustomerToGroupWhereUniqueInput
  }

  /**
   * CustomerToGroup findUniqueOrThrow
   */
  export type CustomerToGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerToGroup to fetch.
     */
    where: CustomerToGroupWhereUniqueInput
  }

  /**
   * CustomerToGroup findFirst
   */
  export type CustomerToGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerToGroup to fetch.
     */
    where?: CustomerToGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerToGroups to fetch.
     */
    orderBy?: CustomerToGroupOrderByWithRelationInput | CustomerToGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerToGroups.
     */
    cursor?: CustomerToGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerToGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerToGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerToGroups.
     */
    distinct?: CustomerToGroupScalarFieldEnum | CustomerToGroupScalarFieldEnum[]
  }

  /**
   * CustomerToGroup findFirstOrThrow
   */
  export type CustomerToGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerToGroup to fetch.
     */
    where?: CustomerToGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerToGroups to fetch.
     */
    orderBy?: CustomerToGroupOrderByWithRelationInput | CustomerToGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerToGroups.
     */
    cursor?: CustomerToGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerToGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerToGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerToGroups.
     */
    distinct?: CustomerToGroupScalarFieldEnum | CustomerToGroupScalarFieldEnum[]
  }

  /**
   * CustomerToGroup findMany
   */
  export type CustomerToGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerToGroups to fetch.
     */
    where?: CustomerToGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerToGroups to fetch.
     */
    orderBy?: CustomerToGroupOrderByWithRelationInput | CustomerToGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerToGroups.
     */
    cursor?: CustomerToGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerToGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerToGroups.
     */
    skip?: number
    distinct?: CustomerToGroupScalarFieldEnum | CustomerToGroupScalarFieldEnum[]
  }

  /**
   * CustomerToGroup create
   */
  export type CustomerToGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerToGroup.
     */
    data: XOR<CustomerToGroupCreateInput, CustomerToGroupUncheckedCreateInput>
  }

  /**
   * CustomerToGroup createMany
   */
  export type CustomerToGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerToGroups.
     */
    data: CustomerToGroupCreateManyInput | CustomerToGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerToGroup createManyAndReturn
   */
  export type CustomerToGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerToGroups.
     */
    data: CustomerToGroupCreateManyInput | CustomerToGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerToGroup update
   */
  export type CustomerToGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerToGroup.
     */
    data: XOR<CustomerToGroupUpdateInput, CustomerToGroupUncheckedUpdateInput>
    /**
     * Choose, which CustomerToGroup to update.
     */
    where: CustomerToGroupWhereUniqueInput
  }

  /**
   * CustomerToGroup updateMany
   */
  export type CustomerToGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerToGroups.
     */
    data: XOR<CustomerToGroupUpdateManyMutationInput, CustomerToGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerToGroups to update
     */
    where?: CustomerToGroupWhereInput
    /**
     * Limit how many CustomerToGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerToGroup updateManyAndReturn
   */
  export type CustomerToGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * The data used to update CustomerToGroups.
     */
    data: XOR<CustomerToGroupUpdateManyMutationInput, CustomerToGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerToGroups to update
     */
    where?: CustomerToGroupWhereInput
    /**
     * Limit how many CustomerToGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerToGroup upsert
   */
  export type CustomerToGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerToGroup to update in case it exists.
     */
    where: CustomerToGroupWhereUniqueInput
    /**
     * In case the CustomerToGroup found by the `where` argument doesn't exist, create a new CustomerToGroup with this data.
     */
    create: XOR<CustomerToGroupCreateInput, CustomerToGroupUncheckedCreateInput>
    /**
     * In case the CustomerToGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerToGroupUpdateInput, CustomerToGroupUncheckedUpdateInput>
  }

  /**
   * CustomerToGroup delete
   */
  export type CustomerToGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
    /**
     * Filter which CustomerToGroup to delete.
     */
    where: CustomerToGroupWhereUniqueInput
  }

  /**
   * CustomerToGroup deleteMany
   */
  export type CustomerToGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerToGroups to delete
     */
    where?: CustomerToGroupWhereInput
    /**
     * Limit how many CustomerToGroups to delete.
     */
    limit?: number
  }

  /**
   * CustomerToGroup without action
   */
  export type CustomerToGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerToGroup
     */
    select?: CustomerToGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerToGroup
     */
    omit?: CustomerToGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerToGroupInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyProgramRule
   */

  export type AggregateLoyaltyProgramRule = {
    _count: LoyaltyProgramRuleCountAggregateOutputType | null
    _avg: LoyaltyProgramRuleAvgAggregateOutputType | null
    _sum: LoyaltyProgramRuleSumAggregateOutputType | null
    _min: LoyaltyProgramRuleMinAggregateOutputType | null
    _max: LoyaltyProgramRuleMaxAggregateOutputType | null
  }

  export type LoyaltyProgramRuleAvgAggregateOutputType = {
    pointsAwarded: number | null
  }

  export type LoyaltyProgramRuleSumAggregateOutputType = {
    pointsAwarded: number | null
  }

  export type LoyaltyProgramRuleMinAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    description: string | null
    type: $Enums.LoyaltyRuleType | null
    conditions: string | null
    pointsAwarded: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramRuleMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    description: string | null
    type: $Enums.LoyaltyRuleType | null
    conditions: string | null
    pointsAwarded: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramRuleCountAggregateOutputType = {
    id: number
    programId: number
    name: number
    description: number
    type: number
    conditions: number
    pointsAwarded: number
    isActive: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyProgramRuleAvgAggregateInputType = {
    pointsAwarded?: true
  }

  export type LoyaltyProgramRuleSumAggregateInputType = {
    pointsAwarded?: true
  }

  export type LoyaltyProgramRuleMinAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    type?: true
    conditions?: true
    pointsAwarded?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramRuleMaxAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    type?: true
    conditions?: true
    pointsAwarded?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramRuleCountAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    type?: true
    conditions?: true
    pointsAwarded?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyProgramRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgramRule to aggregate.
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramRules to fetch.
     */
    orderBy?: LoyaltyProgramRuleOrderByWithRelationInput | LoyaltyProgramRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyProgramRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyProgramRules
    **/
    _count?: true | LoyaltyProgramRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyProgramRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyProgramRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyProgramRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyProgramRuleMaxAggregateInputType
  }

  export type GetLoyaltyProgramRuleAggregateType<T extends LoyaltyProgramRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyProgramRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyProgramRule[P]>
      : GetScalarType<T[P], AggregateLoyaltyProgramRule[P]>
  }




  export type LoyaltyProgramRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramRuleWhereInput
    orderBy?: LoyaltyProgramRuleOrderByWithAggregationInput | LoyaltyProgramRuleOrderByWithAggregationInput[]
    by: LoyaltyProgramRuleScalarFieldEnum[] | LoyaltyProgramRuleScalarFieldEnum
    having?: LoyaltyProgramRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyProgramRuleCountAggregateInputType | true
    _avg?: LoyaltyProgramRuleAvgAggregateInputType
    _sum?: LoyaltyProgramRuleSumAggregateInputType
    _min?: LoyaltyProgramRuleMinAggregateInputType
    _max?: LoyaltyProgramRuleMaxAggregateInputType
  }

  export type LoyaltyProgramRuleGroupByOutputType = {
    id: string
    programId: string
    name: string
    description: string | null
    type: $Enums.LoyaltyRuleType
    conditions: string | null
    pointsAwarded: number
    isActive: boolean
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyProgramRuleCountAggregateOutputType | null
    _avg: LoyaltyProgramRuleAvgAggregateOutputType | null
    _sum: LoyaltyProgramRuleSumAggregateOutputType | null
    _min: LoyaltyProgramRuleMinAggregateOutputType | null
    _max: LoyaltyProgramRuleMaxAggregateOutputType | null
  }

  type GetLoyaltyProgramRuleGroupByPayload<T extends LoyaltyProgramRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyProgramRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyProgramRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyProgramRuleGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyProgramRuleGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyProgramRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    pointsAwarded?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyProgram?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramRule"]>

  export type LoyaltyProgramRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    pointsAwarded?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyProgram?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramRule"]>

  export type LoyaltyProgramRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    pointsAwarded?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    LoyaltyProgram?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramRule"]>

  export type LoyaltyProgramRuleSelectScalar = {
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    pointsAwarded?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyProgramRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "programId" | "name" | "description" | "type" | "conditions" | "pointsAwarded" | "isActive" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["loyaltyProgramRule"]>
  export type LoyaltyProgramRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyProgram?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyProgram?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LoyaltyProgram?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }

  export type $LoyaltyProgramRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyProgramRule"
    objects: {
      LoyaltyProgram: Prisma.$LoyaltyProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      name: string
      description: string | null
      type: $Enums.LoyaltyRuleType
      conditions: string | null
      pointsAwarded: number
      isActive: boolean
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyProgramRule"]>
    composites: {}
  }

  type LoyaltyProgramRuleGetPayload<S extends boolean | null | undefined | LoyaltyProgramRuleDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyProgramRulePayload, S>

  type LoyaltyProgramRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyProgramRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyProgramRuleCountAggregateInputType | true
    }

  export interface LoyaltyProgramRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyProgramRule'], meta: { name: 'LoyaltyProgramRule' } }
    /**
     * Find zero or one LoyaltyProgramRule that matches the filter.
     * @param {LoyaltyProgramRuleFindUniqueArgs} args - Arguments to find a LoyaltyProgramRule
     * @example
     * // Get one LoyaltyProgramRule
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyProgramRuleFindUniqueArgs>(args: SelectSubset<T, LoyaltyProgramRuleFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyProgramRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyProgramRuleFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyProgramRule
     * @example
     * // Get one LoyaltyProgramRule
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyProgramRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyProgramRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgramRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleFindFirstArgs} args - Arguments to find a LoyaltyProgramRule
     * @example
     * // Get one LoyaltyProgramRule
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyProgramRuleFindFirstArgs>(args?: SelectSubset<T, LoyaltyProgramRuleFindFirstArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgramRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleFindFirstOrThrowArgs} args - Arguments to find a LoyaltyProgramRule
     * @example
     * // Get one LoyaltyProgramRule
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyProgramRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyProgramRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyProgramRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyProgramRules
     * const loyaltyProgramRules = await prisma.loyaltyProgramRule.findMany()
     * 
     * // Get first 10 LoyaltyProgramRules
     * const loyaltyProgramRules = await prisma.loyaltyProgramRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyProgramRuleWithIdOnly = await prisma.loyaltyProgramRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyProgramRuleFindManyArgs>(args?: SelectSubset<T, LoyaltyProgramRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyProgramRule.
     * @param {LoyaltyProgramRuleCreateArgs} args - Arguments to create a LoyaltyProgramRule.
     * @example
     * // Create one LoyaltyProgramRule
     * const LoyaltyProgramRule = await prisma.loyaltyProgramRule.create({
     *   data: {
     *     // ... data to create a LoyaltyProgramRule
     *   }
     * })
     * 
     */
    create<T extends LoyaltyProgramRuleCreateArgs>(args: SelectSubset<T, LoyaltyProgramRuleCreateArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyProgramRules.
     * @param {LoyaltyProgramRuleCreateManyArgs} args - Arguments to create many LoyaltyProgramRules.
     * @example
     * // Create many LoyaltyProgramRules
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyProgramRuleCreateManyArgs>(args?: SelectSubset<T, LoyaltyProgramRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyProgramRules and returns the data saved in the database.
     * @param {LoyaltyProgramRuleCreateManyAndReturnArgs} args - Arguments to create many LoyaltyProgramRules.
     * @example
     * // Create many LoyaltyProgramRules
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyProgramRules and only return the `id`
     * const loyaltyProgramRuleWithIdOnly = await prisma.loyaltyProgramRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyProgramRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyProgramRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyProgramRule.
     * @param {LoyaltyProgramRuleDeleteArgs} args - Arguments to delete one LoyaltyProgramRule.
     * @example
     * // Delete one LoyaltyProgramRule
     * const LoyaltyProgramRule = await prisma.loyaltyProgramRule.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyProgramRule
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyProgramRuleDeleteArgs>(args: SelectSubset<T, LoyaltyProgramRuleDeleteArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyProgramRule.
     * @param {LoyaltyProgramRuleUpdateArgs} args - Arguments to update one LoyaltyProgramRule.
     * @example
     * // Update one LoyaltyProgramRule
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyProgramRuleUpdateArgs>(args: SelectSubset<T, LoyaltyProgramRuleUpdateArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyProgramRules.
     * @param {LoyaltyProgramRuleDeleteManyArgs} args - Arguments to filter LoyaltyProgramRules to delete.
     * @example
     * // Delete a few LoyaltyProgramRules
     * const { count } = await prisma.loyaltyProgramRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyProgramRuleDeleteManyArgs>(args?: SelectSubset<T, LoyaltyProgramRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyProgramRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyProgramRules
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyProgramRuleUpdateManyArgs>(args: SelectSubset<T, LoyaltyProgramRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyProgramRules and returns the data updated in the database.
     * @param {LoyaltyProgramRuleUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyProgramRules.
     * @example
     * // Update many LoyaltyProgramRules
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyProgramRules and only return the `id`
     * const loyaltyProgramRuleWithIdOnly = await prisma.loyaltyProgramRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyProgramRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyProgramRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyProgramRule.
     * @param {LoyaltyProgramRuleUpsertArgs} args - Arguments to update or create a LoyaltyProgramRule.
     * @example
     * // Update or create a LoyaltyProgramRule
     * const loyaltyProgramRule = await prisma.loyaltyProgramRule.upsert({
     *   create: {
     *     // ... data to create a LoyaltyProgramRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyProgramRule we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyProgramRuleUpsertArgs>(args: SelectSubset<T, LoyaltyProgramRuleUpsertArgs<ExtArgs>>): Prisma__LoyaltyProgramRuleClient<$Result.GetResult<Prisma.$LoyaltyProgramRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyProgramRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleCountArgs} args - Arguments to filter LoyaltyProgramRules to count.
     * @example
     * // Count the number of LoyaltyProgramRules
     * const count = await prisma.loyaltyProgramRule.count({
     *   where: {
     *     // ... the filter for the LoyaltyProgramRules we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyProgramRuleCountArgs>(
      args?: Subset<T, LoyaltyProgramRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyProgramRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyProgramRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyProgramRuleAggregateArgs>(args: Subset<T, LoyaltyProgramRuleAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyProgramRuleAggregateType<T>>

    /**
     * Group by LoyaltyProgramRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyProgramRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyProgramRuleGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyProgramRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyProgramRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyProgramRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyProgramRule model
   */
  readonly fields: LoyaltyProgramRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyProgramRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyProgramRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    LoyaltyProgram<T extends LoyaltyProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgramDefaultArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyProgramRule model
   */
  interface LoyaltyProgramRuleFieldRefs {
    readonly id: FieldRef<"LoyaltyProgramRule", 'String'>
    readonly programId: FieldRef<"LoyaltyProgramRule", 'String'>
    readonly name: FieldRef<"LoyaltyProgramRule", 'String'>
    readonly description: FieldRef<"LoyaltyProgramRule", 'String'>
    readonly type: FieldRef<"LoyaltyProgramRule", 'LoyaltyRuleType'>
    readonly conditions: FieldRef<"LoyaltyProgramRule", 'String'>
    readonly pointsAwarded: FieldRef<"LoyaltyProgramRule", 'Int'>
    readonly isActive: FieldRef<"LoyaltyProgramRule", 'Boolean'>
    readonly startDate: FieldRef<"LoyaltyProgramRule", 'DateTime'>
    readonly endDate: FieldRef<"LoyaltyProgramRule", 'DateTime'>
    readonly createdAt: FieldRef<"LoyaltyProgramRule", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyProgramRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyProgramRule findUnique
   */
  export type LoyaltyProgramRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramRule to fetch.
     */
    where: LoyaltyProgramRuleWhereUniqueInput
  }

  /**
   * LoyaltyProgramRule findUniqueOrThrow
   */
  export type LoyaltyProgramRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramRule to fetch.
     */
    where: LoyaltyProgramRuleWhereUniqueInput
  }

  /**
   * LoyaltyProgramRule findFirst
   */
  export type LoyaltyProgramRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramRule to fetch.
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramRules to fetch.
     */
    orderBy?: LoyaltyProgramRuleOrderByWithRelationInput | LoyaltyProgramRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyProgramRules.
     */
    cursor?: LoyaltyProgramRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyProgramRules.
     */
    distinct?: LoyaltyProgramRuleScalarFieldEnum | LoyaltyProgramRuleScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramRule findFirstOrThrow
   */
  export type LoyaltyProgramRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramRule to fetch.
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramRules to fetch.
     */
    orderBy?: LoyaltyProgramRuleOrderByWithRelationInput | LoyaltyProgramRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyProgramRules.
     */
    cursor?: LoyaltyProgramRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyProgramRules.
     */
    distinct?: LoyaltyProgramRuleScalarFieldEnum | LoyaltyProgramRuleScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramRule findMany
   */
  export type LoyaltyProgramRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramRules to fetch.
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramRules to fetch.
     */
    orderBy?: LoyaltyProgramRuleOrderByWithRelationInput | LoyaltyProgramRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyProgramRules.
     */
    cursor?: LoyaltyProgramRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramRules.
     */
    skip?: number
    distinct?: LoyaltyProgramRuleScalarFieldEnum | LoyaltyProgramRuleScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramRule create
   */
  export type LoyaltyProgramRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyProgramRule.
     */
    data: XOR<LoyaltyProgramRuleCreateInput, LoyaltyProgramRuleUncheckedCreateInput>
  }

  /**
   * LoyaltyProgramRule createMany
   */
  export type LoyaltyProgramRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyProgramRules.
     */
    data: LoyaltyProgramRuleCreateManyInput | LoyaltyProgramRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgramRule createManyAndReturn
   */
  export type LoyaltyProgramRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyProgramRules.
     */
    data: LoyaltyProgramRuleCreateManyInput | LoyaltyProgramRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyProgramRule update
   */
  export type LoyaltyProgramRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyProgramRule.
     */
    data: XOR<LoyaltyProgramRuleUpdateInput, LoyaltyProgramRuleUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyProgramRule to update.
     */
    where: LoyaltyProgramRuleWhereUniqueInput
  }

  /**
   * LoyaltyProgramRule updateMany
   */
  export type LoyaltyProgramRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyProgramRules.
     */
    data: XOR<LoyaltyProgramRuleUpdateManyMutationInput, LoyaltyProgramRuleUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyProgramRules to update
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * Limit how many LoyaltyProgramRules to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgramRule updateManyAndReturn
   */
  export type LoyaltyProgramRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyProgramRules.
     */
    data: XOR<LoyaltyProgramRuleUpdateManyMutationInput, LoyaltyProgramRuleUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyProgramRules to update
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * Limit how many LoyaltyProgramRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyProgramRule upsert
   */
  export type LoyaltyProgramRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyProgramRule to update in case it exists.
     */
    where: LoyaltyProgramRuleWhereUniqueInput
    /**
     * In case the LoyaltyProgramRule found by the `where` argument doesn't exist, create a new LoyaltyProgramRule with this data.
     */
    create: XOR<LoyaltyProgramRuleCreateInput, LoyaltyProgramRuleUncheckedCreateInput>
    /**
     * In case the LoyaltyProgramRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyProgramRuleUpdateInput, LoyaltyProgramRuleUncheckedUpdateInput>
  }

  /**
   * LoyaltyProgramRule delete
   */
  export type LoyaltyProgramRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyProgramRule to delete.
     */
    where: LoyaltyProgramRuleWhereUniqueInput
  }

  /**
   * LoyaltyProgramRule deleteMany
   */
  export type LoyaltyProgramRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgramRules to delete
     */
    where?: LoyaltyProgramRuleWhereInput
    /**
     * Limit how many LoyaltyProgramRules to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyProgramRule without action
   */
  export type LoyaltyProgramRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramRule
     */
    select?: LoyaltyProgramRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramRule
     */
    omit?: LoyaltyProgramRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramRuleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    relatedEntityId: string | null
    relatedEntityType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    senderId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    relatedEntityId: string | null
    relatedEntityType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    senderId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    relatedEntityId: number
    relatedEntityType: number
    createdAt: number
    updatedAt: number
    senderId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    relatedEntityId?: true
    relatedEntityType?: true
    createdAt?: true
    updatedAt?: true
    senderId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    relatedEntityId?: true
    relatedEntityType?: true
    createdAt?: true
    updatedAt?: true
    senderId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    relatedEntityId?: true
    relatedEntityType?: true
    createdAt?: true
    updatedAt?: true
    senderId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    relatedEntityId: string | null
    relatedEntityType: string | null
    createdAt: Date
    updatedAt: Date
    senderId: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    relatedEntityId?: boolean
    relatedEntityType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    senderId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "relatedEntityId" | "relatedEntityType" | "createdAt" | "updatedAt" | "senderId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      receiver: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      relatedEntityId: string | null
      relatedEntityType: string | null
      createdAt: Date
      updatedAt: Date
      senderId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends Notification$senderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly relatedEntityId: FieldRef<"Notification", 'String'>
    readonly relatedEntityType: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly senderId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.sender
   */
  export type Notification$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model PromotionRedemption
   */

  export type AggregatePromotionRedemption = {
    _count: PromotionRedemptionCountAggregateOutputType | null
    _avg: PromotionRedemptionAvgAggregateOutputType | null
    _sum: PromotionRedemptionSumAggregateOutputType | null
    _min: PromotionRedemptionMinAggregateOutputType | null
    _max: PromotionRedemptionMaxAggregateOutputType | null
  }

  export type PromotionRedemptionAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type PromotionRedemptionSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type PromotionRedemptionMinAggregateOutputType = {
    id: string | null
    promotionId: string | null
    customerId: string | null
    saleId: string | null
    discountAmount: Decimal | null
    createdAt: Date | null
  }

  export type PromotionRedemptionMaxAggregateOutputType = {
    id: string | null
    promotionId: string | null
    customerId: string | null
    saleId: string | null
    discountAmount: Decimal | null
    createdAt: Date | null
  }

  export type PromotionRedemptionCountAggregateOutputType = {
    id: number
    promotionId: number
    customerId: number
    saleId: number
    discountAmount: number
    createdAt: number
    _all: number
  }


  export type PromotionRedemptionAvgAggregateInputType = {
    discountAmount?: true
  }

  export type PromotionRedemptionSumAggregateInputType = {
    discountAmount?: true
  }

  export type PromotionRedemptionMinAggregateInputType = {
    id?: true
    promotionId?: true
    customerId?: true
    saleId?: true
    discountAmount?: true
    createdAt?: true
  }

  export type PromotionRedemptionMaxAggregateInputType = {
    id?: true
    promotionId?: true
    customerId?: true
    saleId?: true
    discountAmount?: true
    createdAt?: true
  }

  export type PromotionRedemptionCountAggregateInputType = {
    id?: true
    promotionId?: true
    customerId?: true
    saleId?: true
    discountAmount?: true
    createdAt?: true
    _all?: true
  }

  export type PromotionRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRedemption to aggregate.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionRedemptions
    **/
    _count?: true | PromotionRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionRedemptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionRedemptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionRedemptionMaxAggregateInputType
  }

  export type GetPromotionRedemptionAggregateType<T extends PromotionRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionRedemption[P]>
      : GetScalarType<T[P], AggregatePromotionRedemption[P]>
  }




  export type PromotionRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRedemptionWhereInput
    orderBy?: PromotionRedemptionOrderByWithAggregationInput | PromotionRedemptionOrderByWithAggregationInput[]
    by: PromotionRedemptionScalarFieldEnum[] | PromotionRedemptionScalarFieldEnum
    having?: PromotionRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionRedemptionCountAggregateInputType | true
    _avg?: PromotionRedemptionAvgAggregateInputType
    _sum?: PromotionRedemptionSumAggregateInputType
    _min?: PromotionRedemptionMinAggregateInputType
    _max?: PromotionRedemptionMaxAggregateInputType
  }

  export type PromotionRedemptionGroupByOutputType = {
    id: string
    promotionId: string
    customerId: string
    saleId: string
    discountAmount: Decimal
    createdAt: Date
    _count: PromotionRedemptionCountAggregateOutputType | null
    _avg: PromotionRedemptionAvgAggregateOutputType | null
    _sum: PromotionRedemptionSumAggregateOutputType | null
    _min: PromotionRedemptionMinAggregateOutputType | null
    _max: PromotionRedemptionMaxAggregateOutputType | null
  }

  type GetPromotionRedemptionGroupByPayload<T extends PromotionRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    customerId?: boolean
    saleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerPromotion?: boolean | CustomerPromotionDefaultArgs<ExtArgs>
    Sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    customerId?: boolean
    saleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerPromotion?: boolean | CustomerPromotionDefaultArgs<ExtArgs>
    Sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    customerId?: boolean
    saleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerPromotion?: boolean | CustomerPromotionDefaultArgs<ExtArgs>
    Sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRedemption"]>

  export type PromotionRedemptionSelectScalar = {
    id?: boolean
    promotionId?: boolean
    customerId?: boolean
    saleId?: boolean
    discountAmount?: boolean
    createdAt?: boolean
  }

  export type PromotionRedemptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promotionId" | "customerId" | "saleId" | "discountAmount" | "createdAt", ExtArgs["result"]["promotionRedemption"]>
  export type PromotionRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerPromotion?: boolean | CustomerPromotionDefaultArgs<ExtArgs>
    Sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type PromotionRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerPromotion?: boolean | CustomerPromotionDefaultArgs<ExtArgs>
    Sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type PromotionRedemptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | CustomerDefaultArgs<ExtArgs>
    CustomerPromotion?: boolean | CustomerPromotionDefaultArgs<ExtArgs>
    Sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $PromotionRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionRedemption"
    objects: {
      Customer: Prisma.$CustomerPayload<ExtArgs>
      CustomerPromotion: Prisma.$CustomerPromotionPayload<ExtArgs>
      Sale: Prisma.$SalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promotionId: string
      customerId: string
      saleId: string
      discountAmount: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["promotionRedemption"]>
    composites: {}
  }

  type PromotionRedemptionGetPayload<S extends boolean | null | undefined | PromotionRedemptionDefaultArgs> = $Result.GetResult<Prisma.$PromotionRedemptionPayload, S>

  type PromotionRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionRedemptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionRedemptionCountAggregateInputType | true
    }

  export interface PromotionRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionRedemption'], meta: { name: 'PromotionRedemption' } }
    /**
     * Find zero or one PromotionRedemption that matches the filter.
     * @param {PromotionRedemptionFindUniqueArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionRedemptionFindUniqueArgs>(args: SelectSubset<T, PromotionRedemptionFindUniqueArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromotionRedemption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionRedemptionFindUniqueOrThrowArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindFirstArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionRedemptionFindFirstArgs>(args?: SelectSubset<T, PromotionRedemptionFindFirstArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindFirstOrThrowArgs} args - Arguments to find a PromotionRedemption
     * @example
     * // Get one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromotionRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionRedemptions
     * const promotionRedemptions = await prisma.promotionRedemption.findMany()
     * 
     * // Get first 10 PromotionRedemptions
     * const promotionRedemptions = await prisma.promotionRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionRedemptionFindManyArgs>(args?: SelectSubset<T, PromotionRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromotionRedemption.
     * @param {PromotionRedemptionCreateArgs} args - Arguments to create a PromotionRedemption.
     * @example
     * // Create one PromotionRedemption
     * const PromotionRedemption = await prisma.promotionRedemption.create({
     *   data: {
     *     // ... data to create a PromotionRedemption
     *   }
     * })
     * 
     */
    create<T extends PromotionRedemptionCreateArgs>(args: SelectSubset<T, PromotionRedemptionCreateArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromotionRedemptions.
     * @param {PromotionRedemptionCreateManyArgs} args - Arguments to create many PromotionRedemptions.
     * @example
     * // Create many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionRedemptionCreateManyArgs>(args?: SelectSubset<T, PromotionRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionRedemptions and returns the data saved in the database.
     * @param {PromotionRedemptionCreateManyAndReturnArgs} args - Arguments to create many PromotionRedemptions.
     * @example
     * // Create many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionRedemptions and only return the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromotionRedemption.
     * @param {PromotionRedemptionDeleteArgs} args - Arguments to delete one PromotionRedemption.
     * @example
     * // Delete one PromotionRedemption
     * const PromotionRedemption = await prisma.promotionRedemption.delete({
     *   where: {
     *     // ... filter to delete one PromotionRedemption
     *   }
     * })
     * 
     */
    delete<T extends PromotionRedemptionDeleteArgs>(args: SelectSubset<T, PromotionRedemptionDeleteArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromotionRedemption.
     * @param {PromotionRedemptionUpdateArgs} args - Arguments to update one PromotionRedemption.
     * @example
     * // Update one PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionRedemptionUpdateArgs>(args: SelectSubset<T, PromotionRedemptionUpdateArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromotionRedemptions.
     * @param {PromotionRedemptionDeleteManyArgs} args - Arguments to filter PromotionRedemptions to delete.
     * @example
     * // Delete a few PromotionRedemptions
     * const { count } = await prisma.promotionRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionRedemptionDeleteManyArgs>(args?: SelectSubset<T, PromotionRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionRedemptionUpdateManyArgs>(args: SelectSubset<T, PromotionRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRedemptions and returns the data updated in the database.
     * @param {PromotionRedemptionUpdateManyAndReturnArgs} args - Arguments to update many PromotionRedemptions.
     * @example
     * // Update many PromotionRedemptions
     * const promotionRedemption = await prisma.promotionRedemption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromotionRedemptions and only return the `id`
     * const promotionRedemptionWithIdOnly = await prisma.promotionRedemption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionRedemptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromotionRedemption.
     * @param {PromotionRedemptionUpsertArgs} args - Arguments to update or create a PromotionRedemption.
     * @example
     * // Update or create a PromotionRedemption
     * const promotionRedemption = await prisma.promotionRedemption.upsert({
     *   create: {
     *     // ... data to create a PromotionRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionRedemption we want to update
     *   }
     * })
     */
    upsert<T extends PromotionRedemptionUpsertArgs>(args: SelectSubset<T, PromotionRedemptionUpsertArgs<ExtArgs>>): Prisma__PromotionRedemptionClient<$Result.GetResult<Prisma.$PromotionRedemptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromotionRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionCountArgs} args - Arguments to filter PromotionRedemptions to count.
     * @example
     * // Count the number of PromotionRedemptions
     * const count = await prisma.promotionRedemption.count({
     *   where: {
     *     // ... the filter for the PromotionRedemptions we want to count
     *   }
     * })
    **/
    count<T extends PromotionRedemptionCountArgs>(
      args?: Subset<T, PromotionRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionRedemptionAggregateArgs>(args: Subset<T, PromotionRedemptionAggregateArgs>): Prisma.PrismaPromise<GetPromotionRedemptionAggregateType<T>>

    /**
     * Group by PromotionRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionRedemption model
   */
  readonly fields: PromotionRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CustomerPromotion<T extends CustomerPromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerPromotionDefaultArgs<ExtArgs>>): Prisma__CustomerPromotionClient<$Result.GetResult<Prisma.$CustomerPromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionRedemption model
   */
  interface PromotionRedemptionFieldRefs {
    readonly id: FieldRef<"PromotionRedemption", 'String'>
    readonly promotionId: FieldRef<"PromotionRedemption", 'String'>
    readonly customerId: FieldRef<"PromotionRedemption", 'String'>
    readonly saleId: FieldRef<"PromotionRedemption", 'String'>
    readonly discountAmount: FieldRef<"PromotionRedemption", 'Decimal'>
    readonly createdAt: FieldRef<"PromotionRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionRedemption findUnique
   */
  export type PromotionRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption findUniqueOrThrow
   */
  export type PromotionRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption findFirst
   */
  export type PromotionRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRedemptions.
     */
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption findFirstOrThrow
   */
  export type PromotionRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemption to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRedemptions.
     */
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption findMany
   */
  export type PromotionRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRedemptions to fetch.
     */
    where?: PromotionRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRedemptions to fetch.
     */
    orderBy?: PromotionRedemptionOrderByWithRelationInput | PromotionRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionRedemptions.
     */
    cursor?: PromotionRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRedemptions.
     */
    skip?: number
    distinct?: PromotionRedemptionScalarFieldEnum | PromotionRedemptionScalarFieldEnum[]
  }

  /**
   * PromotionRedemption create
   */
  export type PromotionRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionRedemption.
     */
    data: XOR<PromotionRedemptionCreateInput, PromotionRedemptionUncheckedCreateInput>
  }

  /**
   * PromotionRedemption createMany
   */
  export type PromotionRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionRedemptions.
     */
    data: PromotionRedemptionCreateManyInput | PromotionRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionRedemption createManyAndReturn
   */
  export type PromotionRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * The data used to create many PromotionRedemptions.
     */
    data: PromotionRedemptionCreateManyInput | PromotionRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRedemption update
   */
  export type PromotionRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionRedemption.
     */
    data: XOR<PromotionRedemptionUpdateInput, PromotionRedemptionUncheckedUpdateInput>
    /**
     * Choose, which PromotionRedemption to update.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption updateMany
   */
  export type PromotionRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionRedemptions.
     */
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRedemptions to update
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to update.
     */
    limit?: number
  }

  /**
   * PromotionRedemption updateManyAndReturn
   */
  export type PromotionRedemptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * The data used to update PromotionRedemptions.
     */
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRedemptions to update
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRedemption upsert
   */
  export type PromotionRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionRedemption to update in case it exists.
     */
    where: PromotionRedemptionWhereUniqueInput
    /**
     * In case the PromotionRedemption found by the `where` argument doesn't exist, create a new PromotionRedemption with this data.
     */
    create: XOR<PromotionRedemptionCreateInput, PromotionRedemptionUncheckedCreateInput>
    /**
     * In case the PromotionRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionRedemptionUpdateInput, PromotionRedemptionUncheckedUpdateInput>
  }

  /**
   * PromotionRedemption delete
   */
  export type PromotionRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
    /**
     * Filter which PromotionRedemption to delete.
     */
    where: PromotionRedemptionWhereUniqueInput
  }

  /**
   * PromotionRedemption deleteMany
   */
  export type PromotionRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRedemptions to delete
     */
    where?: PromotionRedemptionWhereInput
    /**
     * Limit how many PromotionRedemptions to delete.
     */
    limit?: number
  }

  /**
   * PromotionRedemption without action
   */
  export type PromotionRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRedemption
     */
    select?: PromotionRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRedemption
     */
    omit?: PromotionRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRedemptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    address: 'address',
    contactPerson: 'contactPerson',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const WarehouseZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    warehouseId: 'warehouseId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseZoneScalarFieldEnum = (typeof WarehouseZoneScalarFieldEnum)[keyof typeof WarehouseZoneScalarFieldEnum]


  export const WarehouseAisleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseAisleScalarFieldEnum = (typeof WarehouseAisleScalarFieldEnum)[keyof typeof WarehouseAisleScalarFieldEnum]


  export const WarehouseShelfScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    aisleId: 'aisleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseShelfScalarFieldEnum = (typeof WarehouseShelfScalarFieldEnum)[keyof typeof WarehouseShelfScalarFieldEnum]


  export const WarehouseBinScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    shelfId: 'shelfId',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseBinScalarFieldEnum = (typeof WarehouseBinScalarFieldEnum)[keyof typeof WarehouseBinScalarFieldEnum]


  export const WarehouseStaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    warehouseId: 'warehouseId',
    position: 'position',
    isManager: 'isManager',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseStaffScalarFieldEnum = (typeof WarehouseStaffScalarFieldEnum)[keyof typeof WarehouseStaffScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    address: 'address',
    phone: 'phone',
    email: 'email',
    openingHours: 'openingHours',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const StoreStaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storeId: 'storeId',
    position: 'position',
    isManager: 'isManager',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreStaffScalarFieldEnum = (typeof StoreStaffScalarFieldEnum)[keyof typeof StoreStaffScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    taxId: 'taxId',
    paymentTerms: 'paymentTerms',
    notes: 'notes',
    isActive: 'isActive',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SupplierContractScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    startDate: 'startDate',
    endDate: 'endDate',
    terms: 'terms',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierContractScalarFieldEnum = (typeof SupplierContractScalarFieldEnum)[keyof typeof SupplierContractScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    supplierId: 'supplierId',
    warehouseId: 'warehouseId',
    status: 'status',
    orderDate: 'orderDate',
    expectedDeliveryDate: 'expectedDeliveryDate',
    deliveredDate: 'deliveredDate',
    subtotal: 'subtotal',
    tax: 'tax',
    shipping: 'shipping',
    discount: 'discount',
    total: 'total',
    notes: 'notes',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    description: 'description',
    orderedQuantity: 'orderedQuantity',
    receivedQuantity: 'receivedQuantity',
    unitPrice: 'unitPrice',
    discount: 'discount',
    tax: 'tax',
    subtotal: 'subtotal',
    total: 'total',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    barcode: 'barcode',
    name: 'name',
    description: 'description',
    categoryId: 'categoryId',
    supplierId: 'supplierId',
    costPrice: 'costPrice',
    wholesalePrice: 'wholesalePrice',
    retailPrice: 'retailPrice',
    unit: 'unit',
    minStockLevel: 'minStockLevel',
    maxStockLevel: 'maxStockLevel',
    reorderPoint: 'reorderPoint',
    weight: 'weight',
    dimensions: 'dimensions',
    taxRate: 'taxRate',
    isActive: 'isActive',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    warehouseId: 'warehouseId',
    storeId: 'storeId',
    binId: 'binId',
    batchNumber: 'batchNumber',
    lotNumber: 'lotNumber',
    serialNumber: 'serialNumber',
    expiryDate: 'expiryDate',
    quantity: 'quantity',
    reservedQuantity: 'reservedQuantity',
    costPrice: 'costPrice',
    wholesalePrice: 'wholesalePrice',
    retailPrice: 'retailPrice',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    receiptNumber: 'receiptNumber',
    storeId: 'storeId',
    customerId: 'customerId',
    createdById: 'createdById',
    saleDate: 'saleDate',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    totalAmount: 'totalAmount',
    loyaltyPointsEarned: 'loyaltyPointsEarned',
    loyaltyPointsRedeemed: 'loyaltyPointsRedeemed',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleItemScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    productId: 'productId',
    inventoryItemId: 'inventoryItemId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discountAmount: 'discountAmount',
    taxAmount: 'taxAmount',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleItemScalarFieldEnum = (typeof SaleItemScalarFieldEnum)[keyof typeof SaleItemScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    referenceNumber: 'referenceNumber',
    type: 'type',
    sourceWarehouseId: 'sourceWarehouseId',
    destinationWarehouseId: 'destinationWarehouseId',
    sourceStoreId: 'sourceStoreId',
    destinationStoreId: 'destinationStoreId',
    status: 'status',
    requestedDate: 'requestedDate',
    approvedDate: 'approvedDate',
    shippedDate: 'shippedDate',
    receivedDate: 'receivedDate',
    notes: 'notes',
    createdById: 'createdById',
    approvedById: 'approvedById',
    receivedById: 'receivedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const TransferItemScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    productId: 'productId',
    sourceInventoryId: 'sourceInventoryId',
    destinationInventoryId: 'destinationInventoryId',
    requestedQuantity: 'requestedQuantity',
    approvedQuantity: 'approvedQuantity',
    shippedQuantity: 'shippedQuantity',
    receivedQuantity: 'receivedQuantity',
    sourceCostPrice: 'sourceCostPrice',
    sourceWholesalePrice: 'sourceWholesalePrice',
    sourceRetailPrice: 'sourceRetailPrice',
    destinationCostPrice: 'destinationCostPrice',
    destinationWholesalePrice: 'destinationWholesalePrice',
    destinationRetailPrice: 'destinationRetailPrice',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferItemScalarFieldEnum = (typeof TransferItemScalarFieldEnum)[keyof typeof TransferItemScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    birthDate: 'birthDate',
    gender: 'gender',
    loyaltyPoints: 'loyaltyPoints',
    loyaltyTier: 'loyaltyTier',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    addressType: 'addressType',
    isDefault: 'isDefault',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const LoyaltyProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pointsPerCurrency: 'pointsPerCurrency',
    minimumPurchase: 'minimumPurchase',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyProgramScalarFieldEnum = (typeof LoyaltyProgramScalarFieldEnum)[keyof typeof LoyaltyProgramScalarFieldEnum]


  export const LoyaltyProgramTierScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    name: 'name',
    description: 'description',
    requiredPoints: 'requiredPoints',
    pointsMultiplier: 'pointsMultiplier',
    benefits: 'benefits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyProgramTierScalarFieldEnum = (typeof LoyaltyProgramTierScalarFieldEnum)[keyof typeof LoyaltyProgramTierScalarFieldEnum]


  export const LoyaltyTransactionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    programId: 'programId',
    points: 'points',
    type: 'type',
    description: 'description',
    referenceId: 'referenceId',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt'
  };

  export type LoyaltyTransactionScalarFieldEnum = (typeof LoyaltyTransactionScalarFieldEnum)[keyof typeof LoyaltyTransactionScalarFieldEnum]


  export const AuditScalarFieldEnum: {
    id: 'id',
    referenceNumber: 'referenceNumber',
    warehouseId: 'warehouseId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    notes: 'notes',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditScalarFieldEnum = (typeof AuditScalarFieldEnum)[keyof typeof AuditScalarFieldEnum]


  export const AuditItemScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    productId: 'productId',
    inventoryItemId: 'inventoryItemId',
    expectedQuantity: 'expectedQuantity',
    actualQuantity: 'actualQuantity',
    variance: 'variance',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditItemScalarFieldEnum = (typeof AuditItemScalarFieldEnum)[keyof typeof AuditItemScalarFieldEnum]


  export const AuditAssignmentScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    userId: 'userId',
    assignedZones: 'assignedZones',
    assignedAisles: 'assignedAisles',
    assignedShelves: 'assignedShelves',
    assignedBins: 'assignedBins',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditAssignmentScalarFieldEnum = (typeof AuditAssignmentScalarFieldEnum)[keyof typeof AuditAssignmentScalarFieldEnum]


  export const CustomerGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerGroupScalarFieldEnum = (typeof CustomerGroupScalarFieldEnum)[keyof typeof CustomerGroupScalarFieldEnum]


  export const CustomerNoteScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    note: 'note',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerNoteScalarFieldEnum = (typeof CustomerNoteScalarFieldEnum)[keyof typeof CustomerNoteScalarFieldEnum]


  export const CustomerPromotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    discountValue: 'discountValue',
    isPercentage: 'isPercentage',
    code: 'code',
    minimumPurchase: 'minimumPurchase',
    programId: 'programId',
    requiredLoyaltyTier: 'requiredLoyaltyTier',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    usageLimit: 'usageLimit',
    usageCount: 'usageCount',
    applicableProducts: 'applicableProducts',
    applicableCategories: 'applicableCategories',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerPromotionScalarFieldEnum = (typeof CustomerPromotionScalarFieldEnum)[keyof typeof CustomerPromotionScalarFieldEnum]


  export const CustomerToGroupScalarFieldEnum: {
    customerId: 'customerId',
    groupId: 'groupId',
    createdAt: 'createdAt'
  };

  export type CustomerToGroupScalarFieldEnum = (typeof CustomerToGroupScalarFieldEnum)[keyof typeof CustomerToGroupScalarFieldEnum]


  export const LoyaltyProgramRuleScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    name: 'name',
    description: 'description',
    type: 'type',
    conditions: 'conditions',
    pointsAwarded: 'pointsAwarded',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyProgramRuleScalarFieldEnum = (typeof LoyaltyProgramRuleScalarFieldEnum)[keyof typeof LoyaltyProgramRuleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    relatedEntityId: 'relatedEntityId',
    relatedEntityType: 'relatedEntityType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    senderId: 'senderId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PromotionRedemptionScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    customerId: 'customerId',
    saleId: 'saleId',
    discountAmount: 'discountAmount',
    createdAt: 'createdAt'
  };

  export type PromotionRedemptionScalarFieldEnum = (typeof PromotionRedemptionScalarFieldEnum)[keyof typeof PromotionRedemptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'InventoryStatus'
   */
  export type EnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus'>
    


  /**
   * Reference to a field of type 'InventoryStatus[]'
   */
  export type ListEnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'TransferType'
   */
  export type EnumTransferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferType'>
    


  /**
   * Reference to a field of type 'TransferType[]'
   */
  export type ListEnumTransferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferType[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'LoyaltyTier'
   */
  export type EnumLoyaltyTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTier'>
    


  /**
   * Reference to a field of type 'LoyaltyTier[]'
   */
  export type ListEnumLoyaltyTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTier[]'>
    


  /**
   * Reference to a field of type 'LoyaltyTransactionType'
   */
  export type EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType'>
    


  /**
   * Reference to a field of type 'LoyaltyTransactionType[]'
   */
  export type ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'AuditItemStatus'
   */
  export type EnumAuditItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditItemStatus'>
    


  /**
   * Reference to a field of type 'AuditItemStatus[]'
   */
  export type ListEnumAuditItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditItemStatus[]'>
    


  /**
   * Reference to a field of type 'PromotionType'
   */
  export type EnumPromotionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromotionType'>
    


  /**
   * Reference to a field of type 'PromotionType[]'
   */
  export type ListEnumPromotionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromotionType[]'>
    


  /**
   * Reference to a field of type 'LoyaltyRuleType'
   */
  export type EnumLoyaltyRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyRuleType'>
    


  /**
   * Reference to a field of type 'LoyaltyRuleType[]'
   */
  export type ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyRuleType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    createdAudits?: AuditListRelationFilter
    auditAssignments?: AuditAssignmentListRelationFilter
    CustomerNote?: CustomerNoteListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    receivedNotifications?: NotificationListRelationFilter
    Product_Product_createdByIdToUser?: ProductListRelationFilter
    Product_Product_updatedByIdToUser?: ProductListRelationFilter
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderListRelationFilter
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderListRelationFilter
    createdSales?: SaleListRelationFilter
    sessions?: SessionListRelationFilter
    storeStaff?: XOR<StoreStaffNullableScalarRelationFilter, StoreStaffWhereInput> | null
    Supplier_Supplier_createdByIdToUser?: SupplierListRelationFilter
    Supplier_Supplier_updatedByIdToUser?: SupplierListRelationFilter
    Transfer_Transfer_approvedByIdToUser?: TransferListRelationFilter
    Transfer_Transfer_createdByIdToUser?: TransferListRelationFilter
    Transfer_Transfer_receivedByIdToUser?: TransferListRelationFilter
    warehouseStaff?: XOR<WarehouseStaffNullableScalarRelationFilter, WarehouseStaffWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    createdAudits?: AuditOrderByRelationAggregateInput
    auditAssignments?: AuditAssignmentOrderByRelationAggregateInput
    CustomerNote?: CustomerNoteOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    receivedNotifications?: NotificationOrderByRelationAggregateInput
    Product_Product_createdByIdToUser?: ProductOrderByRelationAggregateInput
    Product_Product_updatedByIdToUser?: ProductOrderByRelationAggregateInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderOrderByRelationAggregateInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderOrderByRelationAggregateInput
    createdSales?: SaleOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    storeStaff?: StoreStaffOrderByWithRelationInput
    Supplier_Supplier_createdByIdToUser?: SupplierOrderByRelationAggregateInput
    Supplier_Supplier_updatedByIdToUser?: SupplierOrderByRelationAggregateInput
    Transfer_Transfer_approvedByIdToUser?: TransferOrderByRelationAggregateInput
    Transfer_Transfer_createdByIdToUser?: TransferOrderByRelationAggregateInput
    Transfer_Transfer_receivedByIdToUser?: TransferOrderByRelationAggregateInput
    warehouseStaff?: WarehouseStaffOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    createdAudits?: AuditListRelationFilter
    auditAssignments?: AuditAssignmentListRelationFilter
    CustomerNote?: CustomerNoteListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    receivedNotifications?: NotificationListRelationFilter
    Product_Product_createdByIdToUser?: ProductListRelationFilter
    Product_Product_updatedByIdToUser?: ProductListRelationFilter
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderListRelationFilter
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderListRelationFilter
    createdSales?: SaleListRelationFilter
    sessions?: SessionListRelationFilter
    storeStaff?: XOR<StoreStaffNullableScalarRelationFilter, StoreStaffWhereInput> | null
    Supplier_Supplier_createdByIdToUser?: SupplierListRelationFilter
    Supplier_Supplier_updatedByIdToUser?: SupplierListRelationFilter
    Transfer_Transfer_approvedByIdToUser?: TransferListRelationFilter
    Transfer_Transfer_createdByIdToUser?: TransferListRelationFilter
    Transfer_Transfer_receivedByIdToUser?: TransferListRelationFilter
    warehouseStaff?: XOR<WarehouseStaffNullableScalarRelationFilter, WarehouseStaffWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    audits?: AuditListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferListRelationFilter
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferListRelationFilter
    staff?: WarehouseStaffListRelationFilter
    zones?: WarehouseZoneListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audits?: AuditOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferOrderByRelationAggregateInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferOrderByRelationAggregateInput
    staff?: WarehouseStaffOrderByRelationAggregateInput
    zones?: WarehouseZoneOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    audits?: AuditListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferListRelationFilter
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferListRelationFilter
    staff?: WarehouseStaffListRelationFilter
    zones?: WarehouseZoneListRelationFilter
  }, "id" | "code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    code?: StringWithAggregatesFilter<"Warehouse"> | string
    address?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    email?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    isActive?: BoolWithAggregatesFilter<"Warehouse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type WarehouseZoneWhereInput = {
    AND?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    OR?: WarehouseZoneWhereInput[]
    NOT?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    id?: StringFilter<"WarehouseZone"> | string
    name?: StringFilter<"WarehouseZone"> | string
    code?: StringFilter<"WarehouseZone"> | string
    warehouseId?: StringFilter<"WarehouseZone"> | string
    description?: StringNullableFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    aisles?: WarehouseAisleListRelationFilter
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type WarehouseZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aisles?: WarehouseAisleOrderByRelationAggregateInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type WarehouseZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    warehouseId_code?: WarehouseZoneWarehouseIdCodeCompoundUniqueInput
    AND?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    OR?: WarehouseZoneWhereInput[]
    NOT?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    name?: StringFilter<"WarehouseZone"> | string
    code?: StringFilter<"WarehouseZone"> | string
    warehouseId?: StringFilter<"WarehouseZone"> | string
    description?: StringNullableFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    aisles?: WarehouseAisleListRelationFilter
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "id" | "warehouseId_code">

  export type WarehouseZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseZoneCountOrderByAggregateInput
    _max?: WarehouseZoneMaxOrderByAggregateInput
    _min?: WarehouseZoneMinOrderByAggregateInput
  }

  export type WarehouseZoneScalarWhereWithAggregatesInput = {
    AND?: WarehouseZoneScalarWhereWithAggregatesInput | WarehouseZoneScalarWhereWithAggregatesInput[]
    OR?: WarehouseZoneScalarWhereWithAggregatesInput[]
    NOT?: WarehouseZoneScalarWhereWithAggregatesInput | WarehouseZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseZone"> | string
    name?: StringWithAggregatesFilter<"WarehouseZone"> | string
    code?: StringWithAggregatesFilter<"WarehouseZone"> | string
    warehouseId?: StringWithAggregatesFilter<"WarehouseZone"> | string
    description?: StringNullableWithAggregatesFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseZone"> | Date | string
  }

  export type WarehouseAisleWhereInput = {
    AND?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    OR?: WarehouseAisleWhereInput[]
    NOT?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    id?: StringFilter<"WarehouseAisle"> | string
    name?: StringFilter<"WarehouseAisle"> | string
    code?: StringFilter<"WarehouseAisle"> | string
    zoneId?: StringFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    zone?: XOR<WarehouseZoneScalarRelationFilter, WarehouseZoneWhereInput>
    shelves?: WarehouseShelfListRelationFilter
  }

  export type WarehouseAisleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: WarehouseZoneOrderByWithRelationInput
    shelves?: WarehouseShelfOrderByRelationAggregateInput
  }

  export type WarehouseAisleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    zoneId_code?: WarehouseAisleZoneIdCodeCompoundUniqueInput
    AND?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    OR?: WarehouseAisleWhereInput[]
    NOT?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    name?: StringFilter<"WarehouseAisle"> | string
    code?: StringFilter<"WarehouseAisle"> | string
    zoneId?: StringFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    zone?: XOR<WarehouseZoneScalarRelationFilter, WarehouseZoneWhereInput>
    shelves?: WarehouseShelfListRelationFilter
  }, "id" | "zoneId_code">

  export type WarehouseAisleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseAisleCountOrderByAggregateInput
    _max?: WarehouseAisleMaxOrderByAggregateInput
    _min?: WarehouseAisleMinOrderByAggregateInput
  }

  export type WarehouseAisleScalarWhereWithAggregatesInput = {
    AND?: WarehouseAisleScalarWhereWithAggregatesInput | WarehouseAisleScalarWhereWithAggregatesInput[]
    OR?: WarehouseAisleScalarWhereWithAggregatesInput[]
    NOT?: WarehouseAisleScalarWhereWithAggregatesInput | WarehouseAisleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    name?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    code?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    zoneId?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseAisle"> | Date | string
  }

  export type WarehouseShelfWhereInput = {
    AND?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    OR?: WarehouseShelfWhereInput[]
    NOT?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    id?: StringFilter<"WarehouseShelf"> | string
    name?: StringFilter<"WarehouseShelf"> | string
    code?: StringFilter<"WarehouseShelf"> | string
    aisleId?: StringFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    bins?: WarehouseBinListRelationFilter
    aisle?: XOR<WarehouseAisleScalarRelationFilter, WarehouseAisleWhereInput>
  }

  export type WarehouseShelfOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bins?: WarehouseBinOrderByRelationAggregateInput
    aisle?: WarehouseAisleOrderByWithRelationInput
  }

  export type WarehouseShelfWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    aisleId_code?: WarehouseShelfAisleIdCodeCompoundUniqueInput
    AND?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    OR?: WarehouseShelfWhereInput[]
    NOT?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    name?: StringFilter<"WarehouseShelf"> | string
    code?: StringFilter<"WarehouseShelf"> | string
    aisleId?: StringFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    bins?: WarehouseBinListRelationFilter
    aisle?: XOR<WarehouseAisleScalarRelationFilter, WarehouseAisleWhereInput>
  }, "id" | "aisleId_code">

  export type WarehouseShelfOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseShelfCountOrderByAggregateInput
    _max?: WarehouseShelfMaxOrderByAggregateInput
    _min?: WarehouseShelfMinOrderByAggregateInput
  }

  export type WarehouseShelfScalarWhereWithAggregatesInput = {
    AND?: WarehouseShelfScalarWhereWithAggregatesInput | WarehouseShelfScalarWhereWithAggregatesInput[]
    OR?: WarehouseShelfScalarWhereWithAggregatesInput[]
    NOT?: WarehouseShelfScalarWhereWithAggregatesInput | WarehouseShelfScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    name?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    code?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    aisleId?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseShelf"> | Date | string
  }

  export type WarehouseBinWhereInput = {
    AND?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    OR?: WarehouseBinWhereInput[]
    NOT?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    id?: StringFilter<"WarehouseBin"> | string
    name?: StringFilter<"WarehouseBin"> | string
    code?: StringFilter<"WarehouseBin"> | string
    shelfId?: StringFilter<"WarehouseBin"> | string
    capacity?: IntNullableFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    shelf?: XOR<WarehouseShelfScalarRelationFilter, WarehouseShelfWhereInput>
  }

  export type WarehouseBinOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    shelf?: WarehouseShelfOrderByWithRelationInput
  }

  export type WarehouseBinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shelfId_code?: WarehouseBinShelfIdCodeCompoundUniqueInput
    AND?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    OR?: WarehouseBinWhereInput[]
    NOT?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    name?: StringFilter<"WarehouseBin"> | string
    code?: StringFilter<"WarehouseBin"> | string
    shelfId?: StringFilter<"WarehouseBin"> | string
    capacity?: IntNullableFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    shelf?: XOR<WarehouseShelfScalarRelationFilter, WarehouseShelfWhereInput>
  }, "id" | "shelfId_code">

  export type WarehouseBinOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseBinCountOrderByAggregateInput
    _avg?: WarehouseBinAvgOrderByAggregateInput
    _max?: WarehouseBinMaxOrderByAggregateInput
    _min?: WarehouseBinMinOrderByAggregateInput
    _sum?: WarehouseBinSumOrderByAggregateInput
  }

  export type WarehouseBinScalarWhereWithAggregatesInput = {
    AND?: WarehouseBinScalarWhereWithAggregatesInput | WarehouseBinScalarWhereWithAggregatesInput[]
    OR?: WarehouseBinScalarWhereWithAggregatesInput[]
    NOT?: WarehouseBinScalarWhereWithAggregatesInput | WarehouseBinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseBin"> | string
    name?: StringWithAggregatesFilter<"WarehouseBin"> | string
    code?: StringWithAggregatesFilter<"WarehouseBin"> | string
    shelfId?: StringWithAggregatesFilter<"WarehouseBin"> | string
    capacity?: IntNullableWithAggregatesFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseBin"> | Date | string
  }

  export type WarehouseStaffWhereInput = {
    AND?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    OR?: WarehouseStaffWhereInput[]
    NOT?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    id?: StringFilter<"WarehouseStaff"> | string
    userId?: StringFilter<"WarehouseStaff"> | string
    warehouseId?: StringFilter<"WarehouseStaff"> | string
    position?: StringNullableFilter<"WarehouseStaff"> | string | null
    isManager?: BoolFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type WarehouseStaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type WarehouseStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    OR?: WarehouseStaffWhereInput[]
    NOT?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    warehouseId?: StringFilter<"WarehouseStaff"> | string
    position?: StringNullableFilter<"WarehouseStaff"> | string | null
    isManager?: BoolFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "id" | "userId">

  export type WarehouseStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseStaffCountOrderByAggregateInput
    _max?: WarehouseStaffMaxOrderByAggregateInput
    _min?: WarehouseStaffMinOrderByAggregateInput
  }

  export type WarehouseStaffScalarWhereWithAggregatesInput = {
    AND?: WarehouseStaffScalarWhereWithAggregatesInput | WarehouseStaffScalarWhereWithAggregatesInput[]
    OR?: WarehouseStaffScalarWhereWithAggregatesInput[]
    NOT?: WarehouseStaffScalarWhereWithAggregatesInput | WarehouseStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseStaff"> | string
    userId?: StringWithAggregatesFilter<"WarehouseStaff"> | string
    warehouseId?: StringWithAggregatesFilter<"WarehouseStaff"> | string
    position?: StringNullableWithAggregatesFilter<"WarehouseStaff"> | string | null
    isManager?: BoolWithAggregatesFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseStaff"> | Date | string
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    code?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    openingHours?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    sales?: SaleListRelationFilter
    staff?: StoreStaffListRelationFilter
    Transfer_Transfer_destinationStoreIdToStore?: TransferListRelationFilter
    Transfer_Transfer_sourceStoreIdToStore?: TransferListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    staff?: StoreStaffOrderByRelationAggregateInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferOrderByRelationAggregateInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferOrderByRelationAggregateInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    openingHours?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    sales?: SaleListRelationFilter
    staff?: StoreStaffListRelationFilter
    Transfer_Transfer_destinationStoreIdToStore?: TransferListRelationFilter
    Transfer_Transfer_sourceStoreIdToStore?: TransferListRelationFilter
  }, "id" | "code">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    code?: StringWithAggregatesFilter<"Store"> | string
    address?: StringNullableWithAggregatesFilter<"Store"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Store"> | string | null
    email?: StringNullableWithAggregatesFilter<"Store"> | string | null
    openingHours?: StringNullableWithAggregatesFilter<"Store"> | string | null
    isActive?: BoolWithAggregatesFilter<"Store"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type StoreStaffWhereInput = {
    AND?: StoreStaffWhereInput | StoreStaffWhereInput[]
    OR?: StoreStaffWhereInput[]
    NOT?: StoreStaffWhereInput | StoreStaffWhereInput[]
    id?: StringFilter<"StoreStaff"> | string
    userId?: StringFilter<"StoreStaff"> | string
    storeId?: StringFilter<"StoreStaff"> | string
    position?: StringNullableFilter<"StoreStaff"> | string | null
    isManager?: BoolFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStaff"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StoreStaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StoreStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StoreStaffWhereInput | StoreStaffWhereInput[]
    OR?: StoreStaffWhereInput[]
    NOT?: StoreStaffWhereInput | StoreStaffWhereInput[]
    storeId?: StringFilter<"StoreStaff"> | string
    position?: StringNullableFilter<"StoreStaff"> | string | null
    isManager?: BoolFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStaff"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type StoreStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreStaffCountOrderByAggregateInput
    _max?: StoreStaffMaxOrderByAggregateInput
    _min?: StoreStaffMinOrderByAggregateInput
  }

  export type StoreStaffScalarWhereWithAggregatesInput = {
    AND?: StoreStaffScalarWhereWithAggregatesInput | StoreStaffScalarWhereWithAggregatesInput[]
    OR?: StoreStaffScalarWhereWithAggregatesInput[]
    NOT?: StoreStaffScalarWhereWithAggregatesInput | StoreStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreStaff"> | string
    userId?: StringWithAggregatesFilter<"StoreStaff"> | string
    storeId?: StringWithAggregatesFilter<"StoreStaff"> | string
    position?: StringNullableWithAggregatesFilter<"StoreStaff"> | string | null
    isManager?: BoolWithAggregatesFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreStaff"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    state?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdById?: StringFilter<"Supplier"> | string
    updatedById?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    products?: ProductListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    User_Supplier_createdByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    User_Supplier_updatedByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    contracts?: SupplierContractListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    User_Supplier_createdByIdToUser?: UserOrderByWithRelationInput
    User_Supplier_updatedByIdToUser?: UserOrderByWithRelationInput
    contracts?: SupplierContractOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    state?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdById?: StringFilter<"Supplier"> | string
    updatedById?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    products?: ProductListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    User_Supplier_createdByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    User_Supplier_updatedByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    contracts?: SupplierContractListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    city?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    state?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    country?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdById?: StringWithAggregatesFilter<"Supplier"> | string
    updatedById?: StringWithAggregatesFilter<"Supplier"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type SupplierContractWhereInput = {
    AND?: SupplierContractWhereInput | SupplierContractWhereInput[]
    OR?: SupplierContractWhereInput[]
    NOT?: SupplierContractWhereInput | SupplierContractWhereInput[]
    id?: StringFilter<"SupplierContract"> | string
    supplierId?: StringFilter<"SupplierContract"> | string
    startDate?: DateTimeFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    terms?: StringNullableFilter<"SupplierContract"> | string | null
    attachments?: StringNullableFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierContract"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SupplierContractOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierContractWhereInput | SupplierContractWhereInput[]
    OR?: SupplierContractWhereInput[]
    NOT?: SupplierContractWhereInput | SupplierContractWhereInput[]
    supplierId?: StringFilter<"SupplierContract"> | string
    startDate?: DateTimeFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    terms?: StringNullableFilter<"SupplierContract"> | string | null
    attachments?: StringNullableFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierContract"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id">

  export type SupplierContractOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierContractCountOrderByAggregateInput
    _max?: SupplierContractMaxOrderByAggregateInput
    _min?: SupplierContractMinOrderByAggregateInput
  }

  export type SupplierContractScalarWhereWithAggregatesInput = {
    AND?: SupplierContractScalarWhereWithAggregatesInput | SupplierContractScalarWhereWithAggregatesInput[]
    OR?: SupplierContractScalarWhereWithAggregatesInput[]
    NOT?: SupplierContractScalarWhereWithAggregatesInput | SupplierContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplierContract"> | string
    supplierId?: StringWithAggregatesFilter<"SupplierContract"> | string
    startDate?: DateTimeWithAggregatesFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"SupplierContract"> | Date | string | null
    terms?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    attachments?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierContract"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    warehouseId?: StringFilter<"PurchaseOrder"> | string
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    updatedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    User_PurchaseOrder_createdByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    User_PurchaseOrder_updatedByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User_PurchaseOrder_createdByIdToUser?: UserOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    User_PurchaseOrder_updatedByIdToUser?: UserOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    supplierId?: StringFilter<"PurchaseOrder"> | string
    warehouseId?: StringFilter<"PurchaseOrder"> | string
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    updatedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    User_PurchaseOrder_createdByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    User_PurchaseOrder_updatedByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }, "id" | "orderNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    warehouseId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    deliveredDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    shipping?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    orderedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    description?: SortOrderInput | SortOrder
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    orderedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    description?: SortOrderInput | SortOrder
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    description?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    orderedQuantity?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    supplierId?: StringNullableFilter<"Product"> | string | null
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"Product"> | string
    minStockLevel?: IntFilter<"Product"> | number
    maxStockLevel?: IntNullableFilter<"Product"> | number | null
    reorderPoint?: IntFilter<"Product"> | number
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    taxRate?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdById?: StringFilter<"Product"> | string
    updatedById?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    auditItems?: AuditItemListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    User_Product_createdByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    User_Product_updatedByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    saleItems?: SaleItemListRelationFilter
    transferItems?: TransferItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unit?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrderInput | SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditItems?: AuditItemOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    User_Product_createdByIdToUser?: UserOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    User_Product_updatedByIdToUser?: UserOrderByWithRelationInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    transferItems?: TransferItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    supplierId?: StringNullableFilter<"Product"> | string | null
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"Product"> | string
    minStockLevel?: IntFilter<"Product"> | number
    maxStockLevel?: IntNullableFilter<"Product"> | number | null
    reorderPoint?: IntFilter<"Product"> | number
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    taxRate?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdById?: StringFilter<"Product"> | string
    updatedById?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    auditItems?: AuditItemListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    User_Product_createdByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    User_Product_updatedByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    saleItems?: SaleItemListRelationFilter
    transferItems?: TransferItemListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unit?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrderInput | SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    supplierId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    costPrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"Product"> | string
    minStockLevel?: IntWithAggregatesFilter<"Product"> | number
    maxStockLevel?: IntNullableWithAggregatesFilter<"Product"> | number | null
    reorderPoint?: IntWithAggregatesFilter<"Product"> | number
    weight?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: StringNullableWithAggregatesFilter<"Product"> | string | null
    taxRate?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdById?: StringWithAggregatesFilter<"Product"> | string
    updatedById?: StringWithAggregatesFilter<"Product"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    Category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    other_Category?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Category?: CategoryOrderByWithRelationInput
    other_Category?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    Category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    other_Category?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    productId?: StringFilter<"InventoryItem"> | string
    warehouseId?: StringNullableFilter<"InventoryItem"> | string | null
    storeId?: StringNullableFilter<"InventoryItem"> | string | null
    binId?: StringNullableFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQuantity?: IntFilter<"InventoryItem"> | number
    costPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFilter<"InventoryItem"> | $Enums.InventoryStatus
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    auditItems?: AuditItemListRelationFilter
    bin?: XOR<WarehouseBinNullableScalarRelationFilter, WarehouseBinWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    saleItems?: SaleItemListRelationFilter
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemListRelationFilter
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    binId?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditItems?: AuditItemOrderByRelationAggregateInput
    bin?: WarehouseBinOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemOrderByRelationAggregateInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_warehouseId_storeId_batchNumber_lotNumber?: InventoryItemProductIdWarehouseIdStoreIdBatchNumberLotNumberCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    productId?: StringFilter<"InventoryItem"> | string
    warehouseId?: StringNullableFilter<"InventoryItem"> | string | null
    storeId?: StringNullableFilter<"InventoryItem"> | string | null
    binId?: StringNullableFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQuantity?: IntFilter<"InventoryItem"> | number
    costPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFilter<"InventoryItem"> | $Enums.InventoryStatus
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    auditItems?: AuditItemListRelationFilter
    bin?: XOR<WarehouseBinNullableScalarRelationFilter, WarehouseBinWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    saleItems?: SaleItemListRelationFilter
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemListRelationFilter
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemListRelationFilter
  }, "id" | "productId_warehouseId_storeId_batchNumber_lotNumber">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    binId?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    productId?: StringWithAggregatesFilter<"InventoryItem"> | string
    warehouseId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    storeId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    binId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    reservedQuantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    costPrice?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusWithAggregatesFilter<"InventoryItem"> | $Enums.InventoryStatus
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    receiptNumber?: StringFilter<"Sale"> | string
    storeId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    createdById?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    loyaltyPointsRedeemed?: IntFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    LoyaltyTransaction?: LoyaltyTransactionListRelationFilter
    PromotionRedemption?: PromotionRedemptionListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    items?: SaleItemListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    LoyaltyTransaction?: LoyaltyTransactionOrderByRelationAggregateInput
    PromotionRedemption?: PromotionRedemptionOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    items?: SaleItemOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNumber?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    storeId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    createdById?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    loyaltyPointsRedeemed?: IntFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    LoyaltyTransaction?: LoyaltyTransactionListRelationFilter
    PromotionRedemption?: PromotionRedemptionListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    items?: SaleItemListRelationFilter
  }, "id" | "receiptNumber">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    receiptNumber?: StringWithAggregatesFilter<"Sale"> | string
    storeId?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdById?: StringWithAggregatesFilter<"Sale"> | string
    saleDate?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    subtotal?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntWithAggregatesFilter<"Sale"> | number
    loyaltyPointsRedeemed?: IntWithAggregatesFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type SaleItemWhereInput = {
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    inventoryItemId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeFilter<"SaleItem"> | Date | string
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }

  export type SaleItemOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItem?: InventoryItemOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    sale?: SaleOrderByWithRelationInput
  }

  export type SaleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    inventoryItemId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeFilter<"SaleItem"> | Date | string
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }, "id">

  export type SaleItemOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleItemCountOrderByAggregateInput
    _avg?: SaleItemAvgOrderByAggregateInput
    _max?: SaleItemMaxOrderByAggregateInput
    _min?: SaleItemMinOrderByAggregateInput
    _sum?: SaleItemSumOrderByAggregateInput
  }

  export type SaleItemScalarWhereWithAggregatesInput = {
    AND?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    OR?: SaleItemScalarWhereWithAggregatesInput[]
    NOT?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleItem"> | string
    saleId?: StringWithAggregatesFilter<"SaleItem"> | string
    productId?: StringWithAggregatesFilter<"SaleItem"> | string
    inventoryItemId?: StringWithAggregatesFilter<"SaleItem"> | string
    quantity?: IntWithAggregatesFilter<"SaleItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleItem"> | Date | string
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    referenceNumber?: StringFilter<"Transfer"> | string
    type?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    sourceWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    destinationWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    sourceStoreId?: StringNullableFilter<"Transfer"> | string | null
    destinationStoreId?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    requestedDate?: DateTimeFilter<"Transfer"> | Date | string
    approvedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    shippedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdById?: StringFilter<"Transfer"> | string
    approvedById?: StringNullableFilter<"Transfer"> | string | null
    receivedById?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    User_Transfer_approvedByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Transfer_createdByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    Store_Transfer_destinationStoreIdToStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    User_Transfer_receivedByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Store_Transfer_sourceStoreIdToStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    items?: TransferItemListRelationFilter
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    sourceWarehouseId?: SortOrderInput | SortOrder
    destinationWarehouseId?: SortOrderInput | SortOrder
    sourceStoreId?: SortOrderInput | SortOrder
    destinationStoreId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrderInput | SortOrder
    shippedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    receivedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User_Transfer_approvedByIdToUser?: UserOrderByWithRelationInput
    User_Transfer_createdByIdToUser?: UserOrderByWithRelationInput
    Store_Transfer_destinationStoreIdToStore?: StoreOrderByWithRelationInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseOrderByWithRelationInput
    User_Transfer_receivedByIdToUser?: UserOrderByWithRelationInput
    Store_Transfer_sourceStoreIdToStore?: StoreOrderByWithRelationInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseOrderByWithRelationInput
    items?: TransferItemOrderByRelationAggregateInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    type?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    sourceWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    destinationWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    sourceStoreId?: StringNullableFilter<"Transfer"> | string | null
    destinationStoreId?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    requestedDate?: DateTimeFilter<"Transfer"> | Date | string
    approvedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    shippedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdById?: StringFilter<"Transfer"> | string
    approvedById?: StringNullableFilter<"Transfer"> | string | null
    receivedById?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    User_Transfer_approvedByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Transfer_createdByIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    Store_Transfer_destinationStoreIdToStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    User_Transfer_receivedByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Store_Transfer_sourceStoreIdToStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    items?: TransferItemListRelationFilter
  }, "id" | "referenceNumber">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    sourceWarehouseId?: SortOrderInput | SortOrder
    destinationWarehouseId?: SortOrderInput | SortOrder
    sourceStoreId?: SortOrderInput | SortOrder
    destinationStoreId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrderInput | SortOrder
    shippedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    receivedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    referenceNumber?: StringWithAggregatesFilter<"Transfer"> | string
    type?: EnumTransferTypeWithAggregatesFilter<"Transfer"> | $Enums.TransferType
    sourceWarehouseId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    destinationWarehouseId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    sourceStoreId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    destinationStoreId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    status?: EnumTransferStatusWithAggregatesFilter<"Transfer"> | $Enums.TransferStatus
    requestedDate?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    approvedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    shippedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdById?: StringWithAggregatesFilter<"Transfer"> | string
    approvedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    receivedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type TransferItemWhereInput = {
    AND?: TransferItemWhereInput | TransferItemWhereInput[]
    OR?: TransferItemWhereInput[]
    NOT?: TransferItemWhereInput | TransferItemWhereInput[]
    id?: StringFilter<"TransferItem"> | string
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    sourceInventoryId?: StringNullableFilter<"TransferItem"> | string | null
    destinationInventoryId?: StringNullableFilter<"TransferItem"> | string | null
    requestedQuantity?: IntFilter<"TransferItem"> | number
    approvedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    shippedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    receivedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    sourceCostPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"TransferItem"> | string | null
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: XOR<InventoryItemNullableScalarRelationFilter, InventoryItemWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: XOR<InventoryItemNullableScalarRelationFilter, InventoryItemWhereInput> | null
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
  }

  export type TransferItemOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    sourceInventoryId?: SortOrderInput | SortOrder
    destinationInventoryId?: SortOrderInput | SortOrder
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrderInput | SortOrder
    shippedQuantity?: SortOrderInput | SortOrder
    receivedQuantity?: SortOrderInput | SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemOrderByWithRelationInput
    transfer?: TransferOrderByWithRelationInput
  }

  export type TransferItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferItemWhereInput | TransferItemWhereInput[]
    OR?: TransferItemWhereInput[]
    NOT?: TransferItemWhereInput | TransferItemWhereInput[]
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    sourceInventoryId?: StringNullableFilter<"TransferItem"> | string | null
    destinationInventoryId?: StringNullableFilter<"TransferItem"> | string | null
    requestedQuantity?: IntFilter<"TransferItem"> | number
    approvedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    shippedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    receivedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    sourceCostPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"TransferItem"> | string | null
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: XOR<InventoryItemNullableScalarRelationFilter, InventoryItemWhereInput> | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: XOR<InventoryItemNullableScalarRelationFilter, InventoryItemWhereInput> | null
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
  }, "id">

  export type TransferItemOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    sourceInventoryId?: SortOrderInput | SortOrder
    destinationInventoryId?: SortOrderInput | SortOrder
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrderInput | SortOrder
    shippedQuantity?: SortOrderInput | SortOrder
    receivedQuantity?: SortOrderInput | SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferItemCountOrderByAggregateInput
    _avg?: TransferItemAvgOrderByAggregateInput
    _max?: TransferItemMaxOrderByAggregateInput
    _min?: TransferItemMinOrderByAggregateInput
    _sum?: TransferItemSumOrderByAggregateInput
  }

  export type TransferItemScalarWhereWithAggregatesInput = {
    AND?: TransferItemScalarWhereWithAggregatesInput | TransferItemScalarWhereWithAggregatesInput[]
    OR?: TransferItemScalarWhereWithAggregatesInput[]
    NOT?: TransferItemScalarWhereWithAggregatesInput | TransferItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferItem"> | string
    transferId?: StringWithAggregatesFilter<"TransferItem"> | string
    productId?: StringWithAggregatesFilter<"TransferItem"> | string
    sourceInventoryId?: StringNullableWithAggregatesFilter<"TransferItem"> | string | null
    destinationInventoryId?: StringNullableWithAggregatesFilter<"TransferItem"> | string | null
    requestedQuantity?: IntWithAggregatesFilter<"TransferItem"> | number
    approvedQuantity?: IntNullableWithAggregatesFilter<"TransferItem"> | number | null
    shippedQuantity?: IntNullableWithAggregatesFilter<"TransferItem"> | number | null
    receivedQuantity?: IntNullableWithAggregatesFilter<"TransferItem"> | number | null
    sourceCostPrice?: DecimalWithAggregatesFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalWithAggregatesFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalWithAggregatesFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalWithAggregatesFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalWithAggregatesFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalWithAggregatesFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"TransferItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferItem"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    birthDate?: DateTimeNullableFilter<"Customer"> | Date | string | null
    gender?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"Customer"> | $Enums.LoyaltyTier
    notes?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    customerAddresses?: CustomerAddressListRelationFilter
    CustomerNote?: CustomerNoteListRelationFilter
    CustomerToGroup?: CustomerToGroupListRelationFilter
    loyaltyTransactions?: LoyaltyTransactionListRelationFilter
    PromotionRedemption?: PromotionRedemptionListRelationFilter
    sales?: SaleListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerAddresses?: CustomerAddressOrderByRelationAggregateInput
    CustomerNote?: CustomerNoteOrderByRelationAggregateInput
    CustomerToGroup?: CustomerToGroupOrderByRelationAggregateInput
    loyaltyTransactions?: LoyaltyTransactionOrderByRelationAggregateInput
    PromotionRedemption?: PromotionRedemptionOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    birthDate?: DateTimeNullableFilter<"Customer"> | Date | string | null
    gender?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"Customer"> | $Enums.LoyaltyTier
    notes?: StringNullableFilter<"Customer"> | string | null
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    customerAddresses?: CustomerAddressListRelationFilter
    CustomerNote?: CustomerNoteListRelationFilter
    CustomerToGroup?: CustomerToGroupListRelationFilter
    loyaltyTransactions?: LoyaltyTransactionListRelationFilter
    PromotionRedemption?: PromotionRedemptionListRelationFilter
    sales?: SaleListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    loyaltyTier?: EnumLoyaltyTierWithAggregatesFilter<"Customer"> | $Enums.LoyaltyTier
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    addressType?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    phone?: StringNullableFilter<"CustomerAddress"> | string | null
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressType?: SortOrder
    isDefault?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customerId?: StringFilter<"CustomerAddress"> | string
    addressType?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    phone?: StringNullableFilter<"CustomerAddress"> | string | null
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressType?: SortOrder
    isDefault?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    customerId?: StringWithAggregatesFilter<"CustomerAddress"> | string
    addressType?: StringWithAggregatesFilter<"CustomerAddress"> | string
    isDefault?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    addressLine1?: StringWithAggregatesFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    state?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    postalCode?: StringWithAggregatesFilter<"CustomerAddress"> | string
    country?: StringWithAggregatesFilter<"CustomerAddress"> | string
    phone?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
  }

  export type LoyaltyProgramWhereInput = {
    AND?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    OR?: LoyaltyProgramWhereInput[]
    NOT?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    id?: StringFilter<"LoyaltyProgram"> | string
    name?: StringFilter<"LoyaltyProgram"> | string
    description?: StringNullableFilter<"LoyaltyProgram"> | string | null
    pointsPerCurrency?: DecimalFilter<"LoyaltyProgram"> | Decimal | DecimalJsLike | number | string
    minimumPurchase?: DecimalNullableFilter<"LoyaltyProgram"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"LoyaltyProgram"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    CustomerPromotion?: CustomerPromotionListRelationFilter
    LoyaltyProgramRule?: LoyaltyProgramRuleListRelationFilter
    tiers?: LoyaltyProgramTierListRelationFilter
    transactions?: LoyaltyTransactionListRelationFilter
  }

  export type LoyaltyProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CustomerPromotion?: CustomerPromotionOrderByRelationAggregateInput
    LoyaltyProgramRule?: LoyaltyProgramRuleOrderByRelationAggregateInput
    tiers?: LoyaltyProgramTierOrderByRelationAggregateInput
    transactions?: LoyaltyTransactionOrderByRelationAggregateInput
  }

  export type LoyaltyProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    OR?: LoyaltyProgramWhereInput[]
    NOT?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    name?: StringFilter<"LoyaltyProgram"> | string
    description?: StringNullableFilter<"LoyaltyProgram"> | string | null
    pointsPerCurrency?: DecimalFilter<"LoyaltyProgram"> | Decimal | DecimalJsLike | number | string
    minimumPurchase?: DecimalNullableFilter<"LoyaltyProgram"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"LoyaltyProgram"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    CustomerPromotion?: CustomerPromotionListRelationFilter
    LoyaltyProgramRule?: LoyaltyProgramRuleListRelationFilter
    tiers?: LoyaltyProgramTierListRelationFilter
    transactions?: LoyaltyTransactionListRelationFilter
  }, "id">

  export type LoyaltyProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyProgramCountOrderByAggregateInput
    _avg?: LoyaltyProgramAvgOrderByAggregateInput
    _max?: LoyaltyProgramMaxOrderByAggregateInput
    _min?: LoyaltyProgramMinOrderByAggregateInput
    _sum?: LoyaltyProgramSumOrderByAggregateInput
  }

  export type LoyaltyProgramScalarWhereWithAggregatesInput = {
    AND?: LoyaltyProgramScalarWhereWithAggregatesInput | LoyaltyProgramScalarWhereWithAggregatesInput[]
    OR?: LoyaltyProgramScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyProgramScalarWhereWithAggregatesInput | LoyaltyProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyProgram"> | string
    name?: StringWithAggregatesFilter<"LoyaltyProgram"> | string
    description?: StringNullableWithAggregatesFilter<"LoyaltyProgram"> | string | null
    pointsPerCurrency?: DecimalWithAggregatesFilter<"LoyaltyProgram"> | Decimal | DecimalJsLike | number | string
    minimumPurchase?: DecimalNullableWithAggregatesFilter<"LoyaltyProgram"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"LoyaltyProgram"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyProgram"> | Date | string
  }

  export type LoyaltyProgramTierWhereInput = {
    AND?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    OR?: LoyaltyProgramTierWhereInput[]
    NOT?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    id?: StringFilter<"LoyaltyProgramTier"> | string
    programId?: StringFilter<"LoyaltyProgramTier"> | string
    name?: StringFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: DecimalFilter<"LoyaltyProgramTier"> | Decimal | DecimalJsLike | number | string
    benefits?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }

  export type LoyaltyProgramTierOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: LoyaltyProgramOrderByWithRelationInput
  }

  export type LoyaltyProgramTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    OR?: LoyaltyProgramTierWhereInput[]
    NOT?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    programId?: StringFilter<"LoyaltyProgramTier"> | string
    name?: StringFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: DecimalFilter<"LoyaltyProgramTier"> | Decimal | DecimalJsLike | number | string
    benefits?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }, "id">

  export type LoyaltyProgramTierOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyProgramTierCountOrderByAggregateInput
    _avg?: LoyaltyProgramTierAvgOrderByAggregateInput
    _max?: LoyaltyProgramTierMaxOrderByAggregateInput
    _min?: LoyaltyProgramTierMinOrderByAggregateInput
    _sum?: LoyaltyProgramTierSumOrderByAggregateInput
  }

  export type LoyaltyProgramTierScalarWhereWithAggregatesInput = {
    AND?: LoyaltyProgramTierScalarWhereWithAggregatesInput | LoyaltyProgramTierScalarWhereWithAggregatesInput[]
    OR?: LoyaltyProgramTierScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyProgramTierScalarWhereWithAggregatesInput | LoyaltyProgramTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyProgramTier"> | string
    programId?: StringWithAggregatesFilter<"LoyaltyProgramTier"> | string
    name?: StringWithAggregatesFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableWithAggregatesFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntWithAggregatesFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: DecimalWithAggregatesFilter<"LoyaltyProgramTier"> | Decimal | DecimalJsLike | number | string
    benefits?: StringNullableWithAggregatesFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyProgramTier"> | Date | string
  }

  export type LoyaltyTransactionWhereInput = {
    AND?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    OR?: LoyaltyTransactionWhereInput[]
    NOT?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    id?: StringFilter<"LoyaltyTransaction"> | string
    customerId?: StringFilter<"LoyaltyTransaction"> | string
    programId?: StringFilter<"LoyaltyTransaction"> | string
    points?: IntFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    expiryDate?: DateTimeNullableFilter<"LoyaltyTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
    Sale?: XOR<SaleNullableScalarRelationFilter, SaleWhereInput> | null
  }

  export type LoyaltyTransactionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    program?: LoyaltyProgramOrderByWithRelationInput
    Sale?: SaleOrderByWithRelationInput
  }

  export type LoyaltyTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    OR?: LoyaltyTransactionWhereInput[]
    NOT?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    customerId?: StringFilter<"LoyaltyTransaction"> | string
    programId?: StringFilter<"LoyaltyTransaction"> | string
    points?: IntFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    expiryDate?: DateTimeNullableFilter<"LoyaltyTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
    Sale?: XOR<SaleNullableScalarRelationFilter, SaleWhereInput> | null
  }, "id">

  export type LoyaltyTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LoyaltyTransactionCountOrderByAggregateInput
    _avg?: LoyaltyTransactionAvgOrderByAggregateInput
    _max?: LoyaltyTransactionMaxOrderByAggregateInput
    _min?: LoyaltyTransactionMinOrderByAggregateInput
    _sum?: LoyaltyTransactionSumOrderByAggregateInput
  }

  export type LoyaltyTransactionScalarWhereWithAggregatesInput = {
    AND?: LoyaltyTransactionScalarWhereWithAggregatesInput | LoyaltyTransactionScalarWhereWithAggregatesInput[]
    OR?: LoyaltyTransactionScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyTransactionScalarWhereWithAggregatesInput | LoyaltyTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyTransaction"> | string
    customerId?: StringWithAggregatesFilter<"LoyaltyTransaction"> | string
    programId?: StringWithAggregatesFilter<"LoyaltyTransaction"> | string
    points?: IntWithAggregatesFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeWithAggregatesFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableWithAggregatesFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"LoyaltyTransaction"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"LoyaltyTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyTransaction"> | Date | string
  }

  export type AuditWhereInput = {
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    id?: StringFilter<"Audit"> | string
    referenceNumber?: StringFilter<"Audit"> | string
    warehouseId?: StringFilter<"Audit"> | string
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    notes?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    assignments?: AuditAssignmentListRelationFilter
    items?: AuditItemListRelationFilter
  }

  export type AuditOrderByWithRelationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    assignments?: AuditAssignmentOrderByRelationAggregateInput
    items?: AuditItemOrderByRelationAggregateInput
  }

  export type AuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    warehouseId?: StringFilter<"Audit"> | string
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    notes?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    assignments?: AuditAssignmentListRelationFilter
    items?: AuditItemListRelationFilter
  }, "id" | "referenceNumber">

  export type AuditOrderByWithAggregationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditCountOrderByAggregateInput
    _max?: AuditMaxOrderByAggregateInput
    _min?: AuditMinOrderByAggregateInput
  }

  export type AuditScalarWhereWithAggregatesInput = {
    AND?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    OR?: AuditScalarWhereWithAggregatesInput[]
    NOT?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Audit"> | string
    referenceNumber?: StringWithAggregatesFilter<"Audit"> | string
    warehouseId?: StringWithAggregatesFilter<"Audit"> | string
    status?: EnumAuditStatusWithAggregatesFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Audit"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    createdById?: StringWithAggregatesFilter<"Audit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
  }

  export type AuditItemWhereInput = {
    AND?: AuditItemWhereInput | AuditItemWhereInput[]
    OR?: AuditItemWhereInput[]
    NOT?: AuditItemWhereInput | AuditItemWhereInput[]
    id?: StringFilter<"AuditItem"> | string
    auditId?: StringFilter<"AuditItem"> | string
    productId?: StringFilter<"AuditItem"> | string
    inventoryItemId?: StringFilter<"AuditItem"> | string
    expectedQuantity?: IntFilter<"AuditItem"> | number
    actualQuantity?: IntNullableFilter<"AuditItem"> | number | null
    variance?: IntNullableFilter<"AuditItem"> | number | null
    notes?: StringNullableFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusFilter<"AuditItem"> | $Enums.AuditItemStatus
    createdAt?: DateTimeFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type AuditItemOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type AuditItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditItemWhereInput | AuditItemWhereInput[]
    OR?: AuditItemWhereInput[]
    NOT?: AuditItemWhereInput | AuditItemWhereInput[]
    auditId?: StringFilter<"AuditItem"> | string
    productId?: StringFilter<"AuditItem"> | string
    inventoryItemId?: StringFilter<"AuditItem"> | string
    expectedQuantity?: IntFilter<"AuditItem"> | number
    actualQuantity?: IntNullableFilter<"AuditItem"> | number | null
    variance?: IntNullableFilter<"AuditItem"> | number | null
    notes?: StringNullableFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusFilter<"AuditItem"> | $Enums.AuditItemStatus
    createdAt?: DateTimeFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type AuditItemOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditItemCountOrderByAggregateInput
    _avg?: AuditItemAvgOrderByAggregateInput
    _max?: AuditItemMaxOrderByAggregateInput
    _min?: AuditItemMinOrderByAggregateInput
    _sum?: AuditItemSumOrderByAggregateInput
  }

  export type AuditItemScalarWhereWithAggregatesInput = {
    AND?: AuditItemScalarWhereWithAggregatesInput | AuditItemScalarWhereWithAggregatesInput[]
    OR?: AuditItemScalarWhereWithAggregatesInput[]
    NOT?: AuditItemScalarWhereWithAggregatesInput | AuditItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditItem"> | string
    auditId?: StringWithAggregatesFilter<"AuditItem"> | string
    productId?: StringWithAggregatesFilter<"AuditItem"> | string
    inventoryItemId?: StringWithAggregatesFilter<"AuditItem"> | string
    expectedQuantity?: IntWithAggregatesFilter<"AuditItem"> | number
    actualQuantity?: IntNullableWithAggregatesFilter<"AuditItem"> | number | null
    variance?: IntNullableWithAggregatesFilter<"AuditItem"> | number | null
    notes?: StringNullableWithAggregatesFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusWithAggregatesFilter<"AuditItem"> | $Enums.AuditItemStatus
    createdAt?: DateTimeWithAggregatesFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditItem"> | Date | string
  }

  export type AuditAssignmentWhereInput = {
    AND?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    OR?: AuditAssignmentWhereInput[]
    NOT?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    id?: StringFilter<"AuditAssignment"> | string
    auditId?: StringFilter<"AuditAssignment"> | string
    userId?: StringFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedAisles?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedShelves?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedBins?: StringNullableFilter<"AuditAssignment"> | string | null
    createdAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrderInput | SortOrder
    assignedAisles?: SortOrderInput | SortOrder
    assignedShelves?: SortOrderInput | SortOrder
    assignedBins?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    OR?: AuditAssignmentWhereInput[]
    NOT?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    auditId?: StringFilter<"AuditAssignment"> | string
    userId?: StringFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedAisles?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedShelves?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedBins?: StringNullableFilter<"AuditAssignment"> | string | null
    createdAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrderInput | SortOrder
    assignedAisles?: SortOrderInput | SortOrder
    assignedShelves?: SortOrderInput | SortOrder
    assignedBins?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditAssignmentCountOrderByAggregateInput
    _max?: AuditAssignmentMaxOrderByAggregateInput
    _min?: AuditAssignmentMinOrderByAggregateInput
  }

  export type AuditAssignmentScalarWhereWithAggregatesInput = {
    AND?: AuditAssignmentScalarWhereWithAggregatesInput | AuditAssignmentScalarWhereWithAggregatesInput[]
    OR?: AuditAssignmentScalarWhereWithAggregatesInput[]
    NOT?: AuditAssignmentScalarWhereWithAggregatesInput | AuditAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditAssignment"> | string
    auditId?: StringWithAggregatesFilter<"AuditAssignment"> | string
    userId?: StringWithAggregatesFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableWithAggregatesFilter<"AuditAssignment"> | string | null
    assignedAisles?: StringNullableWithAggregatesFilter<"AuditAssignment"> | string | null
    assignedShelves?: StringNullableWithAggregatesFilter<"AuditAssignment"> | string | null
    assignedBins?: StringNullableWithAggregatesFilter<"AuditAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditAssignment"> | Date | string
  }

  export type CustomerGroupWhereInput = {
    AND?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    OR?: CustomerGroupWhereInput[]
    NOT?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    id?: StringFilter<"CustomerGroup"> | string
    name?: StringFilter<"CustomerGroup"> | string
    description?: StringNullableFilter<"CustomerGroup"> | string | null
    createdAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    CustomerToGroup?: CustomerToGroupListRelationFilter
  }

  export type CustomerGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CustomerToGroup?: CustomerToGroupOrderByRelationAggregateInput
  }

  export type CustomerGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    OR?: CustomerGroupWhereInput[]
    NOT?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    name?: StringFilter<"CustomerGroup"> | string
    description?: StringNullableFilter<"CustomerGroup"> | string | null
    createdAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    CustomerToGroup?: CustomerToGroupListRelationFilter
  }, "id">

  export type CustomerGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerGroupCountOrderByAggregateInput
    _max?: CustomerGroupMaxOrderByAggregateInput
    _min?: CustomerGroupMinOrderByAggregateInput
  }

  export type CustomerGroupScalarWhereWithAggregatesInput = {
    AND?: CustomerGroupScalarWhereWithAggregatesInput | CustomerGroupScalarWhereWithAggregatesInput[]
    OR?: CustomerGroupScalarWhereWithAggregatesInput[]
    NOT?: CustomerGroupScalarWhereWithAggregatesInput | CustomerGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerGroup"> | string
    name?: StringWithAggregatesFilter<"CustomerGroup"> | string
    description?: StringNullableWithAggregatesFilter<"CustomerGroup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerGroup"> | Date | string
  }

  export type CustomerNoteWhereInput = {
    AND?: CustomerNoteWhereInput | CustomerNoteWhereInput[]
    OR?: CustomerNoteWhereInput[]
    NOT?: CustomerNoteWhereInput | CustomerNoteWhereInput[]
    id?: StringFilter<"CustomerNote"> | string
    customerId?: StringFilter<"CustomerNote"> | string
    note?: StringFilter<"CustomerNote"> | string
    createdById?: StringFilter<"CustomerNote"> | string
    createdAt?: DateTimeFilter<"CustomerNote"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerNote"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CustomerNoteOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    note?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type CustomerNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerNoteWhereInput | CustomerNoteWhereInput[]
    OR?: CustomerNoteWhereInput[]
    NOT?: CustomerNoteWhereInput | CustomerNoteWhereInput[]
    customerId?: StringFilter<"CustomerNote"> | string
    note?: StringFilter<"CustomerNote"> | string
    createdById?: StringFilter<"CustomerNote"> | string
    createdAt?: DateTimeFilter<"CustomerNote"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerNote"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CustomerNoteOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    note?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerNoteCountOrderByAggregateInput
    _max?: CustomerNoteMaxOrderByAggregateInput
    _min?: CustomerNoteMinOrderByAggregateInput
  }

  export type CustomerNoteScalarWhereWithAggregatesInput = {
    AND?: CustomerNoteScalarWhereWithAggregatesInput | CustomerNoteScalarWhereWithAggregatesInput[]
    OR?: CustomerNoteScalarWhereWithAggregatesInput[]
    NOT?: CustomerNoteScalarWhereWithAggregatesInput | CustomerNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerNote"> | string
    customerId?: StringWithAggregatesFilter<"CustomerNote"> | string
    note?: StringWithAggregatesFilter<"CustomerNote"> | string
    createdById?: StringWithAggregatesFilter<"CustomerNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerNote"> | Date | string
  }

  export type CustomerPromotionWhereInput = {
    AND?: CustomerPromotionWhereInput | CustomerPromotionWhereInput[]
    OR?: CustomerPromotionWhereInput[]
    NOT?: CustomerPromotionWhereInput | CustomerPromotionWhereInput[]
    id?: StringFilter<"CustomerPromotion"> | string
    name?: StringFilter<"CustomerPromotion"> | string
    description?: StringNullableFilter<"CustomerPromotion"> | string | null
    type?: EnumPromotionTypeFilter<"CustomerPromotion"> | $Enums.PromotionType
    discountValue?: DecimalFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"CustomerPromotion"> | boolean
    code?: StringNullableFilter<"CustomerPromotion"> | string | null
    minimumPurchase?: DecimalNullableFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string | null
    programId?: StringNullableFilter<"CustomerPromotion"> | string | null
    requiredLoyaltyTier?: EnumLoyaltyTierNullableFilter<"CustomerPromotion"> | $Enums.LoyaltyTier | null
    startDate?: DateTimeFilter<"CustomerPromotion"> | Date | string
    endDate?: DateTimeFilter<"CustomerPromotion"> | Date | string
    isActive?: BoolFilter<"CustomerPromotion"> | boolean
    usageLimit?: IntNullableFilter<"CustomerPromotion"> | number | null
    usageCount?: IntFilter<"CustomerPromotion"> | number
    applicableProducts?: StringNullableFilter<"CustomerPromotion"> | string | null
    applicableCategories?: StringNullableFilter<"CustomerPromotion"> | string | null
    createdAt?: DateTimeFilter<"CustomerPromotion"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPromotion"> | Date | string
    LoyaltyProgram?: XOR<LoyaltyProgramNullableScalarRelationFilter, LoyaltyProgramWhereInput> | null
    PromotionRedemption?: PromotionRedemptionListRelationFilter
  }

  export type CustomerPromotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    isPercentage?: SortOrder
    code?: SortOrderInput | SortOrder
    minimumPurchase?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    requiredLoyaltyTier?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    applicableProducts?: SortOrderInput | SortOrder
    applicableCategories?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    LoyaltyProgram?: LoyaltyProgramOrderByWithRelationInput
    PromotionRedemption?: PromotionRedemptionOrderByRelationAggregateInput
  }

  export type CustomerPromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerPromotionWhereInput | CustomerPromotionWhereInput[]
    OR?: CustomerPromotionWhereInput[]
    NOT?: CustomerPromotionWhereInput | CustomerPromotionWhereInput[]
    name?: StringFilter<"CustomerPromotion"> | string
    description?: StringNullableFilter<"CustomerPromotion"> | string | null
    type?: EnumPromotionTypeFilter<"CustomerPromotion"> | $Enums.PromotionType
    discountValue?: DecimalFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"CustomerPromotion"> | boolean
    code?: StringNullableFilter<"CustomerPromotion"> | string | null
    minimumPurchase?: DecimalNullableFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string | null
    programId?: StringNullableFilter<"CustomerPromotion"> | string | null
    requiredLoyaltyTier?: EnumLoyaltyTierNullableFilter<"CustomerPromotion"> | $Enums.LoyaltyTier | null
    startDate?: DateTimeFilter<"CustomerPromotion"> | Date | string
    endDate?: DateTimeFilter<"CustomerPromotion"> | Date | string
    isActive?: BoolFilter<"CustomerPromotion"> | boolean
    usageLimit?: IntNullableFilter<"CustomerPromotion"> | number | null
    usageCount?: IntFilter<"CustomerPromotion"> | number
    applicableProducts?: StringNullableFilter<"CustomerPromotion"> | string | null
    applicableCategories?: StringNullableFilter<"CustomerPromotion"> | string | null
    createdAt?: DateTimeFilter<"CustomerPromotion"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPromotion"> | Date | string
    LoyaltyProgram?: XOR<LoyaltyProgramNullableScalarRelationFilter, LoyaltyProgramWhereInput> | null
    PromotionRedemption?: PromotionRedemptionListRelationFilter
  }, "id">

  export type CustomerPromotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    isPercentage?: SortOrder
    code?: SortOrderInput | SortOrder
    minimumPurchase?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    requiredLoyaltyTier?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    applicableProducts?: SortOrderInput | SortOrder
    applicableCategories?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerPromotionCountOrderByAggregateInput
    _avg?: CustomerPromotionAvgOrderByAggregateInput
    _max?: CustomerPromotionMaxOrderByAggregateInput
    _min?: CustomerPromotionMinOrderByAggregateInput
    _sum?: CustomerPromotionSumOrderByAggregateInput
  }

  export type CustomerPromotionScalarWhereWithAggregatesInput = {
    AND?: CustomerPromotionScalarWhereWithAggregatesInput | CustomerPromotionScalarWhereWithAggregatesInput[]
    OR?: CustomerPromotionScalarWhereWithAggregatesInput[]
    NOT?: CustomerPromotionScalarWhereWithAggregatesInput | CustomerPromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerPromotion"> | string
    name?: StringWithAggregatesFilter<"CustomerPromotion"> | string
    description?: StringNullableWithAggregatesFilter<"CustomerPromotion"> | string | null
    type?: EnumPromotionTypeWithAggregatesFilter<"CustomerPromotion"> | $Enums.PromotionType
    discountValue?: DecimalWithAggregatesFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolWithAggregatesFilter<"CustomerPromotion"> | boolean
    code?: StringNullableWithAggregatesFilter<"CustomerPromotion"> | string | null
    minimumPurchase?: DecimalNullableWithAggregatesFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string | null
    programId?: StringNullableWithAggregatesFilter<"CustomerPromotion"> | string | null
    requiredLoyaltyTier?: EnumLoyaltyTierNullableWithAggregatesFilter<"CustomerPromotion"> | $Enums.LoyaltyTier | null
    startDate?: DateTimeWithAggregatesFilter<"CustomerPromotion"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"CustomerPromotion"> | Date | string
    isActive?: BoolWithAggregatesFilter<"CustomerPromotion"> | boolean
    usageLimit?: IntNullableWithAggregatesFilter<"CustomerPromotion"> | number | null
    usageCount?: IntWithAggregatesFilter<"CustomerPromotion"> | number
    applicableProducts?: StringNullableWithAggregatesFilter<"CustomerPromotion"> | string | null
    applicableCategories?: StringNullableWithAggregatesFilter<"CustomerPromotion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPromotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerPromotion"> | Date | string
  }

  export type CustomerToGroupWhereInput = {
    AND?: CustomerToGroupWhereInput | CustomerToGroupWhereInput[]
    OR?: CustomerToGroupWhereInput[]
    NOT?: CustomerToGroupWhereInput | CustomerToGroupWhereInput[]
    customerId?: StringFilter<"CustomerToGroup"> | string
    groupId?: StringFilter<"CustomerToGroup"> | string
    createdAt?: DateTimeFilter<"CustomerToGroup"> | Date | string
    Customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    CustomerGroup?: XOR<CustomerGroupScalarRelationFilter, CustomerGroupWhereInput>
  }

  export type CustomerToGroupOrderByWithRelationInput = {
    customerId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
    CustomerGroup?: CustomerGroupOrderByWithRelationInput
  }

  export type CustomerToGroupWhereUniqueInput = Prisma.AtLeast<{
    customerId_groupId?: CustomerToGroupCustomerIdGroupIdCompoundUniqueInput
    AND?: CustomerToGroupWhereInput | CustomerToGroupWhereInput[]
    OR?: CustomerToGroupWhereInput[]
    NOT?: CustomerToGroupWhereInput | CustomerToGroupWhereInput[]
    customerId?: StringFilter<"CustomerToGroup"> | string
    groupId?: StringFilter<"CustomerToGroup"> | string
    createdAt?: DateTimeFilter<"CustomerToGroup"> | Date | string
    Customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    CustomerGroup?: XOR<CustomerGroupScalarRelationFilter, CustomerGroupWhereInput>
  }, "customerId_groupId">

  export type CustomerToGroupOrderByWithAggregationInput = {
    customerId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerToGroupCountOrderByAggregateInput
    _max?: CustomerToGroupMaxOrderByAggregateInput
    _min?: CustomerToGroupMinOrderByAggregateInput
  }

  export type CustomerToGroupScalarWhereWithAggregatesInput = {
    AND?: CustomerToGroupScalarWhereWithAggregatesInput | CustomerToGroupScalarWhereWithAggregatesInput[]
    OR?: CustomerToGroupScalarWhereWithAggregatesInput[]
    NOT?: CustomerToGroupScalarWhereWithAggregatesInput | CustomerToGroupScalarWhereWithAggregatesInput[]
    customerId?: StringWithAggregatesFilter<"CustomerToGroup"> | string
    groupId?: StringWithAggregatesFilter<"CustomerToGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerToGroup"> | Date | string
  }

  export type LoyaltyProgramRuleWhereInput = {
    AND?: LoyaltyProgramRuleWhereInput | LoyaltyProgramRuleWhereInput[]
    OR?: LoyaltyProgramRuleWhereInput[]
    NOT?: LoyaltyProgramRuleWhereInput | LoyaltyProgramRuleWhereInput[]
    id?: StringFilter<"LoyaltyProgramRule"> | string
    programId?: StringFilter<"LoyaltyProgramRule"> | string
    name?: StringFilter<"LoyaltyProgramRule"> | string
    description?: StringNullableFilter<"LoyaltyProgramRule"> | string | null
    type?: EnumLoyaltyRuleTypeFilter<"LoyaltyProgramRule"> | $Enums.LoyaltyRuleType
    conditions?: StringNullableFilter<"LoyaltyProgramRule"> | string | null
    pointsAwarded?: IntFilter<"LoyaltyProgramRule"> | number
    isActive?: BoolFilter<"LoyaltyProgramRule"> | boolean
    startDate?: DateTimeNullableFilter<"LoyaltyProgramRule"> | Date | string | null
    endDate?: DateTimeNullableFilter<"LoyaltyProgramRule"> | Date | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramRule"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramRule"> | Date | string
    LoyaltyProgram?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }

  export type LoyaltyProgramRuleOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    conditions?: SortOrderInput | SortOrder
    pointsAwarded?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    LoyaltyProgram?: LoyaltyProgramOrderByWithRelationInput
  }

  export type LoyaltyProgramRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyProgramRuleWhereInput | LoyaltyProgramRuleWhereInput[]
    OR?: LoyaltyProgramRuleWhereInput[]
    NOT?: LoyaltyProgramRuleWhereInput | LoyaltyProgramRuleWhereInput[]
    programId?: StringFilter<"LoyaltyProgramRule"> | string
    name?: StringFilter<"LoyaltyProgramRule"> | string
    description?: StringNullableFilter<"LoyaltyProgramRule"> | string | null
    type?: EnumLoyaltyRuleTypeFilter<"LoyaltyProgramRule"> | $Enums.LoyaltyRuleType
    conditions?: StringNullableFilter<"LoyaltyProgramRule"> | string | null
    pointsAwarded?: IntFilter<"LoyaltyProgramRule"> | number
    isActive?: BoolFilter<"LoyaltyProgramRule"> | boolean
    startDate?: DateTimeNullableFilter<"LoyaltyProgramRule"> | Date | string | null
    endDate?: DateTimeNullableFilter<"LoyaltyProgramRule"> | Date | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramRule"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramRule"> | Date | string
    LoyaltyProgram?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }, "id">

  export type LoyaltyProgramRuleOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    conditions?: SortOrderInput | SortOrder
    pointsAwarded?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyProgramRuleCountOrderByAggregateInput
    _avg?: LoyaltyProgramRuleAvgOrderByAggregateInput
    _max?: LoyaltyProgramRuleMaxOrderByAggregateInput
    _min?: LoyaltyProgramRuleMinOrderByAggregateInput
    _sum?: LoyaltyProgramRuleSumOrderByAggregateInput
  }

  export type LoyaltyProgramRuleScalarWhereWithAggregatesInput = {
    AND?: LoyaltyProgramRuleScalarWhereWithAggregatesInput | LoyaltyProgramRuleScalarWhereWithAggregatesInput[]
    OR?: LoyaltyProgramRuleScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyProgramRuleScalarWhereWithAggregatesInput | LoyaltyProgramRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyProgramRule"> | string
    programId?: StringWithAggregatesFilter<"LoyaltyProgramRule"> | string
    name?: StringWithAggregatesFilter<"LoyaltyProgramRule"> | string
    description?: StringNullableWithAggregatesFilter<"LoyaltyProgramRule"> | string | null
    type?: EnumLoyaltyRuleTypeWithAggregatesFilter<"LoyaltyProgramRule"> | $Enums.LoyaltyRuleType
    conditions?: StringNullableWithAggregatesFilter<"LoyaltyProgramRule"> | string | null
    pointsAwarded?: IntWithAggregatesFilter<"LoyaltyProgramRule"> | number
    isActive?: BoolWithAggregatesFilter<"LoyaltyProgramRule"> | boolean
    startDate?: DateTimeNullableWithAggregatesFilter<"LoyaltyProgramRule"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"LoyaltyProgramRule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyProgramRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyProgramRule"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrderInput | SortOrder
    receiver?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    senderId?: StringNullableFilter<"Notification"> | string | null
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    relatedEntityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    senderId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type PromotionRedemptionWhereInput = {
    AND?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    OR?: PromotionRedemptionWhereInput[]
    NOT?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    id?: StringFilter<"PromotionRedemption"> | string
    promotionId?: StringFilter<"PromotionRedemption"> | string
    customerId?: StringFilter<"PromotionRedemption"> | string
    saleId?: StringFilter<"PromotionRedemption"> | string
    discountAmount?: DecimalFilter<"PromotionRedemption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
    Customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    CustomerPromotion?: XOR<CustomerPromotionScalarRelationFilter, CustomerPromotionWhereInput>
    Sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }

  export type PromotionRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
    CustomerPromotion?: CustomerPromotionOrderByWithRelationInput
    Sale?: SaleOrderByWithRelationInput
  }

  export type PromotionRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    OR?: PromotionRedemptionWhereInput[]
    NOT?: PromotionRedemptionWhereInput | PromotionRedemptionWhereInput[]
    promotionId?: StringFilter<"PromotionRedemption"> | string
    customerId?: StringFilter<"PromotionRedemption"> | string
    saleId?: StringFilter<"PromotionRedemption"> | string
    discountAmount?: DecimalFilter<"PromotionRedemption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
    Customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    CustomerPromotion?: XOR<CustomerPromotionScalarRelationFilter, CustomerPromotionWhereInput>
    Sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }, "id">

  export type PromotionRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
    _count?: PromotionRedemptionCountOrderByAggregateInput
    _avg?: PromotionRedemptionAvgOrderByAggregateInput
    _max?: PromotionRedemptionMaxOrderByAggregateInput
    _min?: PromotionRedemptionMinOrderByAggregateInput
    _sum?: PromotionRedemptionSumOrderByAggregateInput
  }

  export type PromotionRedemptionScalarWhereWithAggregatesInput = {
    AND?: PromotionRedemptionScalarWhereWithAggregatesInput | PromotionRedemptionScalarWhereWithAggregatesInput[]
    OR?: PromotionRedemptionScalarWhereWithAggregatesInput[]
    NOT?: PromotionRedemptionScalarWhereWithAggregatesInput | PromotionRedemptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromotionRedemption"> | string
    promotionId?: StringWithAggregatesFilter<"PromotionRedemption"> | string
    customerId?: StringWithAggregatesFilter<"PromotionRedemption"> | string
    saleId?: StringWithAggregatesFilter<"PromotionRedemption"> | string
    discountAmount?: DecimalWithAggregatesFilter<"PromotionRedemption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PromotionRedemption"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseZoneCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleCreateNestedManyWithoutZoneInput
    warehouse: WarehouseCreateNestedOneWithoutZonesInput
  }

  export type WarehouseZoneUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    warehouseId: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleUncheckedCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUpdateManyWithoutZoneNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutZonesNestedInput
  }

  export type WarehouseZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneCreateManyInput = {
    id?: string
    name: string
    code: string
    warehouseId: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseAisleCreateInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: WarehouseZoneCreateNestedOneWithoutAislesInput
    shelves?: WarehouseShelfCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shelves?: WarehouseShelfUncheckedCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: WarehouseZoneUpdateOneRequiredWithoutAislesNestedInput
    shelves?: WarehouseShelfUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelves?: WarehouseShelfUncheckedUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleCreateManyInput = {
    id?: string
    name: string
    code: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseAisleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseAisleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfCreateInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinCreateNestedManyWithoutShelfInput
    aisle: WarehouseAisleCreateNestedOneWithoutShelvesInput
  }

  export type WarehouseShelfUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    aisleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinUncheckedCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUpdateManyWithoutShelfNestedInput
    aisle?: WarehouseAisleUpdateOneRequiredWithoutShelvesNestedInput
  }

  export type WarehouseShelfUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    aisleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUncheckedUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfCreateManyInput = {
    id?: string
    name: string
    code: string
    aisleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseShelfUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    aisleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinCreateInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutBinInput
    shelf: WarehouseShelfCreateNestedOneWithoutBinsInput
  }

  export type WarehouseBinUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    shelfId: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutBinNestedInput
    shelf?: WarehouseShelfUpdateOneRequiredWithoutBinsNestedInput
  }

  export type WarehouseBinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinCreateManyInput = {
    id?: string
    name: string
    code: string
    shelfId: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseBinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffCreateInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWarehouseStaffInput
    warehouse: WarehouseCreateNestedOneWithoutStaffInput
  }

  export type WarehouseStaffUncheckedCreateInput = {
    id?: string
    userId: string
    warehouseId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWarehouseStaffNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutStaffNestedInput
  }

  export type WarehouseStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffCreateManyInput = {
    id?: string
    userId: string
    warehouseId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffCreateInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutStaffInput
    user: UserCreateNestedOneWithoutStoreStaffInput
  }

  export type StoreStaffUncheckedCreateInput = {
    id?: string
    userId: string
    storeId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStaffNestedInput
    user?: UserUpdateOneRequiredWithoutStoreStaffNestedInput
  }

  export type StoreStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffCreateManyInput = {
    id?: string
    userId: string
    storeId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    User_Supplier_createdByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_createdByIdToUserInput
    User_Supplier_updatedByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_updatedByIdToUserInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    User_Supplier_createdByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_createdByIdToUserNestedInput
    User_Supplier_updatedByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_updatedByIdToUserNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutContractsInput
  }

  export type SupplierContractUncheckedCreateInput = {
    id?: string
    supplierId: string
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutContractsNestedInput
  }

  export type SupplierContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractCreateManyInput = {
    id?: string
    supplierId: string
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_PurchaseOrder_createdByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    User_PurchaseOrder_updatedByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_PurchaseOrder_createdByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    User_PurchaseOrder_updatedByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    store: StoreCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
    sale: SaleCreateNestedOneWithoutItemsInput
  }

  export type SaleItemUncheckedCreateInput = {
    id?: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SaleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateManyInput = {
    id?: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateManyInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateInput = {
    id?: string
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    product: ProductCreateNestedOneWithoutTransferItemsInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
    transfer: TransferCreateNestedOneWithoutItemsInput
  }

  export type TransferItemUncheckedCreateInput = {
    id?: string
    transferId: string
    productId: string
    sourceInventoryId?: string | null
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemsNestedInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateManyInput = {
    id?: string
    transferId: string
    productId: string
    sourceInventoryId?: string | null
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateInput = {
    id?: string
    addressType?: string
    isDefault?: boolean
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerAddressesInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: string
    customerId: string
    addressType?: string
    isDefault?: boolean
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerAddressesNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyInput = {
    id?: string
    customerId: string
    addressType?: string
    isDefault?: boolean
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionCreateNestedManyWithoutLoyaltyProgramInput
    LoyaltyProgramRule?: LoyaltyProgramRuleCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUpdateManyWithoutLoyaltyProgramNestedInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierCreateInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: Decimal | DecimalJsLike | number | string
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: LoyaltyProgramCreateNestedOneWithoutTiersInput
  }

  export type LoyaltyProgramTierUncheckedCreateInput = {
    id?: string
    programId: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: Decimal | DecimalJsLike | number | string
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: LoyaltyProgramUpdateOneRequiredWithoutTiersNestedInput
  }

  export type LoyaltyProgramTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierCreateManyInput = {
    id?: string
    programId: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: Decimal | DecimalJsLike | number | string
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLoyaltyTransactionsInput
    program: LoyaltyProgramCreateNestedOneWithoutTransactionsInput
    Sale?: SaleCreateNestedOneWithoutLoyaltyTransactionInput
  }

  export type LoyaltyTransactionUncheckedCreateInput = {
    id?: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type LoyaltyTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput
    program?: LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput
    Sale?: SaleUpdateOneWithoutLoyaltyTransactionNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateManyInput = {
    id?: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type LoyaltyTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditCreateManyInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateInput = {
    id?: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutAuditItemsInput
    product: ProductCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateInput = {
    id?: string
    auditId: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateManyInput = {
    id?: string
    auditId: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentCreateInput = {
    id?: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutAuditAssignmentsInput
  }

  export type AuditAssignmentUncheckedCreateInput = {
    id?: string
    auditId: string
    userId: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditAssignmentsNestedInput
  }

  export type AuditAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentCreateManyInput = {
    id?: string
    auditId: string
    userId: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CustomerGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteCreateInput = {
    id?: string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerNoteInput
    createdBy: UserCreateNestedOneWithoutCustomerNoteInput
  }

  export type CustomerNoteUncheckedCreateInput = {
    id?: string
    customerId: string
    note: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerNoteNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCustomerNoteNestedInput
  }

  export type CustomerNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteCreateManyInput = {
    id?: string
    customerId: string
    note: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPromotionCreateInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    LoyaltyProgram?: LoyaltyProgramCreateNestedOneWithoutCustomerPromotionInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerPromotionInput
  }

  export type CustomerPromotionUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    programId?: string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerPromotionInput
  }

  export type CustomerPromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyProgram?: LoyaltyProgramUpdateOneWithoutCustomerPromotionNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerPromotionNestedInput
  }

  export type CustomerPromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerPromotionNestedInput
  }

  export type CustomerPromotionCreateManyInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    programId?: string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CustomerPromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupCreateInput = {
    createdAt?: Date | string
    Customer: CustomerCreateNestedOneWithoutCustomerToGroupInput
    CustomerGroup: CustomerGroupCreateNestedOneWithoutCustomerToGroupInput
  }

  export type CustomerToGroupUncheckedCreateInput = {
    customerId: string
    groupId: string
    createdAt?: Date | string
  }

  export type CustomerToGroupUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneRequiredWithoutCustomerToGroupNestedInput
    CustomerGroup?: CustomerGroupUpdateOneRequiredWithoutCustomerToGroupNestedInput
  }

  export type CustomerToGroupUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupCreateManyInput = {
    customerId: string
    groupId: string
    createdAt?: Date | string
  }

  export type CustomerToGroupUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramRuleCreateInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.LoyaltyRuleType
    conditions?: string | null
    pointsAwarded: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    LoyaltyProgram: LoyaltyProgramCreateNestedOneWithoutLoyaltyProgramRuleInput
  }

  export type LoyaltyProgramRuleUncheckedCreateInput = {
    id: string
    programId: string
    name: string
    description?: string | null
    type: $Enums.LoyaltyRuleType
    conditions?: string | null
    pointsAwarded: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LoyaltyProgramRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyProgram?: LoyaltyProgramUpdateOneRequiredWithoutLoyaltyProgramRuleNestedInput
  }

  export type LoyaltyProgramRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramRuleCreateManyInput = {
    id: string
    programId: string
    name: string
    description?: string | null
    type: $Enums.LoyaltyRuleType
    conditions?: string | null
    pointsAwarded: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LoyaltyProgramRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    senderId?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    senderId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionRedemptionCreateInput = {
    id: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Customer: CustomerCreateNestedOneWithoutPromotionRedemptionInput
    CustomerPromotion: CustomerPromotionCreateNestedOneWithoutPromotionRedemptionInput
    Sale: SaleCreateNestedOneWithoutPromotionRedemptionInput
  }

  export type PromotionRedemptionUncheckedCreateInput = {
    id: string
    promotionId: string
    customerId: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PromotionRedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneRequiredWithoutPromotionRedemptionNestedInput
    CustomerPromotion?: CustomerPromotionUpdateOneRequiredWithoutPromotionRedemptionNestedInput
    Sale?: SaleUpdateOneRequiredWithoutPromotionRedemptionNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateManyInput = {
    id: string
    promotionId: string
    customerId: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PromotionRedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AuditListRelationFilter = {
    every?: AuditWhereInput
    some?: AuditWhereInput
    none?: AuditWhereInput
  }

  export type AuditAssignmentListRelationFilter = {
    every?: AuditAssignmentWhereInput
    some?: AuditAssignmentWhereInput
    none?: AuditAssignmentWhereInput
  }

  export type CustomerNoteListRelationFilter = {
    every?: CustomerNoteWhereInput
    some?: CustomerNoteWhereInput
    none?: CustomerNoteWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type StoreStaffNullableScalarRelationFilter = {
    is?: StoreStaffWhereInput | null
    isNot?: StoreStaffWhereInput | null
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type WarehouseStaffNullableScalarRelationFilter = {
    is?: WarehouseStaffWhereInput | null
    isNot?: WarehouseStaffWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type WarehouseStaffListRelationFilter = {
    every?: WarehouseStaffWhereInput
    some?: WarehouseStaffWhereInput
    none?: WarehouseStaffWhereInput
  }

  export type WarehouseZoneListRelationFilter = {
    every?: WarehouseZoneWhereInput
    some?: WarehouseZoneWhereInput
    none?: WarehouseZoneWhereInput
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type WarehouseAisleListRelationFilter = {
    every?: WarehouseAisleWhereInput
    some?: WarehouseAisleWhereInput
    none?: WarehouseAisleWhereInput
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type WarehouseAisleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseZoneWarehouseIdCodeCompoundUniqueInput = {
    warehouseId: string
    code: string
  }

  export type WarehouseZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseZoneScalarRelationFilter = {
    is?: WarehouseZoneWhereInput
    isNot?: WarehouseZoneWhereInput
  }

  export type WarehouseShelfListRelationFilter = {
    every?: WarehouseShelfWhereInput
    some?: WarehouseShelfWhereInput
    none?: WarehouseShelfWhereInput
  }

  export type WarehouseShelfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseAisleZoneIdCodeCompoundUniqueInput = {
    zoneId: string
    code: string
  }

  export type WarehouseAisleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAisleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAisleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinListRelationFilter = {
    every?: WarehouseBinWhereInput
    some?: WarehouseBinWhereInput
    none?: WarehouseBinWhereInput
  }

  export type WarehouseAisleScalarRelationFilter = {
    is?: WarehouseAisleWhereInput
    isNot?: WarehouseAisleWhereInput
  }

  export type WarehouseBinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseShelfAisleIdCodeCompoundUniqueInput = {
    aisleId: string
    code: string
  }

  export type WarehouseShelfCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseShelfMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseShelfMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseShelfScalarRelationFilter = {
    is?: WarehouseShelfWhereInput
    isNot?: WarehouseShelfWhereInput
  }

  export type WarehouseBinShelfIdCodeCompoundUniqueInput = {
    shelfId: string
    code: string
  }

  export type WarehouseBinCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type WarehouseBinMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type WarehouseStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStaffListRelationFilter = {
    every?: StoreStaffWhereInput
    some?: StoreStaffWhereInput
    none?: StoreStaffWhereInput
  }

  export type StoreStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type StoreStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierContractListRelationFilter = {
    every?: SupplierContractWhereInput
    some?: SupplierContractWhereInput
    none?: SupplierContractWhereInput
  }

  export type SupplierContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierContractCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    terms?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierContractMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    terms?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierContractMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    terms?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    deliveredDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    deliveredDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    deliveredDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    description?: SortOrder
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    orderedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    subtotal?: SortOrder
    total?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AuditItemListRelationFilter = {
    every?: AuditItemWhereInput
    some?: AuditItemWhereInput
    none?: AuditItemWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type SaleItemListRelationFilter = {
    every?: SaleItemWhereInput
    some?: SaleItemWhereInput
    none?: SaleItemWhereInput
  }

  export type TransferItemListRelationFilter = {
    every?: TransferItemWhereInput
    some?: TransferItemWhereInput
    none?: TransferItemWhereInput
  }

  export type AuditItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unit?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    taxRate?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrder
    taxRate?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unit?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    taxRate?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unit?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    taxRate?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    maxStockLevel?: SortOrder
    reorderPoint?: SortOrder
    weight?: SortOrder
    taxRate?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type WarehouseBinNullableScalarRelationFilter = {
    is?: WarehouseBinWhereInput | null
    isNot?: WarehouseBinWhereInput | null
  }

  export type StoreNullableScalarRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type InventoryItemProductIdWarehouseIdStoreIdBatchNumberLotNumberCompoundUniqueInput = {
    productId: string
    warehouseId: string
    storeId: string
    batchNumber: string
    lotNumber: string
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    storeId?: SortOrder
    binId?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    storeId?: SortOrder
    binId?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    storeId?: SortOrder
    binId?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
  }

  export type EnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type LoyaltyTransactionListRelationFilter = {
    every?: LoyaltyTransactionWhereInput
    some?: LoyaltyTransactionWhereInput
    none?: LoyaltyTransactionWhereInput
  }

  export type PromotionRedemptionListRelationFilter = {
    every?: PromotionRedemptionWhereInput
    some?: PromotionRedemptionWhereInput
    none?: PromotionRedemptionWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type LoyaltyTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    loyaltyPointsEarned?: SortOrder
    loyaltyPointsRedeemed?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type SaleScalarRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type SaleItemCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleItemMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumTransferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeFilter<$PrismaModel> | $Enums.TransferType
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    sourceWarehouseId?: SortOrder
    destinationWarehouseId?: SortOrder
    sourceStoreId?: SortOrder
    destinationStoreId?: SortOrder
    status?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrder
    shippedDate?: SortOrder
    receivedDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    sourceWarehouseId?: SortOrder
    destinationWarehouseId?: SortOrder
    sourceStoreId?: SortOrder
    destinationStoreId?: SortOrder
    status?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrder
    shippedDate?: SortOrder
    receivedDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    sourceWarehouseId?: SortOrder
    destinationWarehouseId?: SortOrder
    sourceStoreId?: SortOrder
    destinationStoreId?: SortOrder
    status?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrder
    shippedDate?: SortOrder
    receivedDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferTypeFilter<$PrismaModel>
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type InventoryItemNullableScalarRelationFilter = {
    is?: InventoryItemWhereInput | null
    isNot?: InventoryItemWhereInput | null
  }

  export type TransferScalarRelationFilter = {
    is?: TransferWhereInput
    isNot?: TransferWhereInput
  }

  export type TransferItemCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    sourceInventoryId?: SortOrder
    destinationInventoryId?: SortOrder
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrder
    shippedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemAvgOrderByAggregateInput = {
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrder
    shippedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
  }

  export type TransferItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    sourceInventoryId?: SortOrder
    destinationInventoryId?: SortOrder
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrder
    shippedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    sourceInventoryId?: SortOrder
    destinationInventoryId?: SortOrder
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrder
    shippedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemSumOrderByAggregateInput = {
    requestedQuantity?: SortOrder
    approvedQuantity?: SortOrder
    shippedQuantity?: SortOrder
    receivedQuantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceWholesalePrice?: SortOrder
    sourceRetailPrice?: SortOrder
    destinationCostPrice?: SortOrder
    destinationWholesalePrice?: SortOrder
    destinationRetailPrice?: SortOrder
  }

  export type EnumLoyaltyTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierFilter<$PrismaModel> | $Enums.LoyaltyTier
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type CustomerToGroupListRelationFilter = {
    every?: CustomerToGroupWhereInput
    some?: CustomerToGroupWhereInput
    none?: CustomerToGroupWhereInput
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerToGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type EnumLoyaltyTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressType?: SortOrder
    isDefault?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressType?: SortOrder
    isDefault?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressType?: SortOrder
    isDefault?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPromotionListRelationFilter = {
    every?: CustomerPromotionWhereInput
    some?: CustomerPromotionWhereInput
    none?: CustomerPromotionWhereInput
  }

  export type LoyaltyProgramRuleListRelationFilter = {
    every?: LoyaltyProgramRuleWhereInput
    some?: LoyaltyProgramRuleWhereInput
    none?: LoyaltyProgramRuleWhereInput
  }

  export type LoyaltyProgramTierListRelationFilter = {
    every?: LoyaltyProgramTierWhereInput
    some?: LoyaltyProgramTierWhereInput
    none?: LoyaltyProgramTierWhereInput
  }

  export type CustomerPromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoyaltyProgramRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoyaltyProgramTierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoyaltyProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramAvgOrderByAggregateInput = {
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrder
  }

  export type LoyaltyProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramSumOrderByAggregateInput = {
    pointsPerCurrency?: SortOrder
    minimumPurchase?: SortOrder
  }

  export type LoyaltyProgramScalarRelationFilter = {
    is?: LoyaltyProgramWhereInput
    isNot?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramTierCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierAvgOrderByAggregateInput = {
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
  }

  export type LoyaltyProgramTierMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierSumOrderByAggregateInput = {
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
  }

  export type EnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
  }

  export type SaleNullableScalarRelationFilter = {
    is?: SaleWhereInput | null
    isNot?: SaleWhereInput | null
  }

  export type LoyaltyTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyTransactionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LoyaltyTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyTransactionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditCountOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditMinOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type EnumAuditItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusFilter<$PrismaModel> | $Enums.AuditItemStatus
  }

  export type AuditScalarRelationFilter = {
    is?: AuditWhereInput
    isNot?: AuditWhereInput
  }

  export type AuditItemCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrder
    variance?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditItemAvgOrderByAggregateInput = {
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrder
    variance?: SortOrder
  }

  export type AuditItemMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrder
    variance?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditItemMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrder
    variance?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditItemSumOrderByAggregateInput = {
    expectedQuantity?: SortOrder
    actualQuantity?: SortOrder
    variance?: SortOrder
  }

  export type EnumAuditItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditItemStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditItemStatusFilter<$PrismaModel>
  }

  export type AuditAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrder
    assignedAisles?: SortOrder
    assignedShelves?: SortOrder
    assignedBins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrder
    assignedAisles?: SortOrder
    assignedShelves?: SortOrder
    assignedBins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrder
    assignedAisles?: SortOrder
    assignedShelves?: SortOrder
    assignedBins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNoteCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    note?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    note?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNoteMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    note?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPromotionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeFilter<$PrismaModel> | $Enums.PromotionType
  }

  export type EnumLoyaltyTierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoyaltyTierNullableFilter<$PrismaModel> | $Enums.LoyaltyTier | null
  }

  export type LoyaltyProgramNullableScalarRelationFilter = {
    is?: LoyaltyProgramWhereInput | null
    isNot?: LoyaltyProgramWhereInput | null
  }

  export type CustomerPromotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    isPercentage?: SortOrder
    code?: SortOrder
    minimumPurchase?: SortOrder
    programId?: SortOrder
    requiredLoyaltyTier?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    applicableProducts?: SortOrder
    applicableCategories?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPromotionAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    minimumPurchase?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type CustomerPromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    isPercentage?: SortOrder
    code?: SortOrder
    minimumPurchase?: SortOrder
    programId?: SortOrder
    requiredLoyaltyTier?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    applicableProducts?: SortOrder
    applicableCategories?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPromotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    isPercentage?: SortOrder
    code?: SortOrder
    minimumPurchase?: SortOrder
    programId?: SortOrder
    requiredLoyaltyTier?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    applicableProducts?: SortOrder
    applicableCategories?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPromotionSumOrderByAggregateInput = {
    discountValue?: SortOrder
    minimumPurchase?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type EnumPromotionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromotionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromotionTypeFilter<$PrismaModel>
    _max?: NestedEnumPromotionTypeFilter<$PrismaModel>
  }

  export type EnumLoyaltyTierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoyaltyTierNullableWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierNullableFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierNullableFilter<$PrismaModel>
  }

  export type CustomerGroupScalarRelationFilter = {
    is?: CustomerGroupWhereInput
    isNot?: CustomerGroupWhereInput
  }

  export type CustomerToGroupCustomerIdGroupIdCompoundUniqueInput = {
    customerId: string
    groupId: string
  }

  export type CustomerToGroupCountOrderByAggregateInput = {
    customerId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerToGroupMaxOrderByAggregateInput = {
    customerId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerToGroupMinOrderByAggregateInput = {
    customerId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLoyaltyRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyRuleType | EnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyRuleTypeFilter<$PrismaModel> | $Enums.LoyaltyRuleType
  }

  export type LoyaltyProgramRuleCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    pointsAwarded?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramRuleAvgOrderByAggregateInput = {
    pointsAwarded?: SortOrder
  }

  export type LoyaltyProgramRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    pointsAwarded?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramRuleMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    pointsAwarded?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramRuleSumOrderByAggregateInput = {
    pointsAwarded?: SortOrder
  }

  export type EnumLoyaltyRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyRuleType | EnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyRuleTypeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    relatedEntityId?: SortOrder
    relatedEntityType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    senderId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type CustomerPromotionScalarRelationFilter = {
    is?: CustomerPromotionWhereInput
    isNot?: CustomerPromotionWhereInput
  }

  export type PromotionRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRedemptionAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type PromotionRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    discountAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRedemptionSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type CustomerNoteCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CustomerNoteCreateWithoutCreatedByInput, CustomerNoteUncheckedCreateWithoutCreatedByInput> | CustomerNoteCreateWithoutCreatedByInput[] | CustomerNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCreatedByInput | CustomerNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: CustomerNoteCreateManyCreatedByInputEnvelope
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutReceiverInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput = {
    create?: XOR<ProductCreateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput> | ProductCreateWithoutUser_Product_createdByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_createdByIdToUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput = {
    create?: XOR<ProductCreateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput> | ProductCreateWithoutUser_Product_updatedByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_updatedByIdToUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StoreStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    connect?: StoreStaffWhereUniqueInput
  }

  export type SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput> | SupplierCreateWithoutUser_Supplier_createdByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_createdByIdToUserInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput> | SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_updatedByIdToUserInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput> | TransferCreateWithoutUser_Transfer_approvedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_approvedByIdToUserInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput> | TransferCreateWithoutUser_Transfer_createdByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_createdByIdToUserInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput> | TransferCreateWithoutUser_Transfer_receivedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_receivedByIdToUserInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type WarehouseStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    connect?: WarehouseStaffWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CustomerNoteCreateWithoutCreatedByInput, CustomerNoteUncheckedCreateWithoutCreatedByInput> | CustomerNoteCreateWithoutCreatedByInput[] | CustomerNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCreatedByInput | CustomerNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: CustomerNoteCreateManyCreatedByInputEnvelope
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput = {
    create?: XOR<ProductCreateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput> | ProductCreateWithoutUser_Product_createdByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_createdByIdToUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput = {
    create?: XOR<ProductCreateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput> | ProductCreateWithoutUser_Product_updatedByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_updatedByIdToUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StoreStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    connect?: StoreStaffWhereUniqueInput
  }

  export type SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput> | SupplierCreateWithoutUser_Supplier_createdByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_createdByIdToUserInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput> | SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_updatedByIdToUserInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput> | TransferCreateWithoutUser_Transfer_approvedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_approvedByIdToUserInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput> | TransferCreateWithoutUser_Transfer_createdByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_createdByIdToUserInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput> | TransferCreateWithoutUser_Transfer_receivedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_receivedByIdToUserInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type WarehouseStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    connect?: WarehouseStaffWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutCreatedByInput | AuditUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutCreatedByInput | AuditUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutCreatedByInput | AuditUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutUserInput | AuditAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutUserInput | AuditAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutUserInput | AuditAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type CustomerNoteUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CustomerNoteCreateWithoutCreatedByInput, CustomerNoteUncheckedCreateWithoutCreatedByInput> | CustomerNoteCreateWithoutCreatedByInput[] | CustomerNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCreatedByInput | CustomerNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: CustomerNoteUpsertWithWhereUniqueWithoutCreatedByInput | CustomerNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CustomerNoteCreateManyCreatedByInputEnvelope
    set?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    disconnect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    delete?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    update?: CustomerNoteUpdateWithWhereUniqueWithoutCreatedByInput | CustomerNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CustomerNoteUpdateManyWithWhereWithoutCreatedByInput | CustomerNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CustomerNoteScalarWhereInput | CustomerNoteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutReceiverInput | NotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutReceiverInput | NotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutReceiverInput | NotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput = {
    create?: XOR<ProductCreateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput> | ProductCreateWithoutUser_Product_createdByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUser_Product_createdByIdToUserInput | ProductUpsertWithWhereUniqueWithoutUser_Product_createdByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_createdByIdToUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUser_Product_createdByIdToUserInput | ProductUpdateWithWhereUniqueWithoutUser_Product_createdByIdToUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUser_Product_createdByIdToUserInput | ProductUpdateManyWithWhereWithoutUser_Product_createdByIdToUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput = {
    create?: XOR<ProductCreateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput> | ProductCreateWithoutUser_Product_updatedByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput | ProductUpsertWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_updatedByIdToUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput | ProductUpdateWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUser_Product_updatedByIdToUserInput | ProductUpdateManyWithWhereWithoutUser_Product_updatedByIdToUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCreatedByInput | SaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCreatedByInput | SaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCreatedByInput | SaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StoreStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    upsert?: StoreStaffUpsertWithoutUserInput
    disconnect?: StoreStaffWhereInput | boolean
    delete?: StoreStaffWhereInput | boolean
    connect?: StoreStaffWhereUniqueInput
    update?: XOR<XOR<StoreStaffUpdateToOneWithWhereWithoutUserInput, StoreStaffUpdateWithoutUserInput>, StoreStaffUncheckedUpdateWithoutUserInput>
  }

  export type SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput> | SupplierCreateWithoutUser_Supplier_createdByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput | SupplierUpsertWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_createdByIdToUserInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput | SupplierUpdateWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutUser_Supplier_createdByIdToUserInput | SupplierUpdateManyWithWhereWithoutUser_Supplier_createdByIdToUserInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput> | SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput | SupplierUpsertWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_updatedByIdToUserInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput | SupplierUpdateWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutUser_Supplier_updatedByIdToUserInput | SupplierUpdateManyWithWhereWithoutUser_Supplier_updatedByIdToUserInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput> | TransferCreateWithoutUser_Transfer_approvedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput | TransferUpsertWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_approvedByIdToUserInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput | TransferUpdateWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUser_Transfer_approvedByIdToUserInput | TransferUpdateManyWithWhereWithoutUser_Transfer_approvedByIdToUserInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput> | TransferCreateWithoutUser_Transfer_createdByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput | TransferUpsertWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_createdByIdToUserInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput | TransferUpdateWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUser_Transfer_createdByIdToUserInput | TransferUpdateManyWithWhereWithoutUser_Transfer_createdByIdToUserInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput> | TransferCreateWithoutUser_Transfer_receivedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput | TransferUpsertWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_receivedByIdToUserInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput | TransferUpdateWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUser_Transfer_receivedByIdToUserInput | TransferUpdateManyWithWhereWithoutUser_Transfer_receivedByIdToUserInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type WarehouseStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    upsert?: WarehouseStaffUpsertWithoutUserInput
    disconnect?: WarehouseStaffWhereInput | boolean
    delete?: WarehouseStaffWhereInput | boolean
    connect?: WarehouseStaffWhereUniqueInput
    update?: XOR<XOR<WarehouseStaffUpdateToOneWithWhereWithoutUserInput, WarehouseStaffUpdateWithoutUserInput>, WarehouseStaffUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutCreatedByInput | AuditUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutCreatedByInput | AuditUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutCreatedByInput | AuditUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutUserInput | AuditAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutUserInput | AuditAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutUserInput | AuditAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CustomerNoteCreateWithoutCreatedByInput, CustomerNoteUncheckedCreateWithoutCreatedByInput> | CustomerNoteCreateWithoutCreatedByInput[] | CustomerNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCreatedByInput | CustomerNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: CustomerNoteUpsertWithWhereUniqueWithoutCreatedByInput | CustomerNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CustomerNoteCreateManyCreatedByInputEnvelope
    set?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    disconnect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    delete?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    update?: CustomerNoteUpdateWithWhereUniqueWithoutCreatedByInput | CustomerNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CustomerNoteUpdateManyWithWhereWithoutCreatedByInput | CustomerNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CustomerNoteScalarWhereInput | CustomerNoteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutReceiverInput | NotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutReceiverInput | NotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutReceiverInput | NotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput = {
    create?: XOR<ProductCreateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput> | ProductCreateWithoutUser_Product_createdByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUser_Product_createdByIdToUserInput | ProductUpsertWithWhereUniqueWithoutUser_Product_createdByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_createdByIdToUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUser_Product_createdByIdToUserInput | ProductUpdateWithWhereUniqueWithoutUser_Product_createdByIdToUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUser_Product_createdByIdToUserInput | ProductUpdateManyWithWhereWithoutUser_Product_createdByIdToUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput = {
    create?: XOR<ProductCreateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput> | ProductCreateWithoutUser_Product_updatedByIdToUserInput[] | ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput | ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput | ProductUpsertWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput[]
    createMany?: ProductCreateManyUser_Product_updatedByIdToUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput | ProductUpdateWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUser_Product_updatedByIdToUserInput | ProductUpdateManyWithWhereWithoutUser_Product_updatedByIdToUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_createdByIdToUserInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput> | PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[] | PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    createMany?: PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_updatedByIdToUserInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCreatedByInput | SaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCreatedByInput | SaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCreatedByInput | SaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StoreStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    upsert?: StoreStaffUpsertWithoutUserInput
    disconnect?: StoreStaffWhereInput | boolean
    delete?: StoreStaffWhereInput | boolean
    connect?: StoreStaffWhereUniqueInput
    update?: XOR<XOR<StoreStaffUpdateToOneWithWhereWithoutUserInput, StoreStaffUpdateWithoutUserInput>, StoreStaffUncheckedUpdateWithoutUserInput>
  }

  export type SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput> | SupplierCreateWithoutUser_Supplier_createdByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput | SupplierUpsertWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_createdByIdToUserInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput | SupplierUpdateWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutUser_Supplier_createdByIdToUserInput | SupplierUpdateManyWithWhereWithoutUser_Supplier_createdByIdToUserInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput = {
    create?: XOR<SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput> | SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput[] | SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput | SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput | SupplierUpsertWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput[]
    createMany?: SupplierCreateManyUser_Supplier_updatedByIdToUserInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput | SupplierUpdateWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutUser_Supplier_updatedByIdToUserInput | SupplierUpdateManyWithWhereWithoutUser_Supplier_updatedByIdToUserInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput> | TransferCreateWithoutUser_Transfer_approvedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput | TransferUpsertWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_approvedByIdToUserInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput | TransferUpdateWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUser_Transfer_approvedByIdToUserInput | TransferUpdateManyWithWhereWithoutUser_Transfer_approvedByIdToUserInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput> | TransferCreateWithoutUser_Transfer_createdByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput | TransferUpsertWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_createdByIdToUserInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput | TransferUpdateWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUser_Transfer_createdByIdToUserInput | TransferUpdateManyWithWhereWithoutUser_Transfer_createdByIdToUserInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput = {
    create?: XOR<TransferCreateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput> | TransferCreateWithoutUser_Transfer_receivedByIdToUserInput[] | TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput | TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput | TransferUpsertWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput[]
    createMany?: TransferCreateManyUser_Transfer_receivedByIdToUserInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput | TransferUpdateWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutUser_Transfer_receivedByIdToUserInput | TransferUpdateManyWithWhereWithoutUser_Transfer_receivedByIdToUserInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    upsert?: WarehouseStaffUpsertWithoutUserInput
    disconnect?: WarehouseStaffWhereInput | boolean
    delete?: WarehouseStaffWhereInput | boolean
    connect?: WarehouseStaffWhereUniqueInput
    update?: XOR<XOR<WarehouseStaffUpdateToOneWithWhereWithoutUserInput, WarehouseStaffUpdateWithoutUserInput>, WarehouseStaffUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AuditCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type WarehouseStaffCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
  }

  export type WarehouseZoneCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
  }

  export type WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AuditUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutWarehouseInput | AuditUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutWarehouseInput | AuditUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutWarehouseInput | AuditUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput | PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferUpdateManyWithWhereWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferUpdateManyWithWhereWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type WarehouseStaffUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    set?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    disconnect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    delete?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    update?: WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput | WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
  }

  export type WarehouseZoneUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    set?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    disconnect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    delete?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    update?: WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput | WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutWarehouseInput | AuditUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutWarehouseInput | AuditUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutWarehouseInput | AuditUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput | PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferUpdateManyWithWhereWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput> | TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[] | TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    createMany?: TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferUpdateManyWithWhereWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    set?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    disconnect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    delete?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    update?: WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput | WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
  }

  export type WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    set?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    disconnect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    delete?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    update?: WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput | WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
  }

  export type WarehouseAisleCreateNestedManyWithoutZoneInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
  }

  export type WarehouseCreateNestedOneWithoutZonesInput = {
    create?: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutZonesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseAisleUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
  }

  export type WarehouseAisleUpdateManyWithoutZoneNestedInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    upsert?: WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput | WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    set?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    disconnect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    delete?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    update?: WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput | WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: WarehouseAisleUpdateManyWithWhereWithoutZoneInput | WarehouseAisleUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutZonesInput
    upsert?: WarehouseUpsertWithoutZonesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutZonesInput, WarehouseUpdateWithoutZonesInput>, WarehouseUncheckedUpdateWithoutZonesInput>
  }

  export type WarehouseAisleUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    upsert?: WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput | WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    set?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    disconnect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    delete?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    update?: WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput | WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: WarehouseAisleUpdateManyWithWhereWithoutZoneInput | WarehouseAisleUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
  }

  export type WarehouseZoneCreateNestedOneWithoutAislesInput = {
    create?: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutAislesInput
    connect?: WarehouseZoneWhereUniqueInput
  }

  export type WarehouseShelfCreateNestedManyWithoutAisleInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
  }

  export type WarehouseShelfUncheckedCreateNestedManyWithoutAisleInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
  }

  export type WarehouseZoneUpdateOneRequiredWithoutAislesNestedInput = {
    create?: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutAislesInput
    upsert?: WarehouseZoneUpsertWithoutAislesInput
    connect?: WarehouseZoneWhereUniqueInput
    update?: XOR<XOR<WarehouseZoneUpdateToOneWithWhereWithoutAislesInput, WarehouseZoneUpdateWithoutAislesInput>, WarehouseZoneUncheckedUpdateWithoutAislesInput>
  }

  export type WarehouseShelfUpdateManyWithoutAisleNestedInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    upsert?: WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput | WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    set?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    disconnect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    delete?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    update?: WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput | WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput[]
    updateMany?: WarehouseShelfUpdateManyWithWhereWithoutAisleInput | WarehouseShelfUpdateManyWithWhereWithoutAisleInput[]
    deleteMany?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
  }

  export type WarehouseShelfUncheckedUpdateManyWithoutAisleNestedInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    upsert?: WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput | WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    set?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    disconnect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    delete?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    update?: WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput | WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput[]
    updateMany?: WarehouseShelfUpdateManyWithWhereWithoutAisleInput | WarehouseShelfUpdateManyWithWhereWithoutAisleInput[]
    deleteMany?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
  }

  export type WarehouseBinCreateNestedManyWithoutShelfInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
  }

  export type WarehouseAisleCreateNestedOneWithoutShelvesInput = {
    create?: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutShelvesInput
    connect?: WarehouseAisleWhereUniqueInput
  }

  export type WarehouseBinUncheckedCreateNestedManyWithoutShelfInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
  }

  export type WarehouseBinUpdateManyWithoutShelfNestedInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    upsert?: WarehouseBinUpsertWithWhereUniqueWithoutShelfInput | WarehouseBinUpsertWithWhereUniqueWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    set?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    disconnect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    delete?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    update?: WarehouseBinUpdateWithWhereUniqueWithoutShelfInput | WarehouseBinUpdateWithWhereUniqueWithoutShelfInput[]
    updateMany?: WarehouseBinUpdateManyWithWhereWithoutShelfInput | WarehouseBinUpdateManyWithWhereWithoutShelfInput[]
    deleteMany?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
  }

  export type WarehouseAisleUpdateOneRequiredWithoutShelvesNestedInput = {
    create?: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutShelvesInput
    upsert?: WarehouseAisleUpsertWithoutShelvesInput
    connect?: WarehouseAisleWhereUniqueInput
    update?: XOR<XOR<WarehouseAisleUpdateToOneWithWhereWithoutShelvesInput, WarehouseAisleUpdateWithoutShelvesInput>, WarehouseAisleUncheckedUpdateWithoutShelvesInput>
  }

  export type WarehouseBinUncheckedUpdateManyWithoutShelfNestedInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    upsert?: WarehouseBinUpsertWithWhereUniqueWithoutShelfInput | WarehouseBinUpsertWithWhereUniqueWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    set?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    disconnect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    delete?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    update?: WarehouseBinUpdateWithWhereUniqueWithoutShelfInput | WarehouseBinUpdateWithWhereUniqueWithoutShelfInput[]
    updateMany?: WarehouseBinUpdateManyWithWhereWithoutShelfInput | WarehouseBinUpdateManyWithWhereWithoutShelfInput[]
    deleteMany?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
  }

  export type InventoryItemCreateNestedManyWithoutBinInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type WarehouseShelfCreateNestedOneWithoutBinsInput = {
    create?: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutBinsInput
    connect?: WarehouseShelfWhereUniqueInput
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutBinInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUpdateManyWithoutBinNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBinInput | InventoryItemUpsertWithWhereUniqueWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBinInput | InventoryItemUpdateWithWhereUniqueWithoutBinInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBinInput | InventoryItemUpdateManyWithWhereWithoutBinInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type WarehouseShelfUpdateOneRequiredWithoutBinsNestedInput = {
    create?: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutBinsInput
    upsert?: WarehouseShelfUpsertWithoutBinsInput
    connect?: WarehouseShelfWhereUniqueInput
    update?: XOR<XOR<WarehouseShelfUpdateToOneWithWhereWithoutBinsInput, WarehouseShelfUpdateWithoutBinsInput>, WarehouseShelfUncheckedUpdateWithoutBinsInput>
  }

  export type InventoryItemUncheckedUpdateManyWithoutBinNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBinInput | InventoryItemUpsertWithWhereUniqueWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBinInput | InventoryItemUpdateWithWhereUniqueWithoutBinInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBinInput | InventoryItemUpdateManyWithWhereWithoutBinInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWarehouseStaffInput = {
    create?: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehouseStaffInput
    connect?: UserWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStaffInput = {
    create?: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWarehouseStaffNestedInput = {
    create?: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehouseStaffInput
    upsert?: UserUpsertWithoutWarehouseStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWarehouseStaffInput, UserUpdateWithoutWarehouseStaffInput>, UserUncheckedUpdateWithoutWarehouseStaffInput>
  }

  export type WarehouseUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffInput
    upsert?: WarehouseUpsertWithoutStaffInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStaffInput, WarehouseUpdateWithoutStaffInput>, WarehouseUncheckedUpdateWithoutStaffInput>
  }

  export type InventoryItemCreateNestedManyWithoutStoreInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutStoreInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StoreStaffCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_destinationStoreIdToStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_sourceStoreIdToStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StoreStaffUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_destinationStoreIdToStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_sourceStoreIdToStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type InventoryItemUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutStoreInput | InventoryItemUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutStoreInput | InventoryItemUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutStoreInput | InventoryItemUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutStoreInput | SaleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutStoreInput | SaleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutStoreInput | SaleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StoreStaffUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    upsert?: StoreStaffUpsertWithWhereUniqueWithoutStoreInput | StoreStaffUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    set?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    disconnect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    delete?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    update?: StoreStaffUpdateWithWhereUniqueWithoutStoreInput | StoreStaffUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreStaffUpdateManyWithWhereWithoutStoreInput | StoreStaffUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferUpsertWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_destinationStoreIdToStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferUpdateWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferUpdateManyWithWhereWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferUpsertWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_sourceStoreIdToStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferUpdateWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferUpdateManyWithWhereWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutStoreInput | InventoryItemUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutStoreInput | InventoryItemUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutStoreInput | InventoryItemUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutStoreInput | SaleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutStoreInput | SaleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutStoreInput | SaleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StoreStaffUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    upsert?: StoreStaffUpsertWithWhereUniqueWithoutStoreInput | StoreStaffUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    set?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    disconnect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    delete?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    update?: StoreStaffUpdateWithWhereUniqueWithoutStoreInput | StoreStaffUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreStaffUpdateManyWithWhereWithoutStoreInput | StoreStaffUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferUpsertWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_destinationStoreIdToStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferUpdateWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutStore_Transfer_destinationStoreIdToStoreInput | TransferUpdateManyWithWhereWithoutStore_Transfer_destinationStoreIdToStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput = {
    create?: XOR<TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput> | TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[] | TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferUpsertWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    createMany?: TransferCreateManyStore_Transfer_sourceStoreIdToStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferUpdateWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutStore_Transfer_sourceStoreIdToStoreInput | TransferUpdateManyWithWhereWithoutStore_Transfer_sourceStoreIdToStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutStaffInput = {
    create?: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStaffInput
    connect?: StoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStoreStaffInput = {
    create?: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreStaffInput
    connect?: UserWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStaffInput
    upsert?: StoreUpsertWithoutStaffInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStaffInput, StoreUpdateWithoutStaffInput>, StoreUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateOneRequiredWithoutStoreStaffNestedInput = {
    create?: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreStaffInput
    upsert?: UserUpsertWithoutStoreStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreStaffInput, UserUpdateWithoutStoreStaffInput>, UserUncheckedUpdateWithoutStoreStaffInput>
  }

  export type ProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSupplier_Supplier_createdByIdToUserInput = {
    create?: XOR<UserCreateWithoutSupplier_Supplier_createdByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplier_Supplier_createdByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupplier_Supplier_updatedByIdToUserInput = {
    create?: XOR<UserCreateWithoutSupplier_Supplier_updatedByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_updatedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplier_Supplier_updatedByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierContractCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierContractUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutSupplier_Supplier_createdByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutSupplier_Supplier_createdByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplier_Supplier_createdByIdToUserInput
    upsert?: UserUpsertWithoutSupplier_Supplier_createdByIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupplier_Supplier_createdByIdToUserInput, UserUpdateWithoutSupplier_Supplier_createdByIdToUserInput>, UserUncheckedUpdateWithoutSupplier_Supplier_createdByIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutSupplier_Supplier_updatedByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutSupplier_Supplier_updatedByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_updatedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplier_Supplier_updatedByIdToUserInput
    upsert?: UserUpsertWithoutSupplier_Supplier_updatedByIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupplier_Supplier_updatedByIdToUserInput, UserUpdateWithoutSupplier_Supplier_updatedByIdToUserInput>, UserUncheckedUpdateWithoutSupplier_Supplier_updatedByIdToUserInput>
  }

  export type SupplierContractUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierContractUpsertWithWhereUniqueWithoutSupplierInput | SupplierContractUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    set?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    disconnect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    delete?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    update?: SupplierContractUpdateWithWhereUniqueWithoutSupplierInput | SupplierContractUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierContractUpdateManyWithWhereWithoutSupplierInput | SupplierContractUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierContractUpsertWithWhereUniqueWithoutSupplierInput | SupplierContractUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    set?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    disconnect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    delete?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    update?: SupplierContractUpdateWithWhereUniqueWithoutSupplierInput | SupplierContractUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierContractUpdateManyWithWhereWithoutSupplierInput | SupplierContractUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutContractsInput = {
    create?: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutContractsInput
    connect?: SupplierWhereUniqueInput
  }

  export type SupplierUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutContractsInput
    upsert?: SupplierUpsertWithoutContractsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutContractsInput, SupplierUpdateWithoutContractsInput>, SupplierUncheckedUpdateWithoutContractsInput>
  }

  export type UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    create?: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    create?: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutPurchaseOrdersInput
    connect?: WarehouseWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    upsert?: UserUpsertWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>, UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    upsert?: UserUpsertWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>, UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
  }

  export type WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: WarehouseUpsertWithoutPurchaseOrdersInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutPurchaseOrdersInput, WarehouseUpdateWithoutPurchaseOrdersInput>, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ProductUpsertWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ProductUpdateWithoutPurchaseOrderItemsInput>, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type AuditItemCreateNestedManyWithoutProductInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput = {
    create?: XOR<UserCreateWithoutProduct_Product_createdByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutProduct_Product_createdByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutProductsInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    connect?: SupplierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput = {
    create?: XOR<UserCreateWithoutProduct_Product_updatedByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_updatedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutProduct_Product_updatedByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type SaleItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type AuditItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AuditItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutProductInput | AuditItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutProductInput | AuditItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutProductInput | AuditItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProductInput | InventoryItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProductInput | InventoryItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProductInput | InventoryItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutProduct_Product_createdByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutProduct_Product_createdByIdToUserInput
    upsert?: UserUpsertWithoutProduct_Product_createdByIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProduct_Product_createdByIdToUserInput, UserUpdateWithoutProduct_Product_createdByIdToUserInput>, UserUncheckedUpdateWithoutProduct_Product_createdByIdToUserInput>
  }

  export type SupplierUpdateOneWithoutProductsNestedInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    upsert?: SupplierUpsertWithoutProductsInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutProductsInput, SupplierUpdateWithoutProductsInput>, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutProduct_Product_updatedByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_updatedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutProduct_Product_updatedByIdToUserInput
    upsert?: UserUpsertWithoutProduct_Product_updatedByIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProduct_Product_updatedByIdToUserInput, UserUpdateWithoutProduct_Product_updatedByIdToUserInput>, UserUncheckedUpdateWithoutProduct_Product_updatedByIdToUserInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type SaleItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutProductInput | TransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutProductInput | TransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutProductInput | TransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type AuditItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutProductInput | AuditItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutProductInput | AuditItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutProductInput | AuditItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProductInput | InventoryItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProductInput | InventoryItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProductInput | InventoryItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutProductInput | TransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutProductInput | TransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutProductInput | TransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutOther_CategoryInput = {
    create?: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutOther_CategoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutOther_CategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutOther_CategoryInput
    upsert?: CategoryUpsertWithoutOther_CategoryInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutOther_CategoryInput, CategoryUpdateWithoutOther_CategoryInput>, CategoryUncheckedUpdateWithoutOther_CategoryInput>
  }

  export type CategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCategoryInput | CategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCategoryInput | CategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCategoryInput | CategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput> | CategoryCreateWithoutCategoryInput[] | CategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutCategoryInput | CategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutCategoryInput | CategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryCreateManyCategoryInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutCategoryInput | CategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutCategoryInput | CategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AuditItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type WarehouseBinCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutInventoryItemsInput
    connect?: WarehouseBinWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutInventoryItemsInput
    connect?: StoreWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type EnumInventoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InventoryStatus
  }

  export type AuditItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput | AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput | AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutInventoryItemInput | AuditItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type WarehouseBinUpdateOneWithoutInventoryItemsNestedInput = {
    create?: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutInventoryItemsInput
    upsert?: WarehouseBinUpsertWithoutInventoryItemsInput
    disconnect?: WarehouseBinWhereInput | boolean
    delete?: WarehouseBinWhereInput | boolean
    connect?: WarehouseBinWhereUniqueInput
    update?: XOR<XOR<WarehouseBinUpdateToOneWithWhereWithoutInventoryItemsInput, WarehouseBinUpdateWithoutInventoryItemsInput>, WarehouseBinUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    upsert?: ProductUpsertWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryItemsInput, ProductUpdateWithoutInventoryItemsInput>, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type StoreUpdateOneWithoutInventoryItemsNestedInput = {
    create?: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutInventoryItemsInput
    upsert?: StoreUpsertWithoutInventoryItemsInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutInventoryItemsInput, StoreUpdateWithoutInventoryItemsInput>, StoreUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateOneWithoutInventoryItemsNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    upsert?: WarehouseUpsertWithoutInventoryItemsInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput, WarehouseUpdateWithoutInventoryItemsInput>, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type SaleItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput | SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput | SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutInventoryItemInput | SaleItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput | AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput | AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutInventoryItemInput | AuditItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput | SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput | SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutInventoryItemInput | SaleItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput = {
    create?: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput> | TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[] | TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    createMany?: TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type LoyaltyTransactionCreateNestedManyWithoutSaleInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutSaleInput, LoyaltyTransactionUncheckedCreateWithoutSaleInput> | LoyaltyTransactionCreateWithoutSaleInput[] | LoyaltyTransactionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutSaleInput | LoyaltyTransactionCreateOrConnectWithoutSaleInput[]
    createMany?: LoyaltyTransactionCreateManySaleInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type PromotionRedemptionCreateNestedManyWithoutSaleInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSaleInput, PromotionRedemptionUncheckedCreateWithoutSaleInput> | PromotionRedemptionCreateWithoutSaleInput[] | PromotionRedemptionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSaleInput | PromotionRedemptionCreateOrConnectWithoutSaleInput[]
    createMany?: PromotionRedemptionCreateManySaleInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedSalesInput = {
    create?: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSalesInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutSalesInput = {
    create?: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesInput
    connect?: StoreWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutSaleInput, LoyaltyTransactionUncheckedCreateWithoutSaleInput> | LoyaltyTransactionCreateWithoutSaleInput[] | LoyaltyTransactionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutSaleInput | LoyaltyTransactionCreateOrConnectWithoutSaleInput[]
    createMany?: LoyaltyTransactionCreateManySaleInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSaleInput, PromotionRedemptionUncheckedCreateWithoutSaleInput> | PromotionRedemptionCreateWithoutSaleInput[] | PromotionRedemptionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSaleInput | PromotionRedemptionCreateOrConnectWithoutSaleInput[]
    createMany?: PromotionRedemptionCreateManySaleInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type LoyaltyTransactionUpdateManyWithoutSaleNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutSaleInput, LoyaltyTransactionUncheckedCreateWithoutSaleInput> | LoyaltyTransactionCreateWithoutSaleInput[] | LoyaltyTransactionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutSaleInput | LoyaltyTransactionCreateOrConnectWithoutSaleInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutSaleInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: LoyaltyTransactionCreateManySaleInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutSaleInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutSaleInput | LoyaltyTransactionUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type PromotionRedemptionUpdateManyWithoutSaleNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSaleInput, PromotionRedemptionUncheckedCreateWithoutSaleInput> | PromotionRedemptionCreateWithoutSaleInput[] | PromotionRedemptionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSaleInput | PromotionRedemptionCreateOrConnectWithoutSaleInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutSaleInput | PromotionRedemptionUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: PromotionRedemptionCreateManySaleInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutSaleInput | PromotionRedemptionUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutSaleInput | PromotionRedemptionUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedSalesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSalesInput
    upsert?: UserUpsertWithoutCreatedSalesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSalesInput, UserUpdateWithoutCreatedSalesInput>, UserUncheckedUpdateWithoutCreatedSalesInput>
  }

  export type CustomerUpdateOneWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type StoreUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesInput
    upsert?: StoreUpsertWithoutSalesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSalesInput, StoreUpdateWithoutSalesInput>, StoreUncheckedUpdateWithoutSalesInput>
  }

  export type SaleItemUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutSaleInput, LoyaltyTransactionUncheckedCreateWithoutSaleInput> | LoyaltyTransactionCreateWithoutSaleInput[] | LoyaltyTransactionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutSaleInput | LoyaltyTransactionCreateOrConnectWithoutSaleInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutSaleInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: LoyaltyTransactionCreateManySaleInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutSaleInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutSaleInput | LoyaltyTransactionUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutSaleInput, PromotionRedemptionUncheckedCreateWithoutSaleInput> | PromotionRedemptionCreateWithoutSaleInput[] | PromotionRedemptionUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutSaleInput | PromotionRedemptionCreateOrConnectWithoutSaleInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutSaleInput | PromotionRedemptionUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: PromotionRedemptionCreateManySaleInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutSaleInput | PromotionRedemptionUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutSaleInput | PromotionRedemptionUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSaleItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type SaleCreateNestedOneWithoutItemsInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    connect?: SaleWhereUniqueInput
  }

  export type InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSaleItemsInput
    upsert?: InventoryItemUpsertWithoutSaleItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutSaleItemsInput, InventoryItemUpdateWithoutSaleItemsInput>, InventoryItemUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleItemsInput
    upsert?: ProductUpsertWithoutSaleItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSaleItemsInput, ProductUpdateWithoutSaleItemsInput>, ProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type SaleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    upsert?: SaleUpsertWithoutItemsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutItemsInput, SaleUpdateWithoutItemsInput>, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput = {
    create?: XOR<UserCreateWithoutTransfer_Transfer_approvedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_approvedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_Transfer_approvedByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput = {
    create?: XOR<UserCreateWithoutTransfer_Transfer_createdByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_Transfer_createdByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    create?: XOR<StoreCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    connect?: StoreWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    create?: XOR<WarehouseCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput = {
    create?: XOR<UserCreateWithoutTransfer_Transfer_receivedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_receivedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_Transfer_receivedByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    create?: XOR<StoreCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    connect?: StoreWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    create?: XOR<WarehouseCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    connect?: WarehouseWhereUniqueInput
  }

  export type TransferItemCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type EnumTransferTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransferType
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutTransfer_Transfer_approvedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_approvedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_Transfer_approvedByIdToUserInput
    upsert?: UserUpsertWithoutTransfer_Transfer_approvedByIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransfer_Transfer_approvedByIdToUserInput, UserUpdateWithoutTransfer_Transfer_approvedByIdToUserInput>, UserUncheckedUpdateWithoutTransfer_Transfer_approvedByIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutTransfer_Transfer_createdByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_createdByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_Transfer_createdByIdToUserInput
    upsert?: UserUpsertWithoutTransfer_Transfer_createdByIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransfer_Transfer_createdByIdToUserInput, UserUpdateWithoutTransfer_Transfer_createdByIdToUserInput>, UserUncheckedUpdateWithoutTransfer_Transfer_createdByIdToUserInput>
  }

  export type StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput = {
    create?: XOR<StoreCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    upsert?: StoreUpsertWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>, StoreUncheckedUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
  }

  export type WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput = {
    create?: XOR<WarehouseCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    upsert?: WarehouseUpsertWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>, WarehouseUncheckedUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutTransfer_Transfer_receivedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_receivedByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransfer_Transfer_receivedByIdToUserInput
    upsert?: UserUpsertWithoutTransfer_Transfer_receivedByIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransfer_Transfer_receivedByIdToUserInput, UserUpdateWithoutTransfer_Transfer_receivedByIdToUserInput>, UserUncheckedUpdateWithoutTransfer_Transfer_receivedByIdToUserInput>
  }

  export type StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput = {
    create?: XOR<StoreCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    upsert?: StoreUpsertWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>, StoreUncheckedUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
  }

  export type WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput = {
    create?: XOR<WarehouseCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    upsert?: WarehouseUpsertWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>, WarehouseUncheckedUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type TransferItemUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutTransferInput | TransferItemUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutTransferInput | TransferItemUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutTransferInput | TransferItemUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutTransferInput | TransferItemUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutTransferInput | TransferItemUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutTransferInput | TransferItemUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    create?: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransferItemsInput = {
    create?: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    create?: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type TransferCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutItemsInput
    connect?: TransferWhereUniqueInput
  }

  export type InventoryItemUpdateOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    upsert?: InventoryItemUpsertWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    disconnect?: InventoryItemWhereInput | boolean
    delete?: InventoryItemWhereInput | boolean
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>, InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type ProductUpdateOneRequiredWithoutTransferItemsNestedInput = {
    create?: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferItemsInput
    upsert?: ProductUpsertWithoutTransferItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransferItemsInput, ProductUpdateWithoutTransferItemsInput>, ProductUncheckedUpdateWithoutTransferItemsInput>
  }

  export type InventoryItemUpdateOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
    upsert?: InventoryItemUpsertWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
    disconnect?: InventoryItemWhereInput | boolean
    delete?: InventoryItemWhereInput | boolean
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>, InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type TransferUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutItemsInput
    upsert?: TransferUpsertWithoutItemsInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutItemsInput, TransferUpdateWithoutItemsInput>, TransferUncheckedUpdateWithoutItemsInput>
  }

  export type CustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type CustomerNoteCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerNoteCreateWithoutCustomerInput, CustomerNoteUncheckedCreateWithoutCustomerInput> | CustomerNoteCreateWithoutCustomerInput[] | CustomerNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCustomerInput | CustomerNoteCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerNoteCreateManyCustomerInputEnvelope
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
  }

  export type CustomerToGroupCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerInput, CustomerToGroupUncheckedCreateWithoutCustomerInput> | CustomerToGroupCreateWithoutCustomerInput[] | CustomerToGroupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerInput | CustomerToGroupCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerToGroupCreateManyCustomerInputEnvelope
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
  }

  export type LoyaltyTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type PromotionRedemptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerInput, PromotionRedemptionUncheckedCreateWithoutCustomerInput> | PromotionRedemptionCreateWithoutCustomerInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerInput | PromotionRedemptionCreateOrConnectWithoutCustomerInput[]
    createMany?: PromotionRedemptionCreateManyCustomerInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerNoteCreateWithoutCustomerInput, CustomerNoteUncheckedCreateWithoutCustomerInput> | CustomerNoteCreateWithoutCustomerInput[] | CustomerNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCustomerInput | CustomerNoteCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerNoteCreateManyCustomerInputEnvelope
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
  }

  export type CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerInput, CustomerToGroupUncheckedCreateWithoutCustomerInput> | CustomerToGroupCreateWithoutCustomerInput[] | CustomerToGroupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerInput | CustomerToGroupCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerToGroupCreateManyCustomerInputEnvelope
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerInput, PromotionRedemptionUncheckedCreateWithoutCustomerInput> | PromotionRedemptionCreateWithoutCustomerInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerInput | PromotionRedemptionCreateOrConnectWithoutCustomerInput[]
    createMany?: PromotionRedemptionCreateManyCustomerInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type EnumLoyaltyTierFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTier
  }

  export type CustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type CustomerNoteUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerNoteCreateWithoutCustomerInput, CustomerNoteUncheckedCreateWithoutCustomerInput> | CustomerNoteCreateWithoutCustomerInput[] | CustomerNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCustomerInput | CustomerNoteCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerNoteUpsertWithWhereUniqueWithoutCustomerInput | CustomerNoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerNoteCreateManyCustomerInputEnvelope
    set?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    disconnect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    delete?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    update?: CustomerNoteUpdateWithWhereUniqueWithoutCustomerInput | CustomerNoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerNoteUpdateManyWithWhereWithoutCustomerInput | CustomerNoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerNoteScalarWhereInput | CustomerNoteScalarWhereInput[]
  }

  export type CustomerToGroupUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerInput, CustomerToGroupUncheckedCreateWithoutCustomerInput> | CustomerToGroupCreateWithoutCustomerInput[] | CustomerToGroupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerInput | CustomerToGroupCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerToGroupUpsertWithWhereUniqueWithoutCustomerInput | CustomerToGroupUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerToGroupCreateManyCustomerInputEnvelope
    set?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    disconnect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    delete?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    update?: CustomerToGroupUpdateWithWhereUniqueWithoutCustomerInput | CustomerToGroupUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerToGroupUpdateManyWithWhereWithoutCustomerInput | CustomerToGroupUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerToGroupScalarWhereInput | CustomerToGroupScalarWhereInput[]
  }

  export type LoyaltyTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput | LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type PromotionRedemptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerInput, PromotionRedemptionUncheckedCreateWithoutCustomerInput> | PromotionRedemptionCreateWithoutCustomerInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerInput | PromotionRedemptionCreateOrConnectWithoutCustomerInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerInput | PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PromotionRedemptionCreateManyCustomerInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerInput | PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutCustomerInput | PromotionRedemptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerNoteCreateWithoutCustomerInput, CustomerNoteUncheckedCreateWithoutCustomerInput> | CustomerNoteCreateWithoutCustomerInput[] | CustomerNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerNoteCreateOrConnectWithoutCustomerInput | CustomerNoteCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerNoteUpsertWithWhereUniqueWithoutCustomerInput | CustomerNoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerNoteCreateManyCustomerInputEnvelope
    set?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    disconnect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    delete?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    connect?: CustomerNoteWhereUniqueInput | CustomerNoteWhereUniqueInput[]
    update?: CustomerNoteUpdateWithWhereUniqueWithoutCustomerInput | CustomerNoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerNoteUpdateManyWithWhereWithoutCustomerInput | CustomerNoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerNoteScalarWhereInput | CustomerNoteScalarWhereInput[]
  }

  export type CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerInput, CustomerToGroupUncheckedCreateWithoutCustomerInput> | CustomerToGroupCreateWithoutCustomerInput[] | CustomerToGroupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerInput | CustomerToGroupCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerToGroupUpsertWithWhereUniqueWithoutCustomerInput | CustomerToGroupUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerToGroupCreateManyCustomerInputEnvelope
    set?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    disconnect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    delete?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    update?: CustomerToGroupUpdateWithWhereUniqueWithoutCustomerInput | CustomerToGroupUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerToGroupUpdateManyWithWhereWithoutCustomerInput | CustomerToGroupUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerToGroupScalarWhereInput | CustomerToGroupScalarWhereInput[]
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput | LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerInput, PromotionRedemptionUncheckedCreateWithoutCustomerInput> | PromotionRedemptionCreateWithoutCustomerInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerInput | PromotionRedemptionCreateOrConnectWithoutCustomerInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerInput | PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PromotionRedemptionCreateManyCustomerInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerInput | PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutCustomerInput | PromotionRedemptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerAddressesInput = {
    create?: XOR<CustomerCreateWithoutCustomerAddressesInput, CustomerUncheckedCreateWithoutCustomerAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerAddressesInput, CustomerUncheckedCreateWithoutCustomerAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerAddressesInput
    upsert?: CustomerUpsertWithoutCustomerAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerAddressesInput, CustomerUpdateWithoutCustomerAddressesInput>, CustomerUncheckedUpdateWithoutCustomerAddressesInput>
  }

  export type CustomerPromotionCreateNestedManyWithoutLoyaltyProgramInput = {
    create?: XOR<CustomerPromotionCreateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput> | CustomerPromotionCreateWithoutLoyaltyProgramInput[] | CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput | CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput[]
    createMany?: CustomerPromotionCreateManyLoyaltyProgramInputEnvelope
    connect?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
  }

  export type LoyaltyProgramRuleCreateNestedManyWithoutLoyaltyProgramInput = {
    create?: XOR<LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput> | LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput[] | LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput | LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput[]
    createMany?: LoyaltyProgramRuleCreateManyLoyaltyProgramInputEnvelope
    connect?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
  }

  export type LoyaltyProgramTierCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
  }

  export type LoyaltyTransactionCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type CustomerPromotionUncheckedCreateNestedManyWithoutLoyaltyProgramInput = {
    create?: XOR<CustomerPromotionCreateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput> | CustomerPromotionCreateWithoutLoyaltyProgramInput[] | CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput | CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput[]
    createMany?: CustomerPromotionCreateManyLoyaltyProgramInputEnvelope
    connect?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
  }

  export type LoyaltyProgramRuleUncheckedCreateNestedManyWithoutLoyaltyProgramInput = {
    create?: XOR<LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput> | LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput[] | LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput | LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput[]
    createMany?: LoyaltyProgramRuleCreateManyLoyaltyProgramInputEnvelope
    connect?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
  }

  export type LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type CustomerPromotionUpdateManyWithoutLoyaltyProgramNestedInput = {
    create?: XOR<CustomerPromotionCreateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput> | CustomerPromotionCreateWithoutLoyaltyProgramInput[] | CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput | CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput[]
    upsert?: CustomerPromotionUpsertWithWhereUniqueWithoutLoyaltyProgramInput | CustomerPromotionUpsertWithWhereUniqueWithoutLoyaltyProgramInput[]
    createMany?: CustomerPromotionCreateManyLoyaltyProgramInputEnvelope
    set?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    disconnect?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    delete?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    connect?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    update?: CustomerPromotionUpdateWithWhereUniqueWithoutLoyaltyProgramInput | CustomerPromotionUpdateWithWhereUniqueWithoutLoyaltyProgramInput[]
    updateMany?: CustomerPromotionUpdateManyWithWhereWithoutLoyaltyProgramInput | CustomerPromotionUpdateManyWithWhereWithoutLoyaltyProgramInput[]
    deleteMany?: CustomerPromotionScalarWhereInput | CustomerPromotionScalarWhereInput[]
  }

  export type LoyaltyProgramRuleUpdateManyWithoutLoyaltyProgramNestedInput = {
    create?: XOR<LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput> | LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput[] | LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput | LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput[]
    upsert?: LoyaltyProgramRuleUpsertWithWhereUniqueWithoutLoyaltyProgramInput | LoyaltyProgramRuleUpsertWithWhereUniqueWithoutLoyaltyProgramInput[]
    createMany?: LoyaltyProgramRuleCreateManyLoyaltyProgramInputEnvelope
    set?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    disconnect?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    delete?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    connect?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    update?: LoyaltyProgramRuleUpdateWithWhereUniqueWithoutLoyaltyProgramInput | LoyaltyProgramRuleUpdateWithWhereUniqueWithoutLoyaltyProgramInput[]
    updateMany?: LoyaltyProgramRuleUpdateManyWithWhereWithoutLoyaltyProgramInput | LoyaltyProgramRuleUpdateManyWithWhereWithoutLoyaltyProgramInput[]
    deleteMany?: LoyaltyProgramRuleScalarWhereInput | LoyaltyProgramRuleScalarWhereInput[]
  }

  export type LoyaltyProgramTierUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    set?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    disconnect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    delete?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    update?: LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput | LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
  }

  export type LoyaltyTransactionUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput | LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramNestedInput = {
    create?: XOR<CustomerPromotionCreateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput> | CustomerPromotionCreateWithoutLoyaltyProgramInput[] | CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput | CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput[]
    upsert?: CustomerPromotionUpsertWithWhereUniqueWithoutLoyaltyProgramInput | CustomerPromotionUpsertWithWhereUniqueWithoutLoyaltyProgramInput[]
    createMany?: CustomerPromotionCreateManyLoyaltyProgramInputEnvelope
    set?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    disconnect?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    delete?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    connect?: CustomerPromotionWhereUniqueInput | CustomerPromotionWhereUniqueInput[]
    update?: CustomerPromotionUpdateWithWhereUniqueWithoutLoyaltyProgramInput | CustomerPromotionUpdateWithWhereUniqueWithoutLoyaltyProgramInput[]
    updateMany?: CustomerPromotionUpdateManyWithWhereWithoutLoyaltyProgramInput | CustomerPromotionUpdateManyWithWhereWithoutLoyaltyProgramInput[]
    deleteMany?: CustomerPromotionScalarWhereInput | CustomerPromotionScalarWhereInput[]
  }

  export type LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramNestedInput = {
    create?: XOR<LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput> | LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput[] | LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput[]
    connectOrCreate?: LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput | LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput[]
    upsert?: LoyaltyProgramRuleUpsertWithWhereUniqueWithoutLoyaltyProgramInput | LoyaltyProgramRuleUpsertWithWhereUniqueWithoutLoyaltyProgramInput[]
    createMany?: LoyaltyProgramRuleCreateManyLoyaltyProgramInputEnvelope
    set?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    disconnect?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    delete?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    connect?: LoyaltyProgramRuleWhereUniqueInput | LoyaltyProgramRuleWhereUniqueInput[]
    update?: LoyaltyProgramRuleUpdateWithWhereUniqueWithoutLoyaltyProgramInput | LoyaltyProgramRuleUpdateWithWhereUniqueWithoutLoyaltyProgramInput[]
    updateMany?: LoyaltyProgramRuleUpdateManyWithWhereWithoutLoyaltyProgramInput | LoyaltyProgramRuleUpdateManyWithWhereWithoutLoyaltyProgramInput[]
    deleteMany?: LoyaltyProgramRuleScalarWhereInput | LoyaltyProgramRuleScalarWhereInput[]
  }

  export type LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    set?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    disconnect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    delete?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    update?: LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput | LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput | LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type LoyaltyProgramCreateNestedOneWithoutTiersInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTiersInput
    connect?: LoyaltyProgramWhereUniqueInput
  }

  export type LoyaltyProgramUpdateOneRequiredWithoutTiersNestedInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTiersInput
    upsert?: LoyaltyProgramUpsertWithoutTiersInput
    connect?: LoyaltyProgramWhereUniqueInput
    update?: XOR<XOR<LoyaltyProgramUpdateToOneWithWhereWithoutTiersInput, LoyaltyProgramUpdateWithoutTiersInput>, LoyaltyProgramUncheckedUpdateWithoutTiersInput>
  }

  export type CustomerCreateNestedOneWithoutLoyaltyTransactionsInput = {
    create?: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoyaltyTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type LoyaltyProgramCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTransactionsInput
    connect?: LoyaltyProgramWhereUniqueInput
  }

  export type SaleCreateNestedOneWithoutLoyaltyTransactionInput = {
    create?: XOR<SaleCreateWithoutLoyaltyTransactionInput, SaleUncheckedCreateWithoutLoyaltyTransactionInput>
    connectOrCreate?: SaleCreateOrConnectWithoutLoyaltyTransactionInput
    connect?: SaleWhereUniqueInput
  }

  export type EnumLoyaltyTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTransactionType
  }

  export type CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoyaltyTransactionsInput
    upsert?: CustomerUpsertWithoutLoyaltyTransactionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLoyaltyTransactionsInput, CustomerUpdateWithoutLoyaltyTransactionsInput>, CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
  }

  export type LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTransactionsInput
    upsert?: LoyaltyProgramUpsertWithoutTransactionsInput
    connect?: LoyaltyProgramWhereUniqueInput
    update?: XOR<XOR<LoyaltyProgramUpdateToOneWithWhereWithoutTransactionsInput, LoyaltyProgramUpdateWithoutTransactionsInput>, LoyaltyProgramUncheckedUpdateWithoutTransactionsInput>
  }

  export type SaleUpdateOneWithoutLoyaltyTransactionNestedInput = {
    create?: XOR<SaleCreateWithoutLoyaltyTransactionInput, SaleUncheckedCreateWithoutLoyaltyTransactionInput>
    connectOrCreate?: SaleCreateOrConnectWithoutLoyaltyTransactionInput
    upsert?: SaleUpsertWithoutLoyaltyTransactionInput
    disconnect?: SaleWhereInput | boolean
    delete?: SaleWhereInput | boolean
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutLoyaltyTransactionInput, SaleUpdateWithoutLoyaltyTransactionInput>, SaleUncheckedUpdateWithoutLoyaltyTransactionInput>
  }

  export type UserCreateNestedOneWithoutCreatedAuditsInput = {
    create?: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutAuditsInput = {
    create?: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAuditsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type AuditAssignmentCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type AuditItemCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type AuditItemUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedAuditsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAuditsInput
    upsert?: UserUpsertWithoutCreatedAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAuditsInput, UserUpdateWithoutCreatedAuditsInput>, UserUncheckedUpdateWithoutCreatedAuditsInput>
  }

  export type WarehouseUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAuditsInput
    upsert?: WarehouseUpsertWithoutAuditsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutAuditsInput, WarehouseUpdateWithoutAuditsInput>, WarehouseUncheckedUpdateWithoutAuditsInput>
  }

  export type AuditAssignmentUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput | AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput | AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutAuditInput | AuditAssignmentUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type AuditItemUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutAuditInput | AuditItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutAuditInput | AuditItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutAuditInput | AuditItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput | AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput | AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutAuditInput | AuditAssignmentUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type AuditItemUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutAuditInput | AuditItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutAuditInput | AuditItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutAuditInput | AuditItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type AuditCreateNestedOneWithoutItemsInput = {
    create?: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutItemsInput
    connect?: AuditWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutAuditItemsInput = {
    create?: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutAuditItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAuditItemsInput = {
    create?: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAuditItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumAuditItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditItemStatus
  }

  export type AuditUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutItemsInput
    upsert?: AuditUpsertWithoutItemsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutItemsInput, AuditUpdateWithoutItemsInput>, AuditUncheckedUpdateWithoutItemsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutAuditItemsInput
    upsert?: InventoryItemUpsertWithoutAuditItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutAuditItemsInput, InventoryItemUpdateWithoutAuditItemsInput>, InventoryItemUncheckedUpdateWithoutAuditItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutAuditItemsNestedInput = {
    create?: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAuditItemsInput
    upsert?: ProductUpsertWithoutAuditItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAuditItemsInput, ProductUpdateWithoutAuditItemsInput>, ProductUncheckedUpdateWithoutAuditItemsInput>
  }

  export type AuditCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutAssignmentsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditAssignmentsInput = {
    create?: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutAssignmentsInput
    upsert?: AuditUpsertWithoutAssignmentsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutAssignmentsInput, AuditUpdateWithoutAssignmentsInput>, AuditUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditAssignmentsInput
    upsert?: UserUpsertWithoutAuditAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditAssignmentsInput, UserUpdateWithoutAuditAssignmentsInput>, UserUncheckedUpdateWithoutAuditAssignmentsInput>
  }

  export type CustomerToGroupCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerGroupInput, CustomerToGroupUncheckedCreateWithoutCustomerGroupInput> | CustomerToGroupCreateWithoutCustomerGroupInput[] | CustomerToGroupUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerGroupInput | CustomerToGroupCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: CustomerToGroupCreateManyCustomerGroupInputEnvelope
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
  }

  export type CustomerToGroupUncheckedCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerGroupInput, CustomerToGroupUncheckedCreateWithoutCustomerGroupInput> | CustomerToGroupCreateWithoutCustomerGroupInput[] | CustomerToGroupUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerGroupInput | CustomerToGroupCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: CustomerToGroupCreateManyCustomerGroupInputEnvelope
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
  }

  export type CustomerToGroupUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerGroupInput, CustomerToGroupUncheckedCreateWithoutCustomerGroupInput> | CustomerToGroupCreateWithoutCustomerGroupInput[] | CustomerToGroupUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerGroupInput | CustomerToGroupCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: CustomerToGroupUpsertWithWhereUniqueWithoutCustomerGroupInput | CustomerToGroupUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: CustomerToGroupCreateManyCustomerGroupInputEnvelope
    set?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    disconnect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    delete?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    update?: CustomerToGroupUpdateWithWhereUniqueWithoutCustomerGroupInput | CustomerToGroupUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: CustomerToGroupUpdateManyWithWhereWithoutCustomerGroupInput | CustomerToGroupUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: CustomerToGroupScalarWhereInput | CustomerToGroupScalarWhereInput[]
  }

  export type CustomerToGroupUncheckedUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<CustomerToGroupCreateWithoutCustomerGroupInput, CustomerToGroupUncheckedCreateWithoutCustomerGroupInput> | CustomerToGroupCreateWithoutCustomerGroupInput[] | CustomerToGroupUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: CustomerToGroupCreateOrConnectWithoutCustomerGroupInput | CustomerToGroupCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: CustomerToGroupUpsertWithWhereUniqueWithoutCustomerGroupInput | CustomerToGroupUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: CustomerToGroupCreateManyCustomerGroupInputEnvelope
    set?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    disconnect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    delete?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    connect?: CustomerToGroupWhereUniqueInput | CustomerToGroupWhereUniqueInput[]
    update?: CustomerToGroupUpdateWithWhereUniqueWithoutCustomerGroupInput | CustomerToGroupUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: CustomerToGroupUpdateManyWithWhereWithoutCustomerGroupInput | CustomerToGroupUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: CustomerToGroupScalarWhereInput | CustomerToGroupScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerNoteInput = {
    create?: XOR<CustomerCreateWithoutCustomerNoteInput, CustomerUncheckedCreateWithoutCustomerNoteInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerNoteInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCustomerNoteInput = {
    create?: XOR<UserCreateWithoutCustomerNoteInput, UserUncheckedCreateWithoutCustomerNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerNoteInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerNoteNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerNoteInput, CustomerUncheckedCreateWithoutCustomerNoteInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerNoteInput
    upsert?: CustomerUpsertWithoutCustomerNoteInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerNoteInput, CustomerUpdateWithoutCustomerNoteInput>, CustomerUncheckedUpdateWithoutCustomerNoteInput>
  }

  export type UserUpdateOneRequiredWithoutCustomerNoteNestedInput = {
    create?: XOR<UserCreateWithoutCustomerNoteInput, UserUncheckedCreateWithoutCustomerNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomerNoteInput
    upsert?: UserUpsertWithoutCustomerNoteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomerNoteInput, UserUpdateWithoutCustomerNoteInput>, UserUncheckedUpdateWithoutCustomerNoteInput>
  }

  export type LoyaltyProgramCreateNestedOneWithoutCustomerPromotionInput = {
    create?: XOR<LoyaltyProgramCreateWithoutCustomerPromotionInput, LoyaltyProgramUncheckedCreateWithoutCustomerPromotionInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutCustomerPromotionInput
    connect?: LoyaltyProgramWhereUniqueInput
  }

  export type PromotionRedemptionCreateNestedManyWithoutCustomerPromotionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput> | PromotionRedemptionCreateWithoutCustomerPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput | PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput[]
    createMany?: PromotionRedemptionCreateManyCustomerPromotionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerPromotionInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput> | PromotionRedemptionCreateWithoutCustomerPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput | PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput[]
    createMany?: PromotionRedemptionCreateManyCustomerPromotionInputEnvelope
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
  }

  export type EnumPromotionTypeFieldUpdateOperationsInput = {
    set?: $Enums.PromotionType
  }

  export type NullableEnumLoyaltyTierFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTier | null
  }

  export type LoyaltyProgramUpdateOneWithoutCustomerPromotionNestedInput = {
    create?: XOR<LoyaltyProgramCreateWithoutCustomerPromotionInput, LoyaltyProgramUncheckedCreateWithoutCustomerPromotionInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutCustomerPromotionInput
    upsert?: LoyaltyProgramUpsertWithoutCustomerPromotionInput
    disconnect?: LoyaltyProgramWhereInput | boolean
    delete?: LoyaltyProgramWhereInput | boolean
    connect?: LoyaltyProgramWhereUniqueInput
    update?: XOR<XOR<LoyaltyProgramUpdateToOneWithWhereWithoutCustomerPromotionInput, LoyaltyProgramUpdateWithoutCustomerPromotionInput>, LoyaltyProgramUncheckedUpdateWithoutCustomerPromotionInput>
  }

  export type PromotionRedemptionUpdateManyWithoutCustomerPromotionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput> | PromotionRedemptionCreateWithoutCustomerPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput | PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerPromotionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerPromotionInput[]
    createMany?: PromotionRedemptionCreateManyCustomerPromotionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerPromotionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerPromotionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutCustomerPromotionInput | PromotionRedemptionUpdateManyWithWhereWithoutCustomerPromotionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutCustomerPromotionNestedInput = {
    create?: XOR<PromotionRedemptionCreateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput> | PromotionRedemptionCreateWithoutCustomerPromotionInput[] | PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput[]
    connectOrCreate?: PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput | PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput[]
    upsert?: PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerPromotionInput | PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerPromotionInput[]
    createMany?: PromotionRedemptionCreateManyCustomerPromotionInputEnvelope
    set?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    disconnect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    delete?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    connect?: PromotionRedemptionWhereUniqueInput | PromotionRedemptionWhereUniqueInput[]
    update?: PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerPromotionInput | PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerPromotionInput[]
    updateMany?: PromotionRedemptionUpdateManyWithWhereWithoutCustomerPromotionInput | PromotionRedemptionUpdateManyWithWhereWithoutCustomerPromotionInput[]
    deleteMany?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutCustomerToGroupInput = {
    create?: XOR<CustomerCreateWithoutCustomerToGroupInput, CustomerUncheckedCreateWithoutCustomerToGroupInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerToGroupInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerGroupCreateNestedOneWithoutCustomerToGroupInput = {
    create?: XOR<CustomerGroupCreateWithoutCustomerToGroupInput, CustomerGroupUncheckedCreateWithoutCustomerToGroupInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutCustomerToGroupInput
    connect?: CustomerGroupWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerToGroupNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerToGroupInput, CustomerUncheckedCreateWithoutCustomerToGroupInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerToGroupInput
    upsert?: CustomerUpsertWithoutCustomerToGroupInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerToGroupInput, CustomerUpdateWithoutCustomerToGroupInput>, CustomerUncheckedUpdateWithoutCustomerToGroupInput>
  }

  export type CustomerGroupUpdateOneRequiredWithoutCustomerToGroupNestedInput = {
    create?: XOR<CustomerGroupCreateWithoutCustomerToGroupInput, CustomerGroupUncheckedCreateWithoutCustomerToGroupInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutCustomerToGroupInput
    upsert?: CustomerGroupUpsertWithoutCustomerToGroupInput
    connect?: CustomerGroupWhereUniqueInput
    update?: XOR<XOR<CustomerGroupUpdateToOneWithWhereWithoutCustomerToGroupInput, CustomerGroupUpdateWithoutCustomerToGroupInput>, CustomerGroupUncheckedUpdateWithoutCustomerToGroupInput>
  }

  export type LoyaltyProgramCreateNestedOneWithoutLoyaltyProgramRuleInput = {
    create?: XOR<LoyaltyProgramCreateWithoutLoyaltyProgramRuleInput, LoyaltyProgramUncheckedCreateWithoutLoyaltyProgramRuleInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutLoyaltyProgramRuleInput
    connect?: LoyaltyProgramWhereUniqueInput
  }

  export type EnumLoyaltyRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyRuleType
  }

  export type LoyaltyProgramUpdateOneRequiredWithoutLoyaltyProgramRuleNestedInput = {
    create?: XOR<LoyaltyProgramCreateWithoutLoyaltyProgramRuleInput, LoyaltyProgramUncheckedCreateWithoutLoyaltyProgramRuleInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutLoyaltyProgramRuleInput
    upsert?: LoyaltyProgramUpsertWithoutLoyaltyProgramRuleInput
    connect?: LoyaltyProgramWhereUniqueInput
    update?: XOR<XOR<LoyaltyProgramUpdateToOneWithWhereWithoutLoyaltyProgramRuleInput, LoyaltyProgramUpdateWithoutLoyaltyProgramRuleInput>, LoyaltyProgramUncheckedUpdateWithoutLoyaltyProgramRuleInput>
  }

  export type UserCreateNestedOneWithoutReceivedNotificationsInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedNotificationsInput
    upsert?: UserUpsertWithoutReceivedNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedNotificationsInput, UserUpdateWithoutReceivedNotificationsInput>, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserUpdateOneWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type CustomerCreateNestedOneWithoutPromotionRedemptionInput = {
    create?: XOR<CustomerCreateWithoutPromotionRedemptionInput, CustomerUncheckedCreateWithoutPromotionRedemptionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPromotionRedemptionInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerPromotionCreateNestedOneWithoutPromotionRedemptionInput = {
    create?: XOR<CustomerPromotionCreateWithoutPromotionRedemptionInput, CustomerPromotionUncheckedCreateWithoutPromotionRedemptionInput>
    connectOrCreate?: CustomerPromotionCreateOrConnectWithoutPromotionRedemptionInput
    connect?: CustomerPromotionWhereUniqueInput
  }

  export type SaleCreateNestedOneWithoutPromotionRedemptionInput = {
    create?: XOR<SaleCreateWithoutPromotionRedemptionInput, SaleUncheckedCreateWithoutPromotionRedemptionInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPromotionRedemptionInput
    connect?: SaleWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutPromotionRedemptionNestedInput = {
    create?: XOR<CustomerCreateWithoutPromotionRedemptionInput, CustomerUncheckedCreateWithoutPromotionRedemptionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPromotionRedemptionInput
    upsert?: CustomerUpsertWithoutPromotionRedemptionInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPromotionRedemptionInput, CustomerUpdateWithoutPromotionRedemptionInput>, CustomerUncheckedUpdateWithoutPromotionRedemptionInput>
  }

  export type CustomerPromotionUpdateOneRequiredWithoutPromotionRedemptionNestedInput = {
    create?: XOR<CustomerPromotionCreateWithoutPromotionRedemptionInput, CustomerPromotionUncheckedCreateWithoutPromotionRedemptionInput>
    connectOrCreate?: CustomerPromotionCreateOrConnectWithoutPromotionRedemptionInput
    upsert?: CustomerPromotionUpsertWithoutPromotionRedemptionInput
    connect?: CustomerPromotionWhereUniqueInput
    update?: XOR<XOR<CustomerPromotionUpdateToOneWithWhereWithoutPromotionRedemptionInput, CustomerPromotionUpdateWithoutPromotionRedemptionInput>, CustomerPromotionUncheckedUpdateWithoutPromotionRedemptionInput>
  }

  export type SaleUpdateOneRequiredWithoutPromotionRedemptionNestedInput = {
    create?: XOR<SaleCreateWithoutPromotionRedemptionInput, SaleUncheckedCreateWithoutPromotionRedemptionInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPromotionRedemptionInput
    upsert?: SaleUpsertWithoutPromotionRedemptionInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutPromotionRedemptionInput, SaleUpdateWithoutPromotionRedemptionInput>, SaleUncheckedUpdateWithoutPromotionRedemptionInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeFilter<$PrismaModel> | $Enums.TransferType
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierFilter<$PrismaModel> | $Enums.LoyaltyTier
  }

  export type NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
  }

  export type NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusFilter<$PrismaModel> | $Enums.AuditItemStatus
  }

  export type NestedEnumAuditItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditItemStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumPromotionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeFilter<$PrismaModel> | $Enums.PromotionType
  }

  export type NestedEnumLoyaltyTierNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoyaltyTierNullableFilter<$PrismaModel> | $Enums.LoyaltyTier | null
  }

  export type NestedEnumPromotionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionType | EnumPromotionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromotionType[] | ListEnumPromotionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromotionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromotionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromotionTypeFilter<$PrismaModel>
    _max?: NestedEnumPromotionTypeFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyTierNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoyaltyTierNullableWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierNullableFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierNullableFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyRuleType | EnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyRuleTypeFilter<$PrismaModel> | $Enums.LoyaltyRuleType
  }

  export type NestedEnumLoyaltyRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyRuleType | EnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyRuleType[] | ListEnumLoyaltyRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyRuleTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditCreateWithoutCreatedByInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutCreatedByInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditCreateManyCreatedByInputEnvelope = {
    data: AuditCreateManyCreatedByInput | AuditCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditAssignmentCreateWithoutUserInput = {
    id?: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutAssignmentsInput
  }

  export type AuditAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    auditId: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateOrConnectWithoutUserInput = {
    where: AuditAssignmentWhereUniqueInput
    create: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput>
  }

  export type AuditAssignmentCreateManyUserInputEnvelope = {
    data: AuditAssignmentCreateManyUserInput | AuditAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerNoteCreateWithoutCreatedByInput = {
    id?: string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerNoteInput
  }

  export type CustomerNoteUncheckedCreateWithoutCreatedByInput = {
    id?: string
    customerId: string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNoteCreateOrConnectWithoutCreatedByInput = {
    where: CustomerNoteWhereUniqueInput
    create: XOR<CustomerNoteCreateWithoutCreatedByInput, CustomerNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type CustomerNoteCreateManyCreatedByInputEnvelope = {
    data: CustomerNoteCreateManyCreatedByInput | CustomerNoteCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    receiver: UserCreateNestedOneWithoutReceivedNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutReceiverInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutReceiverInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    senderId?: string | null
  }

  export type NotificationCreateOrConnectWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput>
  }

  export type NotificationCreateManyReceiverInputEnvelope = {
    data: NotificationCreateManyReceiverInput | NotificationCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUser_Product_createdByIdToUserInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUser_Product_createdByIdToUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput>
  }

  export type ProductCreateManyUser_Product_createdByIdToUserInputEnvelope = {
    data: ProductCreateManyUser_Product_createdByIdToUserInput | ProductCreateManyUser_Product_createdByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUser_Product_updatedByIdToUserInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUser_Product_updatedByIdToUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput>
  }

  export type ProductCreateManyUser_Product_updatedByIdToUserInputEnvelope = {
    data: ProductCreateManyUser_Product_updatedByIdToUserInput | ProductCreateManyUser_Product_updatedByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    User_PurchaseOrder_updatedByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput>
  }

  export type PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInputEnvelope = {
    data: PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInput | PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_PurchaseOrder_createdByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput>
  }

  export type PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInputEnvelope = {
    data: PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInput | PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutCreatedByInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutSaleInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    store: StoreCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput>
  }

  export type SaleCreateManyCreatedByInputEnvelope = {
    data: SaleCreateManyCreatedByInput | SaleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StoreStaffCreateWithoutUserInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutStaffInput
  }

  export type StoreStaffUncheckedCreateWithoutUserInput = {
    id?: string
    storeId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffCreateOrConnectWithoutUserInput = {
    where: StoreStaffWhereUniqueInput
    create: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
  }

  export type SupplierCreateWithoutUser_Supplier_createdByIdToUserInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    User_Supplier_updatedByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_updatedByIdToUserInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutUser_Supplier_createdByIdToUserInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput>
  }

  export type SupplierCreateManyUser_Supplier_createdByIdToUserInputEnvelope = {
    data: SupplierCreateManyUser_Supplier_createdByIdToUserInput | SupplierCreateManyUser_Supplier_createdByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    User_Supplier_createdByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_createdByIdToUserInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutUser_Supplier_updatedByIdToUserInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput>
  }

  export type SupplierCreateManyUser_Supplier_updatedByIdToUserInputEnvelope = {
    data: SupplierCreateManyUser_Supplier_updatedByIdToUserInput | SupplierCreateManyUser_Supplier_updatedByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutUser_Transfer_approvedByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutUser_Transfer_approvedByIdToUserInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput>
  }

  export type TransferCreateManyUser_Transfer_approvedByIdToUserInputEnvelope = {
    data: TransferCreateManyUser_Transfer_approvedByIdToUserInput | TransferCreateManyUser_Transfer_approvedByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutUser_Transfer_createdByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutUser_Transfer_createdByIdToUserInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput>
  }

  export type TransferCreateManyUser_Transfer_createdByIdToUserInputEnvelope = {
    data: TransferCreateManyUser_Transfer_createdByIdToUserInput | TransferCreateManyUser_Transfer_createdByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutUser_Transfer_receivedByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutUser_Transfer_receivedByIdToUserInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput>
  }

  export type TransferCreateManyUser_Transfer_receivedByIdToUserInputEnvelope = {
    data: TransferCreateManyUser_Transfer_receivedByIdToUserInput | TransferCreateManyUser_Transfer_receivedByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseStaffCreateWithoutUserInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutStaffInput
  }

  export type WarehouseStaffUncheckedCreateWithoutUserInput = {
    id?: string
    warehouseId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffCreateOrConnectWithoutUserInput = {
    where: WarehouseStaffWhereUniqueInput
    create: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type AuditUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutCreatedByInput, AuditUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutCreatedByInput, AuditUncheckedUpdateWithoutCreatedByInput>
  }

  export type AuditUpdateManyWithWhereWithoutCreatedByInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuditScalarWhereInput = {
    AND?: AuditScalarWhereInput | AuditScalarWhereInput[]
    OR?: AuditScalarWhereInput[]
    NOT?: AuditScalarWhereInput | AuditScalarWhereInput[]
    id?: StringFilter<"Audit"> | string
    referenceNumber?: StringFilter<"Audit"> | string
    warehouseId?: StringFilter<"Audit"> | string
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    notes?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
  }

  export type AuditAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditAssignmentWhereUniqueInput
    update: XOR<AuditAssignmentUpdateWithoutUserInput, AuditAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput>
  }

  export type AuditAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditAssignmentWhereUniqueInput
    data: XOR<AuditAssignmentUpdateWithoutUserInput, AuditAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type AuditAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: AuditAssignmentScalarWhereInput
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditAssignmentScalarWhereInput = {
    AND?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
    OR?: AuditAssignmentScalarWhereInput[]
    NOT?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
    id?: StringFilter<"AuditAssignment"> | string
    auditId?: StringFilter<"AuditAssignment"> | string
    userId?: StringFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedAisles?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedShelves?: StringNullableFilter<"AuditAssignment"> | string | null
    assignedBins?: StringNullableFilter<"AuditAssignment"> | string | null
    createdAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AuditAssignment"> | Date | string
  }

  export type CustomerNoteUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CustomerNoteWhereUniqueInput
    update: XOR<CustomerNoteUpdateWithoutCreatedByInput, CustomerNoteUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CustomerNoteCreateWithoutCreatedByInput, CustomerNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type CustomerNoteUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CustomerNoteWhereUniqueInput
    data: XOR<CustomerNoteUpdateWithoutCreatedByInput, CustomerNoteUncheckedUpdateWithoutCreatedByInput>
  }

  export type CustomerNoteUpdateManyWithWhereWithoutCreatedByInput = {
    where: CustomerNoteScalarWhereInput
    data: XOR<CustomerNoteUpdateManyMutationInput, CustomerNoteUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CustomerNoteScalarWhereInput = {
    AND?: CustomerNoteScalarWhereInput | CustomerNoteScalarWhereInput[]
    OR?: CustomerNoteScalarWhereInput[]
    NOT?: CustomerNoteScalarWhereInput | CustomerNoteScalarWhereInput[]
    id?: StringFilter<"CustomerNote"> | string
    customerId?: StringFilter<"CustomerNote"> | string
    note?: StringFilter<"CustomerNote"> | string
    createdById?: StringFilter<"CustomerNote"> | string
    createdAt?: DateTimeFilter<"CustomerNote"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerNote"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    senderId?: StringNullableFilter<"Notification"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutReceiverInput, NotificationUncheckedUpdateWithoutReceiverInput>
    create: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutReceiverInput, NotificationUncheckedUpdateWithoutReceiverInput>
  }

  export type NotificationUpdateManyWithWhereWithoutReceiverInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutUser_Product_createdByIdToUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedUpdateWithoutUser_Product_createdByIdToUserInput>
    create: XOR<ProductCreateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_createdByIdToUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUser_Product_createdByIdToUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUser_Product_createdByIdToUserInput, ProductUncheckedUpdateWithoutUser_Product_createdByIdToUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUser_Product_createdByIdToUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    categoryId?: StringNullableFilter<"Product"> | string | null
    supplierId?: StringNullableFilter<"Product"> | string | null
    costPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"Product"> | string
    minStockLevel?: IntFilter<"Product"> | number
    maxStockLevel?: IntNullableFilter<"Product"> | number | null
    reorderPoint?: IntFilter<"Product"> | number
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: StringNullableFilter<"Product"> | string | null
    taxRate?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdById?: StringFilter<"Product"> | string
    updatedById?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedUpdateWithoutUser_Product_updatedByIdToUserInput>
    create: XOR<ProductCreateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedCreateWithoutUser_Product_updatedByIdToUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUser_Product_updatedByIdToUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUser_Product_updatedByIdToUserInput, ProductUncheckedUpdateWithoutUser_Product_updatedByIdToUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUser_Product_updatedByIdToUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedUpdateWithoutUser_PurchaseOrder_createdByIdToUserInput>
    create: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_createdByIdToUserInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutUser_PurchaseOrder_createdByIdToUserInput, PurchaseOrderUncheckedUpdateWithoutUser_PurchaseOrder_createdByIdToUserInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    warehouseId?: StringFilter<"PurchaseOrder"> | string
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    updatedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedUpdateWithoutUser_PurchaseOrder_updatedByIdToUserInput>
    create: XOR<PurchaseOrderCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedCreateWithoutUser_PurchaseOrder_updatedByIdToUserInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutUser_PurchaseOrder_updatedByIdToUserInput, PurchaseOrderUncheckedUpdateWithoutUser_PurchaseOrder_updatedByIdToUserInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCreatedByInput, SaleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCreatedByInput, SaleUncheckedUpdateWithoutCreatedByInput>
  }

  export type SaleUpdateManyWithWhereWithoutCreatedByInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    receiptNumber?: StringFilter<"Sale"> | string
    storeId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    createdById?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFilter<"Sale"> | number
    loyaltyPointsRedeemed?: IntFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type StoreStaffUpsertWithoutUserInput = {
    update: XOR<StoreStaffUpdateWithoutUserInput, StoreStaffUncheckedUpdateWithoutUserInput>
    create: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    where?: StoreStaffWhereInput
  }

  export type StoreStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: StoreStaffWhereInput
    data: XOR<StoreStaffUpdateWithoutUserInput, StoreStaffUncheckedUpdateWithoutUserInput>
  }

  export type StoreStaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StoreStaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedUpdateWithoutUser_Supplier_createdByIdToUserInput>
    create: XOR<SupplierCreateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_createdByIdToUserInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutUser_Supplier_createdByIdToUserInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutUser_Supplier_createdByIdToUserInput, SupplierUncheckedUpdateWithoutUser_Supplier_createdByIdToUserInput>
  }

  export type SupplierUpdateManyWithWhereWithoutUser_Supplier_createdByIdToUserInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    state?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdById?: StringFilter<"Supplier"> | string
    updatedById?: StringFilter<"Supplier"> | string
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedUpdateWithoutUser_Supplier_updatedByIdToUserInput>
    create: XOR<SupplierCreateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedCreateWithoutUser_Supplier_updatedByIdToUserInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutUser_Supplier_updatedByIdToUserInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutUser_Supplier_updatedByIdToUserInput, SupplierUncheckedUpdateWithoutUser_Supplier_updatedByIdToUserInput>
  }

  export type SupplierUpdateManyWithWhereWithoutUser_Supplier_updatedByIdToUserInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedUpdateWithoutUser_Transfer_approvedByIdToUserInput>
    create: XOR<TransferCreateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_approvedByIdToUserInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutUser_Transfer_approvedByIdToUserInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutUser_Transfer_approvedByIdToUserInput, TransferUncheckedUpdateWithoutUser_Transfer_approvedByIdToUserInput>
  }

  export type TransferUpdateManyWithWhereWithoutUser_Transfer_approvedByIdToUserInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    referenceNumber?: StringFilter<"Transfer"> | string
    type?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    sourceWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    destinationWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    sourceStoreId?: StringNullableFilter<"Transfer"> | string | null
    destinationStoreId?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    requestedDate?: DateTimeFilter<"Transfer"> | Date | string
    approvedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    shippedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdById?: StringFilter<"Transfer"> | string
    approvedById?: StringNullableFilter<"Transfer"> | string | null
    receivedById?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedUpdateWithoutUser_Transfer_createdByIdToUserInput>
    create: XOR<TransferCreateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_createdByIdToUserInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutUser_Transfer_createdByIdToUserInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutUser_Transfer_createdByIdToUserInput, TransferUncheckedUpdateWithoutUser_Transfer_createdByIdToUserInput>
  }

  export type TransferUpdateManyWithWhereWithoutUser_Transfer_createdByIdToUserInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedUpdateWithoutUser_Transfer_receivedByIdToUserInput>
    create: XOR<TransferCreateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedCreateWithoutUser_Transfer_receivedByIdToUserInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutUser_Transfer_receivedByIdToUserInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutUser_Transfer_receivedByIdToUserInput, TransferUncheckedUpdateWithoutUser_Transfer_receivedByIdToUserInput>
  }

  export type TransferUpdateManyWithWhereWithoutUser_Transfer_receivedByIdToUserInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserInput>
  }

  export type WarehouseStaffUpsertWithoutUserInput = {
    update: XOR<WarehouseStaffUpdateWithoutUserInput, WarehouseStaffUncheckedUpdateWithoutUserInput>
    create: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    where?: WarehouseStaffWhereInput
  }

  export type WarehouseStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: WarehouseStaffWhereInput
    data: XOR<WarehouseStaffUpdateWithoutUserInput, WarehouseStaffUncheckedUpdateWithoutUserInput>
  }

  export type WarehouseStaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutStaffNestedInput
  }

  export type WarehouseStaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AuditCreateWithoutWarehouseInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutWarehouseInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutWarehouseInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput>
  }

  export type AuditCreateManyWarehouseInputEnvelope = {
    data: AuditCreateManyWarehouseInput | AuditCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutWarehouseInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutWarehouseInput = {
    id?: string
    productId: string
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemCreateManyWarehouseInputEnvelope = {
    data: InventoryItemCreateManyWarehouseInput | InventoryItemCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutWarehouseInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_PurchaseOrder_createdByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    User_PurchaseOrder_updatedByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutWarehouseInput = {
    id?: string
    orderNumber: string
    supplierId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type PurchaseOrderCreateManyWarehouseInputEnvelope = {
    data: PurchaseOrderCreateManyWarehouseInput | PurchaseOrderCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInputEnvelope = {
    data: TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInput | TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInputEnvelope = {
    data: TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInput | TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseStaffCreateWithoutWarehouseInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWarehouseStaffInput
  }

  export type WarehouseStaffUncheckedCreateWithoutWarehouseInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffCreateOrConnectWithoutWarehouseInput = {
    where: WarehouseStaffWhereUniqueInput
    create: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseStaffCreateManyWarehouseInputEnvelope = {
    data: WarehouseStaffCreateManyWarehouseInput | WarehouseStaffCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseZoneCreateWithoutWarehouseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneUncheckedCreateWithoutWarehouseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleUncheckedCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneCreateOrConnectWithoutWarehouseInput = {
    where: WarehouseZoneWhereUniqueInput
    create: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseZoneCreateManyWarehouseInputEnvelope = {
    data: WarehouseZoneCreateManyWarehouseInput | WarehouseZoneCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type AuditUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutWarehouseInput, AuditUncheckedUpdateWithoutWarehouseInput>
    create: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutWarehouseInput, AuditUncheckedUpdateWithoutWarehouseInput>
  }

  export type AuditUpdateManyWithWhereWithoutWarehouseInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    productId?: StringFilter<"InventoryItem"> | string
    warehouseId?: StringNullableFilter<"InventoryItem"> | string | null
    storeId?: StringNullableFilter<"InventoryItem"> | string | null
    binId?: StringNullableFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQuantity?: IntFilter<"InventoryItem"> | number
    costPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFilter<"InventoryItem"> | $Enums.InventoryStatus
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutWarehouseInput, PurchaseOrderUncheckedUpdateWithoutWarehouseInput>
    create: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutWarehouseInput, PurchaseOrderUncheckedUpdateWithoutWarehouseInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedUpdateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput>
    create: XOR<TransferCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput, TransferUncheckedUpdateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type TransferUpdateManyWithWhereWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedUpdateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput>
    create: XOR<TransferCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedCreateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput, TransferUncheckedUpdateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type TransferUpdateManyWithWhereWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseStaffWhereUniqueInput
    update: XOR<WarehouseStaffUpdateWithoutWarehouseInput, WarehouseStaffUncheckedUpdateWithoutWarehouseInput>
    create: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseStaffWhereUniqueInput
    data: XOR<WarehouseStaffUpdateWithoutWarehouseInput, WarehouseStaffUncheckedUpdateWithoutWarehouseInput>
  }

  export type WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput = {
    where: WarehouseStaffScalarWhereInput
    data: XOR<WarehouseStaffUpdateManyMutationInput, WarehouseStaffUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseStaffScalarWhereInput = {
    AND?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
    OR?: WarehouseStaffScalarWhereInput[]
    NOT?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
    id?: StringFilter<"WarehouseStaff"> | string
    userId?: StringFilter<"WarehouseStaff"> | string
    warehouseId?: StringFilter<"WarehouseStaff"> | string
    position?: StringNullableFilter<"WarehouseStaff"> | string | null
    isManager?: BoolFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
  }

  export type WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseZoneWhereUniqueInput
    update: XOR<WarehouseZoneUpdateWithoutWarehouseInput, WarehouseZoneUncheckedUpdateWithoutWarehouseInput>
    create: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseZoneWhereUniqueInput
    data: XOR<WarehouseZoneUpdateWithoutWarehouseInput, WarehouseZoneUncheckedUpdateWithoutWarehouseInput>
  }

  export type WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput = {
    where: WarehouseZoneScalarWhereInput
    data: XOR<WarehouseZoneUpdateManyMutationInput, WarehouseZoneUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseZoneScalarWhereInput = {
    AND?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
    OR?: WarehouseZoneScalarWhereInput[]
    NOT?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
    id?: StringFilter<"WarehouseZone"> | string
    name?: StringFilter<"WarehouseZone"> | string
    code?: StringFilter<"WarehouseZone"> | string
    warehouseId?: StringFilter<"WarehouseZone"> | string
    description?: StringNullableFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseZone"> | Date | string
  }

  export type WarehouseAisleCreateWithoutZoneInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shelves?: WarehouseShelfCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleUncheckedCreateWithoutZoneInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shelves?: WarehouseShelfUncheckedCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleCreateOrConnectWithoutZoneInput = {
    where: WarehouseAisleWhereUniqueInput
    create: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput>
  }

  export type WarehouseAisleCreateManyZoneInputEnvelope = {
    data: WarehouseAisleCreateManyZoneInput | WarehouseAisleCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseCreateWithoutZonesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutZonesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
  }

  export type WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput = {
    where: WarehouseAisleWhereUniqueInput
    update: XOR<WarehouseAisleUpdateWithoutZoneInput, WarehouseAisleUncheckedUpdateWithoutZoneInput>
    create: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput>
  }

  export type WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput = {
    where: WarehouseAisleWhereUniqueInput
    data: XOR<WarehouseAisleUpdateWithoutZoneInput, WarehouseAisleUncheckedUpdateWithoutZoneInput>
  }

  export type WarehouseAisleUpdateManyWithWhereWithoutZoneInput = {
    where: WarehouseAisleScalarWhereInput
    data: XOR<WarehouseAisleUpdateManyMutationInput, WarehouseAisleUncheckedUpdateManyWithoutZoneInput>
  }

  export type WarehouseAisleScalarWhereInput = {
    AND?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
    OR?: WarehouseAisleScalarWhereInput[]
    NOT?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
    id?: StringFilter<"WarehouseAisle"> | string
    name?: StringFilter<"WarehouseAisle"> | string
    code?: StringFilter<"WarehouseAisle"> | string
    zoneId?: StringFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
  }

  export type WarehouseUpsertWithoutZonesInput = {
    update: XOR<WarehouseUpdateWithoutZonesInput, WarehouseUncheckedUpdateWithoutZonesInput>
    create: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutZonesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutZonesInput, WarehouseUncheckedUpdateWithoutZonesInput>
  }

  export type WarehouseUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseZoneCreateWithoutAislesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutZonesInput
  }

  export type WarehouseZoneUncheckedCreateWithoutAislesInput = {
    id?: string
    name: string
    code: string
    warehouseId: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseZoneCreateOrConnectWithoutAislesInput = {
    where: WarehouseZoneWhereUniqueInput
    create: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
  }

  export type WarehouseShelfCreateWithoutAisleInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfUncheckedCreateWithoutAisleInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinUncheckedCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfCreateOrConnectWithoutAisleInput = {
    where: WarehouseShelfWhereUniqueInput
    create: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput>
  }

  export type WarehouseShelfCreateManyAisleInputEnvelope = {
    data: WarehouseShelfCreateManyAisleInput | WarehouseShelfCreateManyAisleInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseZoneUpsertWithoutAislesInput = {
    update: XOR<WarehouseZoneUpdateWithoutAislesInput, WarehouseZoneUncheckedUpdateWithoutAislesInput>
    create: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
    where?: WarehouseZoneWhereInput
  }

  export type WarehouseZoneUpdateToOneWithWhereWithoutAislesInput = {
    where?: WarehouseZoneWhereInput
    data: XOR<WarehouseZoneUpdateWithoutAislesInput, WarehouseZoneUncheckedUpdateWithoutAislesInput>
  }

  export type WarehouseZoneUpdateWithoutAislesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutZonesNestedInput
  }

  export type WarehouseZoneUncheckedUpdateWithoutAislesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput = {
    where: WarehouseShelfWhereUniqueInput
    update: XOR<WarehouseShelfUpdateWithoutAisleInput, WarehouseShelfUncheckedUpdateWithoutAisleInput>
    create: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput>
  }

  export type WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput = {
    where: WarehouseShelfWhereUniqueInput
    data: XOR<WarehouseShelfUpdateWithoutAisleInput, WarehouseShelfUncheckedUpdateWithoutAisleInput>
  }

  export type WarehouseShelfUpdateManyWithWhereWithoutAisleInput = {
    where: WarehouseShelfScalarWhereInput
    data: XOR<WarehouseShelfUpdateManyMutationInput, WarehouseShelfUncheckedUpdateManyWithoutAisleInput>
  }

  export type WarehouseShelfScalarWhereInput = {
    AND?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
    OR?: WarehouseShelfScalarWhereInput[]
    NOT?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
    id?: StringFilter<"WarehouseShelf"> | string
    name?: StringFilter<"WarehouseShelf"> | string
    code?: StringFilter<"WarehouseShelf"> | string
    aisleId?: StringFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
  }

  export type WarehouseBinCreateWithoutShelfInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinUncheckedCreateWithoutShelfInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinCreateOrConnectWithoutShelfInput = {
    where: WarehouseBinWhereUniqueInput
    create: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput>
  }

  export type WarehouseBinCreateManyShelfInputEnvelope = {
    data: WarehouseBinCreateManyShelfInput | WarehouseBinCreateManyShelfInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseAisleCreateWithoutShelvesInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: WarehouseZoneCreateNestedOneWithoutAislesInput
  }

  export type WarehouseAisleUncheckedCreateWithoutShelvesInput = {
    id?: string
    name: string
    code: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseAisleCreateOrConnectWithoutShelvesInput = {
    where: WarehouseAisleWhereUniqueInput
    create: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
  }

  export type WarehouseBinUpsertWithWhereUniqueWithoutShelfInput = {
    where: WarehouseBinWhereUniqueInput
    update: XOR<WarehouseBinUpdateWithoutShelfInput, WarehouseBinUncheckedUpdateWithoutShelfInput>
    create: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput>
  }

  export type WarehouseBinUpdateWithWhereUniqueWithoutShelfInput = {
    where: WarehouseBinWhereUniqueInput
    data: XOR<WarehouseBinUpdateWithoutShelfInput, WarehouseBinUncheckedUpdateWithoutShelfInput>
  }

  export type WarehouseBinUpdateManyWithWhereWithoutShelfInput = {
    where: WarehouseBinScalarWhereInput
    data: XOR<WarehouseBinUpdateManyMutationInput, WarehouseBinUncheckedUpdateManyWithoutShelfInput>
  }

  export type WarehouseBinScalarWhereInput = {
    AND?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
    OR?: WarehouseBinScalarWhereInput[]
    NOT?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
    id?: StringFilter<"WarehouseBin"> | string
    name?: StringFilter<"WarehouseBin"> | string
    code?: StringFilter<"WarehouseBin"> | string
    shelfId?: StringFilter<"WarehouseBin"> | string
    capacity?: IntNullableFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseBin"> | Date | string
  }

  export type WarehouseAisleUpsertWithoutShelvesInput = {
    update: XOR<WarehouseAisleUpdateWithoutShelvesInput, WarehouseAisleUncheckedUpdateWithoutShelvesInput>
    create: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
    where?: WarehouseAisleWhereInput
  }

  export type WarehouseAisleUpdateToOneWithWhereWithoutShelvesInput = {
    where?: WarehouseAisleWhereInput
    data: XOR<WarehouseAisleUpdateWithoutShelvesInput, WarehouseAisleUncheckedUpdateWithoutShelvesInput>
  }

  export type WarehouseAisleUpdateWithoutShelvesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: WarehouseZoneUpdateOneRequiredWithoutAislesNestedInput
  }

  export type WarehouseAisleUncheckedUpdateWithoutShelvesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateWithoutBinInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutBinInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutBinInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput>
  }

  export type InventoryItemCreateManyBinInputEnvelope = {
    data: InventoryItemCreateManyBinInput | InventoryItemCreateManyBinInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseShelfCreateWithoutBinsInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aisle: WarehouseAisleCreateNestedOneWithoutShelvesInput
  }

  export type WarehouseShelfUncheckedCreateWithoutBinsInput = {
    id?: string
    name: string
    code: string
    aisleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseShelfCreateOrConnectWithoutBinsInput = {
    where: WarehouseShelfWhereUniqueInput
    create: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutBinInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutBinInput, InventoryItemUncheckedUpdateWithoutBinInput>
    create: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutBinInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutBinInput, InventoryItemUncheckedUpdateWithoutBinInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutBinInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutBinInput>
  }

  export type WarehouseShelfUpsertWithoutBinsInput = {
    update: XOR<WarehouseShelfUpdateWithoutBinsInput, WarehouseShelfUncheckedUpdateWithoutBinsInput>
    create: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
    where?: WarehouseShelfWhereInput
  }

  export type WarehouseShelfUpdateToOneWithWhereWithoutBinsInput = {
    where?: WarehouseShelfWhereInput
    data: XOR<WarehouseShelfUpdateWithoutBinsInput, WarehouseShelfUncheckedUpdateWithoutBinsInput>
  }

  export type WarehouseShelfUpdateWithoutBinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisle?: WarehouseAisleUpdateOneRequiredWithoutShelvesNestedInput
  }

  export type WarehouseShelfUncheckedUpdateWithoutBinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    aisleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWarehouseStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
  }

  export type UserUncheckedCreateWithoutWarehouseStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
  }

  export type UserCreateOrConnectWithoutWarehouseStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
  }

  export type WarehouseCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStaffInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
  }

  export type UserUpsertWithoutWarehouseStaffInput = {
    update: XOR<UserUpdateWithoutWarehouseStaffInput, UserUncheckedUpdateWithoutWarehouseStaffInput>
    create: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWarehouseStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWarehouseStaffInput, UserUncheckedUpdateWithoutWarehouseStaffInput>
  }

  export type UserUpdateWithoutWarehouseStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWarehouseStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
  }

  export type WarehouseUpsertWithoutStaffInput = {
    update: XOR<WarehouseUpdateWithoutStaffInput, WarehouseUncheckedUpdateWithoutStaffInput>
    create: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStaffInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStaffInput, WarehouseUncheckedUpdateWithoutStaffInput>
  }

  export type WarehouseUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type InventoryItemCreateWithoutStoreInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutStoreInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutStoreInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput>
  }

  export type InventoryItemCreateManyStoreInputEnvelope = {
    data: InventoryItemCreateManyStoreInput | InventoryItemCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutStoreInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutStoreInput = {
    id?: string
    receiptNumber: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutStoreInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput>
  }

  export type SaleCreateManyStoreInputEnvelope = {
    data: SaleCreateManyStoreInput | SaleCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreStaffCreateWithoutStoreInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStoreStaffInput
  }

  export type StoreStaffUncheckedCreateWithoutStoreInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffCreateOrConnectWithoutStoreInput = {
    where: StoreStaffWhereUniqueInput
    create: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput>
  }

  export type StoreStaffCreateManyStoreInputEnvelope = {
    data: StoreStaffCreateManyStoreInput | StoreStaffCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput>
  }

  export type TransferCreateManyStore_Transfer_destinationStoreIdToStoreInputEnvelope = {
    data: TransferCreateManyStore_Transfer_destinationStoreIdToStoreInput | TransferCreateManyStore_Transfer_destinationStoreIdToStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput>
  }

  export type TransferCreateManyStore_Transfer_sourceStoreIdToStoreInputEnvelope = {
    data: TransferCreateManyStore_Transfer_sourceStoreIdToStoreInput | TransferCreateManyStore_Transfer_sourceStoreIdToStoreInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutStoreInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutStoreInput, InventoryItemUncheckedUpdateWithoutStoreInput>
    create: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutStoreInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutStoreInput, InventoryItemUncheckedUpdateWithoutStoreInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutStoreInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutStoreInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutStoreInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutStoreInput, SaleUncheckedUpdateWithoutStoreInput>
    create: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutStoreInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutStoreInput, SaleUncheckedUpdateWithoutStoreInput>
  }

  export type SaleUpdateManyWithWhereWithoutStoreInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreStaffUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreStaffWhereUniqueInput
    update: XOR<StoreStaffUpdateWithoutStoreInput, StoreStaffUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput>
  }

  export type StoreStaffUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreStaffWhereUniqueInput
    data: XOR<StoreStaffUpdateWithoutStoreInput, StoreStaffUncheckedUpdateWithoutStoreInput>
  }

  export type StoreStaffUpdateManyWithWhereWithoutStoreInput = {
    where: StoreStaffScalarWhereInput
    data: XOR<StoreStaffUpdateManyMutationInput, StoreStaffUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreStaffScalarWhereInput = {
    AND?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
    OR?: StoreStaffScalarWhereInput[]
    NOT?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
    id?: StringFilter<"StoreStaff"> | string
    userId?: StringFilter<"StoreStaff"> | string
    storeId?: StringFilter<"StoreStaff"> | string
    position?: StringNullableFilter<"StoreStaff"> | string | null
    isManager?: BoolFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStaff"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedUpdateWithoutStore_Transfer_destinationStoreIdToStoreInput>
    create: XOR<TransferCreateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_destinationStoreIdToStoreInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutStore_Transfer_destinationStoreIdToStoreInput, TransferUncheckedUpdateWithoutStore_Transfer_destinationStoreIdToStoreInput>
  }

  export type TransferUpdateManyWithWhereWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedUpdateWithoutStore_Transfer_sourceStoreIdToStoreInput>
    create: XOR<TransferCreateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedCreateWithoutStore_Transfer_sourceStoreIdToStoreInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutStore_Transfer_sourceStoreIdToStoreInput, TransferUncheckedUpdateWithoutStore_Transfer_sourceStoreIdToStoreInput>
  }

  export type TransferUpdateManyWithWhereWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreInput>
  }

  export type StoreCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreCreateOrConnectWithoutStaffInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
  }

  export type UserCreateWithoutStoreStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoreStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoreStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
  }

  export type StoreUpsertWithoutStaffInput = {
    update: XOR<StoreUpdateWithoutStaffInput, StoreUncheckedUpdateWithoutStaffInput>
    create: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStaffInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStaffInput, StoreUncheckedUpdateWithoutStaffInput>
  }

  export type StoreUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type UserUpsertWithoutStoreStaffInput = {
    update: XOR<UserUpdateWithoutStoreStaffInput, UserUncheckedUpdateWithoutStoreStaffInput>
    create: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreStaffInput, UserUncheckedUpdateWithoutStoreStaffInput>
  }

  export type UserUpdateWithoutStoreStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProductCreateWithoutSupplierInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSupplierInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductCreateManySupplierInputEnvelope = {
    data: ProductCreateManySupplierInput | ProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_PurchaseOrder_createdByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    User_PurchaseOrder_updatedByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSupplier_Supplier_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupplier_Supplier_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupplier_Supplier_createdByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupplier_Supplier_createdByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_createdByIdToUserInput>
  }

  export type UserCreateWithoutSupplier_Supplier_updatedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupplier_Supplier_updatedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupplier_Supplier_updatedByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupplier_Supplier_updatedByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_updatedByIdToUserInput>
  }

  export type SupplierContractCreateWithoutSupplierInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractUncheckedCreateWithoutSupplierInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractCreateOrConnectWithoutSupplierInput = {
    where: SupplierContractWhereUniqueInput
    create: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierContractCreateManySupplierInputEnvelope = {
    data: SupplierContractCreateManySupplierInput | SupplierContractCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
  }

  export type ProductUpdateManyWithWhereWithoutSupplierInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type UserUpsertWithoutSupplier_Supplier_createdByIdToUserInput = {
    update: XOR<UserUpdateWithoutSupplier_Supplier_createdByIdToUserInput, UserUncheckedUpdateWithoutSupplier_Supplier_createdByIdToUserInput>
    create: XOR<UserCreateWithoutSupplier_Supplier_createdByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_createdByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupplier_Supplier_createdByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupplier_Supplier_createdByIdToUserInput, UserUncheckedUpdateWithoutSupplier_Supplier_createdByIdToUserInput>
  }

  export type UserUpdateWithoutSupplier_Supplier_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupplier_Supplier_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutSupplier_Supplier_updatedByIdToUserInput = {
    update: XOR<UserUpdateWithoutSupplier_Supplier_updatedByIdToUserInput, UserUncheckedUpdateWithoutSupplier_Supplier_updatedByIdToUserInput>
    create: XOR<UserCreateWithoutSupplier_Supplier_updatedByIdToUserInput, UserUncheckedCreateWithoutSupplier_Supplier_updatedByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupplier_Supplier_updatedByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupplier_Supplier_updatedByIdToUserInput, UserUncheckedUpdateWithoutSupplier_Supplier_updatedByIdToUserInput>
  }

  export type UserUpdateWithoutSupplier_Supplier_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupplier_Supplier_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SupplierContractUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierContractWhereUniqueInput
    update: XOR<SupplierContractUpdateWithoutSupplierInput, SupplierContractUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierContractUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierContractWhereUniqueInput
    data: XOR<SupplierContractUpdateWithoutSupplierInput, SupplierContractUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierContractUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierContractScalarWhereInput
    data: XOR<SupplierContractUpdateManyMutationInput, SupplierContractUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierContractScalarWhereInput = {
    AND?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
    OR?: SupplierContractScalarWhereInput[]
    NOT?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
    id?: StringFilter<"SupplierContract"> | string
    supplierId?: StringFilter<"SupplierContract"> | string
    startDate?: DateTimeFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    terms?: StringNullableFilter<"SupplierContract"> | string | null
    attachments?: StringNullableFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierContract"> | Date | string
  }

  export type SupplierCreateWithoutContractsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    User_Supplier_createdByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_createdByIdToUserInput
    User_Supplier_updatedByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_updatedByIdToUserInput
  }

  export type SupplierUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutContractsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
  }

  export type SupplierUpsertWithoutContractsInput = {
    update: XOR<SupplierUpdateWithoutContractsInput, SupplierUncheckedUpdateWithoutContractsInput>
    create: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutContractsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutContractsInput, SupplierUncheckedUpdateWithoutContractsInput>
  }

  export type SupplierUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    User_Supplier_createdByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_createdByIdToUserNestedInput
    User_Supplier_updatedByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_updatedByIdToUserNestedInput
  }

  export type SupplierUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    User_Supplier_createdByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_createdByIdToUserInput
    User_Supplier_updatedByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_updatedByIdToUserInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type UserCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
  }

  export type WarehouseCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutPurchaseOrdersInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    id?: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    productId: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    update: XOR<UserUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
    create: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput, UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput>
  }

  export type UserUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    User_Supplier_createdByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_createdByIdToUserNestedInput
    User_Supplier_updatedByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_updatedByIdToUserNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserUpsertWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    update: XOR<UserUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
    create: XOR<UserCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUncheckedCreateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput, UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput>
  }

  export type UserUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WarehouseUpsertWithoutPurchaseOrdersInput = {
    update: XOR<WarehouseUpdateWithoutPurchaseOrdersInput, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutPurchaseOrdersInput, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type WarehouseUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    orderedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"PurchaseOrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
  }

  export type ProductCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_PurchaseOrder_createdByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    User_PurchaseOrder_updatedByIdToUser?: UserCreateNestedOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ProductUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_PurchaseOrder_createdByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    User_PurchaseOrder_updatedByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateWithoutProductInput = {
    id?: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateWithoutProductInput = {
    id?: string
    auditId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateOrConnectWithoutProductInput = {
    where: AuditItemWhereUniqueInput
    create: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput>
  }

  export type AuditItemCreateManyProductInputEnvelope = {
    data: AuditItemCreateManyProductInput | AuditItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutProductInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutProductInput = {
    id?: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput>
  }

  export type InventoryItemCreateManyProductInputEnvelope = {
    data: InventoryItemCreateManyProductInput | InventoryItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type UserCreateWithoutProduct_Product_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProduct_Product_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProduct_Product_createdByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProduct_Product_createdByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_createdByIdToUserInput>
  }

  export type SupplierCreateWithoutProductsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    User_Supplier_createdByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_createdByIdToUserInput
    User_Supplier_updatedByIdToUser: UserCreateNestedOneWithoutSupplier_Supplier_updatedByIdToUserInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutProductsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
  }

  export type UserCreateWithoutProduct_Product_updatedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProduct_Product_updatedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProduct_Product_updatedByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProduct_Product_updatedByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_updatedByIdToUserInput>
  }

  export type PurchaseOrderItemCreateWithoutProductInput = {
    id?: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseOrderId: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemCreateManyProductInputEnvelope = {
    data: PurchaseOrderItemCreateManyProductInput | PurchaseOrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
    sale: SaleCreateNestedOneWithoutItemsInput
  }

  export type SaleItemUncheckedCreateWithoutProductInput = {
    id?: string
    saleId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemCreateManyProductInputEnvelope = {
    data: SaleItemCreateManyProductInput | SaleItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutProductInput = {
    id?: string
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
    transfer: TransferCreateNestedOneWithoutItemsInput
  }

  export type TransferItemUncheckedCreateWithoutProductInput = {
    id?: string
    transferId: string
    sourceInventoryId?: string | null
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput>
  }

  export type TransferItemCreateManyProductInputEnvelope = {
    data: TransferItemCreateManyProductInput | TransferItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AuditItemUpsertWithWhereUniqueWithoutProductInput = {
    where: AuditItemWhereUniqueInput
    update: XOR<AuditItemUpdateWithoutProductInput, AuditItemUncheckedUpdateWithoutProductInput>
    create: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput>
  }

  export type AuditItemUpdateWithWhereUniqueWithoutProductInput = {
    where: AuditItemWhereUniqueInput
    data: XOR<AuditItemUpdateWithoutProductInput, AuditItemUncheckedUpdateWithoutProductInput>
  }

  export type AuditItemUpdateManyWithWhereWithoutProductInput = {
    where: AuditItemScalarWhereInput
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyWithoutProductInput>
  }

  export type AuditItemScalarWhereInput = {
    AND?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
    OR?: AuditItemScalarWhereInput[]
    NOT?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
    id?: StringFilter<"AuditItem"> | string
    auditId?: StringFilter<"AuditItem"> | string
    productId?: StringFilter<"AuditItem"> | string
    inventoryItemId?: StringFilter<"AuditItem"> | string
    expectedQuantity?: IntFilter<"AuditItem"> | number
    actualQuantity?: IntNullableFilter<"AuditItem"> | number | null
    variance?: IntNullableFilter<"AuditItem"> | number | null
    notes?: StringNullableFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusFilter<"AuditItem"> | $Enums.AuditItemStatus
    createdAt?: DateTimeFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditItem"> | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutProductInput, InventoryItemUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutProductInput, InventoryItemUncheckedUpdateWithoutProductInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutProductInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutProduct_Product_createdByIdToUserInput = {
    update: XOR<UserUpdateWithoutProduct_Product_createdByIdToUserInput, UserUncheckedUpdateWithoutProduct_Product_createdByIdToUserInput>
    create: XOR<UserCreateWithoutProduct_Product_createdByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_createdByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProduct_Product_createdByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProduct_Product_createdByIdToUserInput, UserUncheckedUpdateWithoutProduct_Product_createdByIdToUserInput>
  }

  export type UserUpdateWithoutProduct_Product_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProduct_Product_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SupplierUpsertWithoutProductsInput = {
    update: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutProductsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type SupplierUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    User_Supplier_createdByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_createdByIdToUserNestedInput
    User_Supplier_updatedByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_updatedByIdToUserNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type UserUpsertWithoutProduct_Product_updatedByIdToUserInput = {
    update: XOR<UserUpdateWithoutProduct_Product_updatedByIdToUserInput, UserUncheckedUpdateWithoutProduct_Product_updatedByIdToUserInput>
    create: XOR<UserCreateWithoutProduct_Product_updatedByIdToUserInput, UserUncheckedCreateWithoutProduct_Product_updatedByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProduct_Product_updatedByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProduct_Product_updatedByIdToUserInput, UserUncheckedUpdateWithoutProduct_Product_updatedByIdToUserInput>
  }

  export type UserUpdateWithoutProduct_Product_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProduct_Product_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutProductInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleItemScalarWhereInput = {
    AND?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    OR?: SaleItemScalarWhereInput[]
    NOT?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    inventoryItemId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeFilter<"SaleItem"> | Date | string
  }

  export type TransferItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutProductInput, TransferItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutProductInput, TransferItemUncheckedUpdateWithoutProductInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutProductInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransferItemScalarWhereInput = {
    AND?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
    OR?: TransferItemScalarWhereInput[]
    NOT?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
    id?: StringFilter<"TransferItem"> | string
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    sourceInventoryId?: StringNullableFilter<"TransferItem"> | string | null
    destinationInventoryId?: StringNullableFilter<"TransferItem"> | string | null
    requestedQuantity?: IntFilter<"TransferItem"> | number
    approvedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    shippedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    receivedQuantity?: IntNullableFilter<"TransferItem"> | number | null
    sourceCostPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFilter<"TransferItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"TransferItem"> | string | null
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
  }

  export type CategoryCreateWithoutOther_CategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Category?: CategoryCreateNestedOneWithoutOther_CategoryInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutOther_CategoryInput = {
    id?: string
    name: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutOther_CategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
  }

  export type CategoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    other_Category?: CategoryCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    other_Category?: CategoryUncheckedCreateNestedManyWithoutCategoryInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryCreateManyCategoryInputEnvelope = {
    data: CategoryCreateManyCategoryInput | CategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutOther_CategoryInput = {
    update: XOR<CategoryUpdateWithoutOther_CategoryInput, CategoryUncheckedUpdateWithoutOther_CategoryInput>
    create: XOR<CategoryCreateWithoutOther_CategoryInput, CategoryUncheckedCreateWithoutOther_CategoryInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutOther_CategoryInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutOther_CategoryInput, CategoryUncheckedUpdateWithoutOther_CategoryInput>
  }

  export type CategoryUpdateWithoutOther_CategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: CategoryUpdateOneWithoutOther_CategoryNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutOther_CategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutCategoryInput, CategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryCreateWithoutCategoryInput, CategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutCategoryInput, CategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type AuditItemCreateWithoutInventoryItemInput = {
    id?: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    auditId: string
    productId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateOrConnectWithoutInventoryItemInput = {
    where: AuditItemWhereUniqueInput
    create: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type AuditItemCreateManyInventoryItemInputEnvelope = {
    data: AuditItemCreateManyInventoryItemInput | AuditItemCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseBinCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shelf: WarehouseShelfCreateNestedOneWithoutBinsInput
  }

  export type WarehouseBinUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    shelfId: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseBinCreateOrConnectWithoutInventoryItemsInput = {
    where: WarehouseBinWhereUniqueInput
    create: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
  }

  export type ProductCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
  }

  export type StoreCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreCreateOrConnectWithoutInventoryItemsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
  }

  export type WarehouseCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryItemsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
  }

  export type SaleItemCreateWithoutInventoryItemInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSaleItemsInput
    sale: SaleCreateNestedOneWithoutItemsInput
  }

  export type SaleItemUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    saleId: string
    productId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutInventoryItemInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type SaleItemCreateManyInventoryItemInputEnvelope = {
    data: SaleItemCreateManyInventoryItemInput | SaleItemCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: string
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTransferItemsInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
    transfer: TransferCreateNestedOneWithoutItemsInput
  }

  export type TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: string
    transferId: string
    productId: string
    sourceInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInputEnvelope = {
    data: TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput | TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: string
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    product: ProductCreateNestedOneWithoutTransferItemsInput
    transfer: TransferCreateNestedOneWithoutItemsInput
  }

  export type TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: string
    transferId: string
    productId: string
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInputEnvelope = {
    data: TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput | TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: AuditItemWhereUniqueInput
    update: XOR<AuditItemUpdateWithoutInventoryItemInput, AuditItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: AuditItemWhereUniqueInput
    data: XOR<AuditItemUpdateWithoutInventoryItemInput, AuditItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type AuditItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: AuditItemScalarWhereInput
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type WarehouseBinUpsertWithoutInventoryItemsInput = {
    update: XOR<WarehouseBinUpdateWithoutInventoryItemsInput, WarehouseBinUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
    where?: WarehouseBinWhereInput
  }

  export type WarehouseBinUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: WarehouseBinWhereInput
    data: XOR<WarehouseBinUpdateWithoutInventoryItemsInput, WarehouseBinUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseBinUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelf?: WarehouseShelfUpdateOneRequiredWithoutBinsNestedInput
  }

  export type WarehouseBinUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutInventoryItemsInput = {
    update: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreUpsertWithoutInventoryItemsInput = {
    update: XOR<StoreUpdateWithoutInventoryItemsInput, StoreUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutInventoryItemsInput, StoreUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type StoreUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type WarehouseUpsertWithoutInventoryItemsInput = {
    update: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutInventoryItemInput, SaleItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutInventoryItemInput, SaleItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedUpdateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput>
    create: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput, TransferItemUncheckedUpdateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type TransferItemUpsertWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedUpdateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput>
    create: XOR<TransferItemCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedCreateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput, TransferItemUncheckedUpdateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type LoyaltyTransactionCreateWithoutSaleInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLoyaltyTransactionsInput
    program: LoyaltyProgramCreateNestedOneWithoutTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutSaleInput = {
    id?: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutSaleInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutSaleInput, LoyaltyTransactionUncheckedCreateWithoutSaleInput>
  }

  export type LoyaltyTransactionCreateManySaleInputEnvelope = {
    data: LoyaltyTransactionCreateManySaleInput | LoyaltyTransactionCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionCreateWithoutSaleInput = {
    id: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Customer: CustomerCreateNestedOneWithoutPromotionRedemptionInput
    CustomerPromotion: CustomerPromotionCreateNestedOneWithoutPromotionRedemptionInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutSaleInput = {
    id: string
    promotionId: string
    customerId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutSaleInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutSaleInput, PromotionRedemptionUncheckedCreateWithoutSaleInput>
  }

  export type PromotionRedemptionCreateManySaleInputEnvelope = {
    data: PromotionRedemptionCreateManySaleInput | PromotionRedemptionCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedSalesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSalesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type StoreCreateWithoutSalesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreCreateOrConnectWithoutSalesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
  }

  export type SaleItemCreateWithoutSaleInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutSaleInput = {
    id?: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemCreateManySaleInputEnvelope = {
    data: SaleItemCreateManySaleInput | SaleItemCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutSaleInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutSaleInput, LoyaltyTransactionUncheckedUpdateWithoutSaleInput>
    create: XOR<LoyaltyTransactionCreateWithoutSaleInput, LoyaltyTransactionUncheckedCreateWithoutSaleInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutSaleInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutSaleInput, LoyaltyTransactionUncheckedUpdateWithoutSaleInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutSaleInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutSaleInput>
  }

  export type LoyaltyTransactionScalarWhereInput = {
    AND?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
    OR?: LoyaltyTransactionScalarWhereInput[]
    NOT?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
    id?: StringFilter<"LoyaltyTransaction"> | string
    customerId?: StringFilter<"LoyaltyTransaction"> | string
    programId?: StringFilter<"LoyaltyTransaction"> | string
    points?: IntFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    expiryDate?: DateTimeNullableFilter<"LoyaltyTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutSaleInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutSaleInput, PromotionRedemptionUncheckedUpdateWithoutSaleInput>
    create: XOR<PromotionRedemptionCreateWithoutSaleInput, PromotionRedemptionUncheckedCreateWithoutSaleInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutSaleInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutSaleInput, PromotionRedemptionUncheckedUpdateWithoutSaleInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutSaleInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutSaleInput>
  }

  export type PromotionRedemptionScalarWhereInput = {
    AND?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
    OR?: PromotionRedemptionScalarWhereInput[]
    NOT?: PromotionRedemptionScalarWhereInput | PromotionRedemptionScalarWhereInput[]
    id?: StringFilter<"PromotionRedemption"> | string
    promotionId?: StringFilter<"PromotionRedemption"> | string
    customerId?: StringFilter<"PromotionRedemption"> | string
    saleId?: StringFilter<"PromotionRedemption"> | string
    discountAmount?: DecimalFilter<"PromotionRedemption"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PromotionRedemption"> | Date | string
  }

  export type UserUpsertWithoutCreatedSalesInput = {
    update: XOR<UserUpdateWithoutCreatedSalesInput, UserUncheckedUpdateWithoutCreatedSalesInput>
    create: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSalesInput, UserUncheckedUpdateWithoutCreatedSalesInput>
  }

  export type UserUpdateWithoutCreatedSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreUpsertWithoutSalesInput = {
    update: XOR<StoreUpdateWithoutSalesInput, StoreUncheckedUpdateWithoutSalesInput>
    create: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSalesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSalesInput, StoreUncheckedUpdateWithoutSalesInput>
  }

  export type StoreUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type SaleItemUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutSaleInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutSaleInput>
  }

  export type InventoryItemCreateWithoutSaleItemsInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutSaleItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
  }

  export type ProductCreateWithoutSaleItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSaleItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
  }

  export type SaleCreateWithoutItemsInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    store: StoreCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutItemsInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutItemsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
  }

  export type InventoryItemUpsertWithoutSaleItemsInput = {
    update: XOR<InventoryItemUpdateWithoutSaleItemsInput, InventoryItemUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutSaleItemsInput, InventoryItemUncheckedUpdateWithoutSaleItemsInput>
  }

  export type InventoryItemUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type ProductUpsertWithoutSaleItemsInput = {
    update: XOR<ProductUpdateWithoutSaleItemsInput, ProductUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSaleItemsInput, ProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ProductUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SaleUpsertWithoutItemsInput = {
    update: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutItemsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type SaleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type UserCreateWithoutTransfer_Transfer_approvedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransfer_Transfer_approvedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransfer_Transfer_approvedByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransfer_Transfer_approvedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_approvedByIdToUserInput>
  }

  export type UserCreateWithoutTransfer_Transfer_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransfer_Transfer_createdByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransfer_Transfer_createdByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransfer_Transfer_createdByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_createdByIdToUserInput>
  }

  export type StoreCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreUncheckedCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_sourceStoreIdToStoreInput
  }

  export type StoreCreateOrConnectWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
  }

  export type WarehouseCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type UserCreateWithoutTransfer_Transfer_receivedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransfer_Transfer_receivedByIdToUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransfer_Transfer_receivedByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransfer_Transfer_receivedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_receivedByIdToUserInput>
  }

  export type StoreCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
  }

  export type StoreUncheckedCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedCreateNestedManyWithoutStore_Transfer_destinationStoreIdToStoreInput
  }

  export type StoreCreateOrConnectWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
  }

  export type WarehouseCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type TransferItemCreateWithoutTransferInput = {
    id?: string
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput
    product: ProductCreateNestedOneWithoutTransferItemsInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemCreateNestedOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type TransferItemUncheckedCreateWithoutTransferInput = {
    id?: string
    productId: string
    sourceInventoryId?: string | null
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput>
  }

  export type TransferItemCreateManyTransferInputEnvelope = {
    data: TransferItemCreateManyTransferInput | TransferItemCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTransfer_Transfer_approvedByIdToUserInput = {
    update: XOR<UserUpdateWithoutTransfer_Transfer_approvedByIdToUserInput, UserUncheckedUpdateWithoutTransfer_Transfer_approvedByIdToUserInput>
    create: XOR<UserCreateWithoutTransfer_Transfer_approvedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_approvedByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransfer_Transfer_approvedByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransfer_Transfer_approvedByIdToUserInput, UserUncheckedUpdateWithoutTransfer_Transfer_approvedByIdToUserInput>
  }

  export type UserUpdateWithoutTransfer_Transfer_approvedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransfer_Transfer_approvedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutTransfer_Transfer_createdByIdToUserInput = {
    update: XOR<UserUpdateWithoutTransfer_Transfer_createdByIdToUserInput, UserUncheckedUpdateWithoutTransfer_Transfer_createdByIdToUserInput>
    create: XOR<UserCreateWithoutTransfer_Transfer_createdByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_createdByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransfer_Transfer_createdByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransfer_Transfer_createdByIdToUserInput, UserUncheckedUpdateWithoutTransfer_Transfer_createdByIdToUserInput>
  }

  export type UserUpdateWithoutTransfer_Transfer_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransfer_Transfer_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StoreUpsertWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    update: XOR<StoreUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUncheckedUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
    create: XOR<StoreCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput, StoreUncheckedUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput>
  }

  export type StoreUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTransfer_Transfer_destinationStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_sourceStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreNestedInput
  }

  export type WarehouseUpsertWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    update: XOR<WarehouseUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUncheckedUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
    create: XOR<WarehouseCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput, WarehouseUncheckedUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput>
  }

  export type WarehouseUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutTransfer_Transfer_receivedByIdToUserInput = {
    update: XOR<UserUpdateWithoutTransfer_Transfer_receivedByIdToUserInput, UserUncheckedUpdateWithoutTransfer_Transfer_receivedByIdToUserInput>
    create: XOR<UserCreateWithoutTransfer_Transfer_receivedByIdToUserInput, UserUncheckedCreateWithoutTransfer_Transfer_receivedByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransfer_Transfer_receivedByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransfer_Transfer_receivedByIdToUserInput, UserUncheckedUpdateWithoutTransfer_Transfer_receivedByIdToUserInput>
  }

  export type UserUpdateWithoutTransfer_Transfer_receivedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransfer_Transfer_receivedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StoreUpsertWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    update: XOR<StoreUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUncheckedUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
    create: XOR<StoreCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUncheckedCreateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput, StoreUncheckedUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput>
  }

  export type StoreUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTransfer_Transfer_sourceStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    Transfer_Transfer_destinationStoreIdToStore?: TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreNestedInput
  }

  export type WarehouseUpsertWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    update: XOR<WarehouseUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUncheckedUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
    create: XOR<WarehouseCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUncheckedCreateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput, WarehouseUncheckedUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput>
  }

  export type WarehouseUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type TransferItemUpsertWithWhereUniqueWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutTransferInput, TransferItemUncheckedUpdateWithoutTransferInput>
    create: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutTransferInput, TransferItemUncheckedUpdateWithoutTransferInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutTransferInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutTransferInput>
  }

  export type InventoryItemCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type ProductCreateWithoutTransferItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransferItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransferItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
  }

  export type InventoryItemCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type TransferCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User_Transfer_approvedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_approvedByIdToUserInput
    User_Transfer_createdByIdToUser: UserCreateNestedOneWithoutTransfer_Transfer_createdByIdToUserInput
    Store_Transfer_destinationStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_destinationStoreIdToStoreInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseInput
    User_Transfer_receivedByIdToUser?: UserCreateNestedOneWithoutTransfer_Transfer_receivedByIdToUserInput
    Store_Transfer_sourceStoreIdToStore?: StoreCreateNestedOneWithoutTransfer_Transfer_sourceStoreIdToStoreInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseCreateNestedOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseInput
  }

  export type TransferUncheckedCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutItemsInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
  }

  export type InventoryItemUpsertWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    update: XOR<InventoryItemUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
    create: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput, InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput>
  }

  export type InventoryItemUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type ProductUpsertWithoutTransferItemsInput = {
    update: XOR<ProductUpdateWithoutTransferItemsInput, ProductUncheckedUpdateWithoutTransferItemsInput>
    create: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransferItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransferItemsInput, ProductUncheckedUpdateWithoutTransferItemsInput>
  }

  export type ProductUpdateWithoutTransferItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransferItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type InventoryItemUpsertWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    update: XOR<InventoryItemUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
    create: XOR<InventoryItemCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUncheckedCreateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput, InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput>
  }

  export type InventoryItemUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
  }

  export type TransferUpsertWithoutItemsInput = {
    update: XOR<TransferUpdateWithoutItemsInput, TransferUncheckedUpdateWithoutItemsInput>
    create: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutItemsInput, TransferUncheckedUpdateWithoutItemsInput>
  }

  export type TransferUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
  }

  export type TransferUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateWithoutCustomerInput = {
    id?: string
    addressType?: string
    isDefault?: boolean
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    addressType?: string
    isDefault?: boolean
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateManyCustomerInputEnvelope = {
    data: CustomerAddressCreateManyCustomerInput | CustomerAddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerNoteCreateWithoutCustomerInput = {
    id?: string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCustomerNoteInput
  }

  export type CustomerNoteUncheckedCreateWithoutCustomerInput = {
    id?: string
    note: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNoteCreateOrConnectWithoutCustomerInput = {
    where: CustomerNoteWhereUniqueInput
    create: XOR<CustomerNoteCreateWithoutCustomerInput, CustomerNoteUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerNoteCreateManyCustomerInputEnvelope = {
    data: CustomerNoteCreateManyCustomerInput | CustomerNoteCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerToGroupCreateWithoutCustomerInput = {
    createdAt?: Date | string
    CustomerGroup: CustomerGroupCreateNestedOneWithoutCustomerToGroupInput
  }

  export type CustomerToGroupUncheckedCreateWithoutCustomerInput = {
    groupId: string
    createdAt?: Date | string
  }

  export type CustomerToGroupCreateOrConnectWithoutCustomerInput = {
    where: CustomerToGroupWhereUniqueInput
    create: XOR<CustomerToGroupCreateWithoutCustomerInput, CustomerToGroupUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerToGroupCreateManyCustomerInputEnvelope = {
    data: CustomerToGroupCreateManyCustomerInput | CustomerToGroupCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionCreateWithoutCustomerInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    program: LoyaltyProgramCreateNestedOneWithoutTransactionsInput
    Sale?: SaleCreateNestedOneWithoutLoyaltyTransactionInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutCustomerInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type LoyaltyTransactionCreateManyCustomerInputEnvelope = {
    data: LoyaltyTransactionCreateManyCustomerInput | LoyaltyTransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRedemptionCreateWithoutCustomerInput = {
    id: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    CustomerPromotion: CustomerPromotionCreateNestedOneWithoutPromotionRedemptionInput
    Sale: SaleCreateNestedOneWithoutPromotionRedemptionInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutCustomerInput = {
    id: string
    promotionId: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutCustomerInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutCustomerInput, PromotionRedemptionUncheckedCreateWithoutCustomerInput>
  }

  export type PromotionRedemptionCreateManyCustomerInputEnvelope = {
    data: PromotionRedemptionCreateManyCustomerInput | PromotionRedemptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    store: StoreCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    receiptNumber: string
    storeId: string
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    addressType?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    postalCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    phone?: StringNullableFilter<"CustomerAddress"> | string | null
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
  }

  export type CustomerNoteUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerNoteWhereUniqueInput
    update: XOR<CustomerNoteUpdateWithoutCustomerInput, CustomerNoteUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerNoteCreateWithoutCustomerInput, CustomerNoteUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerNoteUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerNoteWhereUniqueInput
    data: XOR<CustomerNoteUpdateWithoutCustomerInput, CustomerNoteUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerNoteUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerNoteScalarWhereInput
    data: XOR<CustomerNoteUpdateManyMutationInput, CustomerNoteUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerToGroupUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerToGroupWhereUniqueInput
    update: XOR<CustomerToGroupUpdateWithoutCustomerInput, CustomerToGroupUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerToGroupCreateWithoutCustomerInput, CustomerToGroupUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerToGroupUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerToGroupWhereUniqueInput
    data: XOR<CustomerToGroupUpdateWithoutCustomerInput, CustomerToGroupUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerToGroupUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerToGroupScalarWhereInput
    data: XOR<CustomerToGroupUpdateManyMutationInput, CustomerToGroupUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerToGroupScalarWhereInput = {
    AND?: CustomerToGroupScalarWhereInput | CustomerToGroupScalarWhereInput[]
    OR?: CustomerToGroupScalarWhereInput[]
    NOT?: CustomerToGroupScalarWhereInput | CustomerToGroupScalarWhereInput[]
    customerId?: StringFilter<"CustomerToGroup"> | string
    groupId?: StringFilter<"CustomerToGroup"> | string
    createdAt?: DateTimeFilter<"CustomerToGroup"> | Date | string
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutCustomerInput, LoyaltyTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutCustomerInput, LoyaltyTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutCustomerInput, PromotionRedemptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<PromotionRedemptionCreateWithoutCustomerInput, PromotionRedemptionUncheckedCreateWithoutCustomerInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutCustomerInput, PromotionRedemptionUncheckedUpdateWithoutCustomerInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutCustomerInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutCustomerAddressesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerAddressesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerAddressesInput, CustomerUncheckedCreateWithoutCustomerAddressesInput>
  }

  export type CustomerUpsertWithoutCustomerAddressesInput = {
    update: XOR<CustomerUpdateWithoutCustomerAddressesInput, CustomerUncheckedUpdateWithoutCustomerAddressesInput>
    create: XOR<CustomerCreateWithoutCustomerAddressesInput, CustomerUncheckedCreateWithoutCustomerAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerAddressesInput, CustomerUncheckedUpdateWithoutCustomerAddressesInput>
  }

  export type CustomerUpdateWithoutCustomerAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerNote?: CustomerNoteUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerPromotionCreateWithoutLoyaltyProgramInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerPromotionInput
  }

  export type CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerPromotionInput
  }

  export type CustomerPromotionCreateOrConnectWithoutLoyaltyProgramInput = {
    where: CustomerPromotionWhereUniqueInput
    create: XOR<CustomerPromotionCreateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput>
  }

  export type CustomerPromotionCreateManyLoyaltyProgramInputEnvelope = {
    data: CustomerPromotionCreateManyLoyaltyProgramInput | CustomerPromotionCreateManyLoyaltyProgramInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.LoyaltyRuleType
    conditions?: string | null
    pointsAwarded: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.LoyaltyRuleType
    conditions?: string | null
    pointsAwarded: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LoyaltyProgramRuleCreateOrConnectWithoutLoyaltyProgramInput = {
    where: LoyaltyProgramRuleWhereUniqueInput
    create: XOR<LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput>
  }

  export type LoyaltyProgramRuleCreateManyLoyaltyProgramInputEnvelope = {
    data: LoyaltyProgramRuleCreateManyLoyaltyProgramInput | LoyaltyProgramRuleCreateManyLoyaltyProgramInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyProgramTierCreateWithoutProgramInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: Decimal | DecimalJsLike | number | string
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUncheckedCreateWithoutProgramInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: Decimal | DecimalJsLike | number | string
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierCreateOrConnectWithoutProgramInput = {
    where: LoyaltyProgramTierWhereUniqueInput
    create: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyProgramTierCreateManyProgramInputEnvelope = {
    data: LoyaltyProgramTierCreateManyProgramInput | LoyaltyProgramTierCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionCreateWithoutProgramInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLoyaltyTransactionsInput
    Sale?: SaleCreateNestedOneWithoutLoyaltyTransactionInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutProgramInput = {
    id?: string
    customerId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutProgramInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyTransactionCreateManyProgramInputEnvelope = {
    data: LoyaltyTransactionCreateManyProgramInput | LoyaltyTransactionCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPromotionUpsertWithWhereUniqueWithoutLoyaltyProgramInput = {
    where: CustomerPromotionWhereUniqueInput
    update: XOR<CustomerPromotionUpdateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedUpdateWithoutLoyaltyProgramInput>
    create: XOR<CustomerPromotionCreateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedCreateWithoutLoyaltyProgramInput>
  }

  export type CustomerPromotionUpdateWithWhereUniqueWithoutLoyaltyProgramInput = {
    where: CustomerPromotionWhereUniqueInput
    data: XOR<CustomerPromotionUpdateWithoutLoyaltyProgramInput, CustomerPromotionUncheckedUpdateWithoutLoyaltyProgramInput>
  }

  export type CustomerPromotionUpdateManyWithWhereWithoutLoyaltyProgramInput = {
    where: CustomerPromotionScalarWhereInput
    data: XOR<CustomerPromotionUpdateManyMutationInput, CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramInput>
  }

  export type CustomerPromotionScalarWhereInput = {
    AND?: CustomerPromotionScalarWhereInput | CustomerPromotionScalarWhereInput[]
    OR?: CustomerPromotionScalarWhereInput[]
    NOT?: CustomerPromotionScalarWhereInput | CustomerPromotionScalarWhereInput[]
    id?: StringFilter<"CustomerPromotion"> | string
    name?: StringFilter<"CustomerPromotion"> | string
    description?: StringNullableFilter<"CustomerPromotion"> | string | null
    type?: EnumPromotionTypeFilter<"CustomerPromotion"> | $Enums.PromotionType
    discountValue?: DecimalFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFilter<"CustomerPromotion"> | boolean
    code?: StringNullableFilter<"CustomerPromotion"> | string | null
    minimumPurchase?: DecimalNullableFilter<"CustomerPromotion"> | Decimal | DecimalJsLike | number | string | null
    programId?: StringNullableFilter<"CustomerPromotion"> | string | null
    requiredLoyaltyTier?: EnumLoyaltyTierNullableFilter<"CustomerPromotion"> | $Enums.LoyaltyTier | null
    startDate?: DateTimeFilter<"CustomerPromotion"> | Date | string
    endDate?: DateTimeFilter<"CustomerPromotion"> | Date | string
    isActive?: BoolFilter<"CustomerPromotion"> | boolean
    usageLimit?: IntNullableFilter<"CustomerPromotion"> | number | null
    usageCount?: IntFilter<"CustomerPromotion"> | number
    applicableProducts?: StringNullableFilter<"CustomerPromotion"> | string | null
    applicableCategories?: StringNullableFilter<"CustomerPromotion"> | string | null
    createdAt?: DateTimeFilter<"CustomerPromotion"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPromotion"> | Date | string
  }

  export type LoyaltyProgramRuleUpsertWithWhereUniqueWithoutLoyaltyProgramInput = {
    where: LoyaltyProgramRuleWhereUniqueInput
    update: XOR<LoyaltyProgramRuleUpdateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedUpdateWithoutLoyaltyProgramInput>
    create: XOR<LoyaltyProgramRuleCreateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedCreateWithoutLoyaltyProgramInput>
  }

  export type LoyaltyProgramRuleUpdateWithWhereUniqueWithoutLoyaltyProgramInput = {
    where: LoyaltyProgramRuleWhereUniqueInput
    data: XOR<LoyaltyProgramRuleUpdateWithoutLoyaltyProgramInput, LoyaltyProgramRuleUncheckedUpdateWithoutLoyaltyProgramInput>
  }

  export type LoyaltyProgramRuleUpdateManyWithWhereWithoutLoyaltyProgramInput = {
    where: LoyaltyProgramRuleScalarWhereInput
    data: XOR<LoyaltyProgramRuleUpdateManyMutationInput, LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramInput>
  }

  export type LoyaltyProgramRuleScalarWhereInput = {
    AND?: LoyaltyProgramRuleScalarWhereInput | LoyaltyProgramRuleScalarWhereInput[]
    OR?: LoyaltyProgramRuleScalarWhereInput[]
    NOT?: LoyaltyProgramRuleScalarWhereInput | LoyaltyProgramRuleScalarWhereInput[]
    id?: StringFilter<"LoyaltyProgramRule"> | string
    programId?: StringFilter<"LoyaltyProgramRule"> | string
    name?: StringFilter<"LoyaltyProgramRule"> | string
    description?: StringNullableFilter<"LoyaltyProgramRule"> | string | null
    type?: EnumLoyaltyRuleTypeFilter<"LoyaltyProgramRule"> | $Enums.LoyaltyRuleType
    conditions?: StringNullableFilter<"LoyaltyProgramRule"> | string | null
    pointsAwarded?: IntFilter<"LoyaltyProgramRule"> | number
    isActive?: BoolFilter<"LoyaltyProgramRule"> | boolean
    startDate?: DateTimeNullableFilter<"LoyaltyProgramRule"> | Date | string | null
    endDate?: DateTimeNullableFilter<"LoyaltyProgramRule"> | Date | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramRule"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramRule"> | Date | string
  }

  export type LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyProgramTierWhereUniqueInput
    update: XOR<LoyaltyProgramTierUpdateWithoutProgramInput, LoyaltyProgramTierUncheckedUpdateWithoutProgramInput>
    create: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyProgramTierWhereUniqueInput
    data: XOR<LoyaltyProgramTierUpdateWithoutProgramInput, LoyaltyProgramTierUncheckedUpdateWithoutProgramInput>
  }

  export type LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput = {
    where: LoyaltyProgramTierScalarWhereInput
    data: XOR<LoyaltyProgramTierUpdateManyMutationInput, LoyaltyProgramTierUncheckedUpdateManyWithoutProgramInput>
  }

  export type LoyaltyProgramTierScalarWhereInput = {
    AND?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
    OR?: LoyaltyProgramTierScalarWhereInput[]
    NOT?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
    id?: StringFilter<"LoyaltyProgramTier"> | string
    programId?: StringFilter<"LoyaltyProgramTier"> | string
    name?: StringFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: DecimalFilter<"LoyaltyProgramTier"> | Decimal | DecimalJsLike | number | string
    benefits?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutProgramInput, LoyaltyTransactionUncheckedUpdateWithoutProgramInput>
    create: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutProgramInput, LoyaltyTransactionUncheckedUpdateWithoutProgramInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutProgramInput>
  }

  export type LoyaltyProgramCreateWithoutTiersInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionCreateNestedManyWithoutLoyaltyProgramInput
    LoyaltyProgramRule?: LoyaltyProgramRuleCreateNestedManyWithoutLoyaltyProgramInput
    transactions?: LoyaltyTransactionCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateWithoutTiersInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramCreateOrConnectWithoutTiersInput = {
    where: LoyaltyProgramWhereUniqueInput
    create: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
  }

  export type LoyaltyProgramUpsertWithoutTiersInput = {
    update: XOR<LoyaltyProgramUpdateWithoutTiersInput, LoyaltyProgramUncheckedUpdateWithoutTiersInput>
    create: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
    where?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramUpdateToOneWithWhereWithoutTiersInput = {
    where?: LoyaltyProgramWhereInput
    data: XOR<LoyaltyProgramUpdateWithoutTiersInput, LoyaltyProgramUncheckedUpdateWithoutTiersInput>
  }

  export type LoyaltyProgramUpdateWithoutTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUpdateManyWithoutLoyaltyProgramNestedInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUpdateManyWithoutLoyaltyProgramNestedInput
    transactions?: LoyaltyTransactionUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateWithoutTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type CustomerCreateWithoutLoyaltyTransactionsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLoyaltyTransactionsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLoyaltyTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
  }

  export type LoyaltyProgramCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionCreateNestedManyWithoutLoyaltyProgramInput
    LoyaltyProgramRule?: LoyaltyProgramRuleCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramCreateOrConnectWithoutTransactionsInput = {
    where: LoyaltyProgramWhereUniqueInput
    create: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
  }

  export type SaleCreateWithoutLoyaltyTransactionInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    store: StoreCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutLoyaltyTransactionInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutSaleInput
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutLoyaltyTransactionInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutLoyaltyTransactionInput, SaleUncheckedCreateWithoutLoyaltyTransactionInput>
  }

  export type CustomerUpsertWithoutLoyaltyTransactionsInput = {
    update: XOR<CustomerUpdateWithoutLoyaltyTransactionsInput, CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
    create: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLoyaltyTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLoyaltyTransactionsInput, CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
  }

  export type CustomerUpdateWithoutLoyaltyTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LoyaltyProgramUpsertWithoutTransactionsInput = {
    update: XOR<LoyaltyProgramUpdateWithoutTransactionsInput, LoyaltyProgramUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
    where?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LoyaltyProgramWhereInput
    data: XOR<LoyaltyProgramUpdateWithoutTransactionsInput, LoyaltyProgramUncheckedUpdateWithoutTransactionsInput>
  }

  export type LoyaltyProgramUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUpdateManyWithoutLoyaltyProgramNestedInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type SaleUpsertWithoutLoyaltyTransactionInput = {
    update: XOR<SaleUpdateWithoutLoyaltyTransactionInput, SaleUncheckedUpdateWithoutLoyaltyTransactionInput>
    create: XOR<SaleCreateWithoutLoyaltyTransactionInput, SaleUncheckedCreateWithoutLoyaltyTransactionInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutLoyaltyTransactionInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutLoyaltyTransactionInput, SaleUncheckedUpdateWithoutLoyaltyTransactionInput>
  }

  export type SaleUpdateWithoutLoyaltyTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutLoyaltyTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type UserCreateWithoutCreatedAuditsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAuditsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
  }

  export type WarehouseCreateWithoutAuditsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedCreateNestedManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutAuditsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
  }

  export type AuditAssignmentCreateWithoutAuditInput = {
    id?: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditAssignmentsInput
  }

  export type AuditAssignmentUncheckedCreateWithoutAuditInput = {
    id?: string
    userId: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateOrConnectWithoutAuditInput = {
    where: AuditAssignmentWhereUniqueInput
    create: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput>
  }

  export type AuditAssignmentCreateManyAuditInputEnvelope = {
    data: AuditAssignmentCreateManyAuditInput | AuditAssignmentCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditItemCreateWithoutAuditInput = {
    id?: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItem: InventoryItemCreateNestedOneWithoutAuditItemsInput
    product: ProductCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateWithoutAuditInput = {
    id?: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateOrConnectWithoutAuditInput = {
    where: AuditItemWhereUniqueInput
    create: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput>
  }

  export type AuditItemCreateManyAuditInputEnvelope = {
    data: AuditItemCreateManyAuditInput | AuditItemCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedAuditsInput = {
    update: XOR<UserUpdateWithoutCreatedAuditsInput, UserUncheckedUpdateWithoutCreatedAuditsInput>
    create: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAuditsInput, UserUncheckedUpdateWithoutCreatedAuditsInput>
  }

  export type UserUpdateWithoutCreatedAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WarehouseUpsertWithoutAuditsInput = {
    update: XOR<WarehouseUpdateWithoutAuditsInput, WarehouseUncheckedUpdateWithoutAuditsInput>
    create: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutAuditsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutAuditsInput, WarehouseUncheckedUpdateWithoutAuditsInput>
  }

  export type WarehouseUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    Transfer_Transfer_destinationWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Transfer_Transfer_sourceWarehouseIdToWarehouse?: TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditAssignmentWhereUniqueInput
    update: XOR<AuditAssignmentUpdateWithoutAuditInput, AuditAssignmentUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput>
  }

  export type AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditAssignmentWhereUniqueInput
    data: XOR<AuditAssignmentUpdateWithoutAuditInput, AuditAssignmentUncheckedUpdateWithoutAuditInput>
  }

  export type AuditAssignmentUpdateManyWithWhereWithoutAuditInput = {
    where: AuditAssignmentScalarWhereInput
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditItemUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditItemWhereUniqueInput
    update: XOR<AuditItemUpdateWithoutAuditInput, AuditItemUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput>
  }

  export type AuditItemUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditItemWhereUniqueInput
    data: XOR<AuditItemUpdateWithoutAuditInput, AuditItemUncheckedUpdateWithoutAuditInput>
  }

  export type AuditItemUpdateManyWithWhereWithoutAuditInput = {
    where: AuditItemScalarWhereInput
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutItemsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
  }

  export type InventoryItemCreateWithoutAuditItemsInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutAuditItemsInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedCreateNestedManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutAuditItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
  }

  export type ProductCreateWithoutAuditItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    User_Product_createdByIdToUser: UserCreateNestedOneWithoutProduct_Product_createdByIdToUserInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    User_Product_updatedByIdToUser: UserCreateNestedOneWithoutProduct_Product_updatedByIdToUserInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAuditItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAuditItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
  }

  export type AuditUpsertWithoutItemsInput = {
    update: XOR<AuditUpdateWithoutItemsInput, AuditUncheckedUpdateWithoutItemsInput>
    create: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutItemsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutItemsInput, AuditUncheckedUpdateWithoutItemsInput>
  }

  export type AuditUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type InventoryItemUpsertWithoutAuditItemsInput = {
    update: XOR<InventoryItemUpdateWithoutAuditItemsInput, InventoryItemUncheckedUpdateWithoutAuditItemsInput>
    create: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutAuditItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutAuditItemsInput, InventoryItemUncheckedUpdateWithoutAuditItemsInput>
  }

  export type InventoryItemUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type ProductUpsertWithoutAuditItemsInput = {
    update: XOR<ProductUpdateWithoutAuditItemsInput, ProductUncheckedUpdateWithoutAuditItemsInput>
    create: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAuditItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAuditItemsInput, ProductUncheckedUpdateWithoutAuditItemsInput>
  }

  export type ProductUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AuditCreateWithoutAssignmentsInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutAssignmentsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAuditAssignmentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditAssignmentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
  }

  export type AuditUpsertWithoutAssignmentsInput = {
    update: XOR<AuditUpdateWithoutAssignmentsInput, AuditUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutAssignmentsInput, AuditUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AuditUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutAuditAssignmentsInput = {
    update: XOR<UserUpdateWithoutAuditAssignmentsInput, UserUncheckedUpdateWithoutAuditAssignmentsInput>
    create: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditAssignmentsInput, UserUncheckedUpdateWithoutAuditAssignmentsInput>
  }

  export type UserUpdateWithoutAuditAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CustomerToGroupCreateWithoutCustomerGroupInput = {
    createdAt?: Date | string
    Customer: CustomerCreateNestedOneWithoutCustomerToGroupInput
  }

  export type CustomerToGroupUncheckedCreateWithoutCustomerGroupInput = {
    customerId: string
    createdAt?: Date | string
  }

  export type CustomerToGroupCreateOrConnectWithoutCustomerGroupInput = {
    where: CustomerToGroupWhereUniqueInput
    create: XOR<CustomerToGroupCreateWithoutCustomerGroupInput, CustomerToGroupUncheckedCreateWithoutCustomerGroupInput>
  }

  export type CustomerToGroupCreateManyCustomerGroupInputEnvelope = {
    data: CustomerToGroupCreateManyCustomerGroupInput | CustomerToGroupCreateManyCustomerGroupInput[]
    skipDuplicates?: boolean
  }

  export type CustomerToGroupUpsertWithWhereUniqueWithoutCustomerGroupInput = {
    where: CustomerToGroupWhereUniqueInput
    update: XOR<CustomerToGroupUpdateWithoutCustomerGroupInput, CustomerToGroupUncheckedUpdateWithoutCustomerGroupInput>
    create: XOR<CustomerToGroupCreateWithoutCustomerGroupInput, CustomerToGroupUncheckedCreateWithoutCustomerGroupInput>
  }

  export type CustomerToGroupUpdateWithWhereUniqueWithoutCustomerGroupInput = {
    where: CustomerToGroupWhereUniqueInput
    data: XOR<CustomerToGroupUpdateWithoutCustomerGroupInput, CustomerToGroupUncheckedUpdateWithoutCustomerGroupInput>
  }

  export type CustomerToGroupUpdateManyWithWhereWithoutCustomerGroupInput = {
    where: CustomerToGroupScalarWhereInput
    data: XOR<CustomerToGroupUpdateManyMutationInput, CustomerToGroupUncheckedUpdateManyWithoutCustomerGroupInput>
  }

  export type CustomerCreateWithoutCustomerNoteInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerNoteInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerNoteInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerNoteInput, CustomerUncheckedCreateWithoutCustomerNoteInput>
  }

  export type UserCreateWithoutCustomerNoteInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerNoteInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerNoteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerNoteInput, UserUncheckedCreateWithoutCustomerNoteInput>
  }

  export type CustomerUpsertWithoutCustomerNoteInput = {
    update: XOR<CustomerUpdateWithoutCustomerNoteInput, CustomerUncheckedUpdateWithoutCustomerNoteInput>
    create: XOR<CustomerCreateWithoutCustomerNoteInput, CustomerUncheckedCreateWithoutCustomerNoteInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerNoteInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerNoteInput, CustomerUncheckedUpdateWithoutCustomerNoteInput>
  }

  export type CustomerUpdateWithoutCustomerNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutCustomerNoteInput = {
    update: XOR<UserUpdateWithoutCustomerNoteInput, UserUncheckedUpdateWithoutCustomerNoteInput>
    create: XOR<UserCreateWithoutCustomerNoteInput, UserUncheckedCreateWithoutCustomerNoteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomerNoteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomerNoteInput, UserUncheckedUpdateWithoutCustomerNoteInput>
  }

  export type UserUpdateWithoutCustomerNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LoyaltyProgramCreateWithoutCustomerPromotionInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyProgramRule?: LoyaltyProgramRuleCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateWithoutCustomerPromotionInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramCreateOrConnectWithoutCustomerPromotionInput = {
    where: LoyaltyProgramWhereUniqueInput
    create: XOR<LoyaltyProgramCreateWithoutCustomerPromotionInput, LoyaltyProgramUncheckedCreateWithoutCustomerPromotionInput>
  }

  export type PromotionRedemptionCreateWithoutCustomerPromotionInput = {
    id: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Customer: CustomerCreateNestedOneWithoutPromotionRedemptionInput
    Sale: SaleCreateNestedOneWithoutPromotionRedemptionInput
  }

  export type PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput = {
    id: string
    customerId: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateOrConnectWithoutCustomerPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    create: XOR<PromotionRedemptionCreateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput>
  }

  export type PromotionRedemptionCreateManyCustomerPromotionInputEnvelope = {
    data: PromotionRedemptionCreateManyCustomerPromotionInput | PromotionRedemptionCreateManyCustomerPromotionInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyProgramUpsertWithoutCustomerPromotionInput = {
    update: XOR<LoyaltyProgramUpdateWithoutCustomerPromotionInput, LoyaltyProgramUncheckedUpdateWithoutCustomerPromotionInput>
    create: XOR<LoyaltyProgramCreateWithoutCustomerPromotionInput, LoyaltyProgramUncheckedCreateWithoutCustomerPromotionInput>
    where?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramUpdateToOneWithWhereWithoutCustomerPromotionInput = {
    where?: LoyaltyProgramWhereInput
    data: XOR<LoyaltyProgramUpdateWithoutCustomerPromotionInput, LoyaltyProgramUncheckedUpdateWithoutCustomerPromotionInput>
  }

  export type LoyaltyProgramUpdateWithoutCustomerPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyProgramRule?: LoyaltyProgramRuleUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateWithoutCustomerPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyProgramRule?: LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type PromotionRedemptionUpsertWithWhereUniqueWithoutCustomerPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    update: XOR<PromotionRedemptionUpdateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedUpdateWithoutCustomerPromotionInput>
    create: XOR<PromotionRedemptionCreateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedCreateWithoutCustomerPromotionInput>
  }

  export type PromotionRedemptionUpdateWithWhereUniqueWithoutCustomerPromotionInput = {
    where: PromotionRedemptionWhereUniqueInput
    data: XOR<PromotionRedemptionUpdateWithoutCustomerPromotionInput, PromotionRedemptionUncheckedUpdateWithoutCustomerPromotionInput>
  }

  export type PromotionRedemptionUpdateManyWithWhereWithoutCustomerPromotionInput = {
    where: PromotionRedemptionScalarWhereInput
    data: XOR<PromotionRedemptionUpdateManyMutationInput, PromotionRedemptionUncheckedUpdateManyWithoutCustomerPromotionInput>
  }

  export type CustomerCreateWithoutCustomerToGroupInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionCreateNestedManyWithoutCustomerInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerToGroupInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
    PromotionRedemption?: PromotionRedemptionUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerToGroupInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerToGroupInput, CustomerUncheckedCreateWithoutCustomerToGroupInput>
  }

  export type CustomerGroupCreateWithoutCustomerToGroupInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CustomerGroupUncheckedCreateWithoutCustomerToGroupInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CustomerGroupCreateOrConnectWithoutCustomerToGroupInput = {
    where: CustomerGroupWhereUniqueInput
    create: XOR<CustomerGroupCreateWithoutCustomerToGroupInput, CustomerGroupUncheckedCreateWithoutCustomerToGroupInput>
  }

  export type CustomerUpsertWithoutCustomerToGroupInput = {
    update: XOR<CustomerUpdateWithoutCustomerToGroupInput, CustomerUncheckedUpdateWithoutCustomerToGroupInput>
    create: XOR<CustomerCreateWithoutCustomerToGroupInput, CustomerUncheckedCreateWithoutCustomerToGroupInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerToGroupInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerToGroupInput, CustomerUncheckedUpdateWithoutCustomerToGroupInput>
  }

  export type CustomerUpdateWithoutCustomerToGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerToGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerGroupUpsertWithoutCustomerToGroupInput = {
    update: XOR<CustomerGroupUpdateWithoutCustomerToGroupInput, CustomerGroupUncheckedUpdateWithoutCustomerToGroupInput>
    create: XOR<CustomerGroupCreateWithoutCustomerToGroupInput, CustomerGroupUncheckedCreateWithoutCustomerToGroupInput>
    where?: CustomerGroupWhereInput
  }

  export type CustomerGroupUpdateToOneWithWhereWithoutCustomerToGroupInput = {
    where?: CustomerGroupWhereInput
    data: XOR<CustomerGroupUpdateWithoutCustomerToGroupInput, CustomerGroupUncheckedUpdateWithoutCustomerToGroupInput>
  }

  export type CustomerGroupUpdateWithoutCustomerToGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupUncheckedUpdateWithoutCustomerToGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramCreateWithoutLoyaltyProgramRuleInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateWithoutLoyaltyProgramRuleInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerCurrency?: Decimal | DecimalJsLike | number | string
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerPromotion?: CustomerPromotionUncheckedCreateNestedManyWithoutLoyaltyProgramInput
    tiers?: LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramCreateOrConnectWithoutLoyaltyProgramRuleInput = {
    where: LoyaltyProgramWhereUniqueInput
    create: XOR<LoyaltyProgramCreateWithoutLoyaltyProgramRuleInput, LoyaltyProgramUncheckedCreateWithoutLoyaltyProgramRuleInput>
  }

  export type LoyaltyProgramUpsertWithoutLoyaltyProgramRuleInput = {
    update: XOR<LoyaltyProgramUpdateWithoutLoyaltyProgramRuleInput, LoyaltyProgramUncheckedUpdateWithoutLoyaltyProgramRuleInput>
    create: XOR<LoyaltyProgramCreateWithoutLoyaltyProgramRuleInput, LoyaltyProgramUncheckedCreateWithoutLoyaltyProgramRuleInput>
    where?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramUpdateToOneWithWhereWithoutLoyaltyProgramRuleInput = {
    where?: LoyaltyProgramWhereInput
    data: XOR<LoyaltyProgramUpdateWithoutLoyaltyProgramRuleInput, LoyaltyProgramUncheckedUpdateWithoutLoyaltyProgramRuleInput>
  }

  export type LoyaltyProgramUpdateWithoutLoyaltyProgramRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateWithoutLoyaltyProgramRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerCurrency?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramNestedInput
    tiers?: LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type UserCreateWithoutReceivedNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
  }

  export type UserCreateWithoutSentNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCreatedByInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCreatedByInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
    Product_Product_createdByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_createdByIdToUserInput
    Product_Product_updatedByIdToUser?: ProductUncheckedCreateNestedManyWithoutUser_Product_updatedByIdToUserInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_createdByIdToUserInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedCreateNestedManyWithoutUser_PurchaseOrder_updatedByIdToUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_createdByIdToUserInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedCreateNestedManyWithoutUser_Supplier_updatedByIdToUserInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_approvedByIdToUserInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_createdByIdToUserInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedCreateNestedManyWithoutUser_Transfer_receivedByIdToUserInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type UserUpsertWithoutReceivedNotificationsInput = {
    update: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
    create: XOR<UserCreateWithoutReceivedNotificationsInput, UserUncheckedCreateWithoutReceivedNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedNotificationsInput, UserUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type UserUpdateWithoutReceivedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCreatedByNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
    Product_Product_createdByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserNestedInput
    Product_Product_updatedByIdToUser?: ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_createdByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserNestedInput
    PurchaseOrder_PurchaseOrder_updatedByIdToUser?: PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    Supplier_Supplier_createdByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserNestedInput
    Supplier_Supplier_updatedByIdToUser?: SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserNestedInput
    Transfer_Transfer_approvedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserNestedInput
    Transfer_Transfer_createdByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserNestedInput
    Transfer_Transfer_receivedByIdToUser?: TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CustomerCreateWithoutPromotionRedemptionInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPromotionRedemptionInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birthDate?: Date | string | null
    gender?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerAddresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    CustomerNote?: CustomerNoteUncheckedCreateNestedManyWithoutCustomerInput
    CustomerToGroup?: CustomerToGroupUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPromotionRedemptionInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPromotionRedemptionInput, CustomerUncheckedCreateWithoutPromotionRedemptionInput>
  }

  export type CustomerPromotionCreateWithoutPromotionRedemptionInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    LoyaltyProgram?: LoyaltyProgramCreateNestedOneWithoutCustomerPromotionInput
  }

  export type CustomerPromotionUncheckedCreateWithoutPromotionRedemptionInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    programId?: string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CustomerPromotionCreateOrConnectWithoutPromotionRedemptionInput = {
    where: CustomerPromotionWhereUniqueInput
    create: XOR<CustomerPromotionCreateWithoutPromotionRedemptionInput, CustomerPromotionUncheckedCreateWithoutPromotionRedemptionInput>
  }

  export type SaleCreateWithoutPromotionRedemptionInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionCreateNestedManyWithoutSaleInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    store: StoreCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutPromotionRedemptionInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedCreateNestedManyWithoutSaleInput
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutPromotionRedemptionInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutPromotionRedemptionInput, SaleUncheckedCreateWithoutPromotionRedemptionInput>
  }

  export type CustomerUpsertWithoutPromotionRedemptionInput = {
    update: XOR<CustomerUpdateWithoutPromotionRedemptionInput, CustomerUncheckedUpdateWithoutPromotionRedemptionInput>
    create: XOR<CustomerCreateWithoutPromotionRedemptionInput, CustomerUncheckedCreateWithoutPromotionRedemptionInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPromotionRedemptionInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPromotionRedemptionInput, CustomerUncheckedUpdateWithoutPromotionRedemptionInput>
  }

  export type CustomerUpdateWithoutPromotionRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPromotionRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerAddresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerNote?: CustomerNoteUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerToGroup?: CustomerToGroupUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerPromotionUpsertWithoutPromotionRedemptionInput = {
    update: XOR<CustomerPromotionUpdateWithoutPromotionRedemptionInput, CustomerPromotionUncheckedUpdateWithoutPromotionRedemptionInput>
    create: XOR<CustomerPromotionCreateWithoutPromotionRedemptionInput, CustomerPromotionUncheckedCreateWithoutPromotionRedemptionInput>
    where?: CustomerPromotionWhereInput
  }

  export type CustomerPromotionUpdateToOneWithWhereWithoutPromotionRedemptionInput = {
    where?: CustomerPromotionWhereInput
    data: XOR<CustomerPromotionUpdateWithoutPromotionRedemptionInput, CustomerPromotionUncheckedUpdateWithoutPromotionRedemptionInput>
  }

  export type CustomerPromotionUpdateWithoutPromotionRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyProgram?: LoyaltyProgramUpdateOneWithoutCustomerPromotionNestedInput
  }

  export type CustomerPromotionUncheckedUpdateWithoutPromotionRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpsertWithoutPromotionRedemptionInput = {
    update: XOR<SaleUpdateWithoutPromotionRedemptionInput, SaleUncheckedUpdateWithoutPromotionRedemptionInput>
    create: XOR<SaleCreateWithoutPromotionRedemptionInput, SaleUncheckedCreateWithoutPromotionRedemptionInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutPromotionRedemptionInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutPromotionRedemptionInput, SaleUncheckedUpdateWithoutPromotionRedemptionInput>
  }

  export type SaleUpdateWithoutPromotionRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutPromotionRedemptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AuditCreateManyCreatedByInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateManyUserInput = {
    id?: string
    auditId: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNoteCreateManyCreatedByInput = {
    id?: string
    customerId: string
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationCreateManyReceiverInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    relatedEntityId?: string | null
    relatedEntityType?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    senderId?: string | null
  }

  export type ProductCreateManyUser_Product_createdByIdToUserInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyUser_Product_updatedByIdToUserInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyUser_PurchaseOrder_createdByIdToUserInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyUser_PurchaseOrder_updatedByIdToUserInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateManyCreatedByInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SupplierCreateManyUser_Supplier_createdByIdToUserInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyUser_Supplier_updatedByIdToUserInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    isActive?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyUser_Transfer_approvedByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyUser_Transfer_createdByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyUser_Transfer_receivedByIdToUserInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AuditAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerNoteNestedInput
  }

  export type CustomerNoteUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutUser_Product_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUser_Product_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUser_Product_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutUser_Product_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUser_Product_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUser_Product_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    User_PurchaseOrder_updatedByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_PurchaseOrder_createdByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutUser_PurchaseOrder_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutUser_Supplier_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    User_Supplier_updatedByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_updatedByIdToUserNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutUser_Supplier_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutUser_Supplier_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutUser_Supplier_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    User_Supplier_createdByIdToUser?: UserUpdateOneRequiredWithoutSupplier_Supplier_createdByIdToUserNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutUser_Supplier_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutUser_Supplier_updatedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutUser_Transfer_approvedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutUser_Transfer_approvedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutUser_Transfer_approvedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutUser_Transfer_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutUser_Transfer_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutUser_Transfer_createdByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutUser_Transfer_receivedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutUser_Transfer_receivedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutUser_Transfer_receivedByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateManyWarehouseInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyWarehouseInput = {
    id?: string
    productId: string
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyWarehouseInput = {
    id?: string
    orderNumber: string
    supplierId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffCreateManyWarehouseInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseZoneCreateManyWarehouseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_PurchaseOrder_createdByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    User_PurchaseOrder_updatedByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutWarehouse_Transfer_destinationWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutWarehouse_Transfer_sourceWarehouseIdToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWarehouseStaffNestedInput
  }

  export type WarehouseStaffUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseZoneUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseAisleCreateManyZoneInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseAisleUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelves?: WarehouseShelfUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelves?: WarehouseShelfUncheckedUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfCreateManyAisleInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseShelfUpdateWithoutAisleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfUncheckedUpdateWithoutAisleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUncheckedUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfUncheckedUpdateManyWithoutAisleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinCreateManyShelfInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseBinUpdateWithoutShelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinUncheckedUpdateWithoutShelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinUncheckedUpdateManyWithoutShelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyBinInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    storeId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyStoreInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateManyStoreInput = {
    id?: string
    receiptNumber: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffCreateManyStoreInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyStore_Transfer_destinationStoreIdToStoreInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    sourceStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyStore_Transfer_sourceStoreIdToStoreInput = {
    id?: string
    referenceNumber: string
    type: $Enums.TransferType
    sourceWarehouseId?: string | null
    destinationWarehouseId?: string | null
    destinationStoreId?: string | null
    status?: $Enums.TransferStatus
    requestedDate?: Date | string
    approvedDate?: Date | string | null
    shippedDate?: Date | string | null
    receivedDate?: Date | string | null
    notes?: string | null
    createdById: string
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoreStaffNestedInput
  }

  export type StoreStaffUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Store_Transfer_sourceStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_sourceStoreIdToStoreNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutStore_Transfer_destinationStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Transfer_approvedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_approvedByIdToUserNestedInput
    User_Transfer_createdByIdToUser?: UserUpdateOneRequiredWithoutTransfer_Transfer_createdByIdToUserNestedInput
    Store_Transfer_destinationStoreIdToStore?: StoreUpdateOneWithoutTransfer_Transfer_destinationStoreIdToStoreNestedInput
    Warehouse_Transfer_destinationWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_destinationWarehouseIdToWarehouseNestedInput
    User_Transfer_receivedByIdToUser?: UserUpdateOneWithoutTransfer_Transfer_receivedByIdToUserNestedInput
    Warehouse_Transfer_sourceWarehouseIdToWarehouse?: WarehouseUpdateOneWithoutTransfer_Transfer_sourceWarehouseIdToWarehouseNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutStore_Transfer_sourceStoreIdToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    sourceWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    requestedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManySupplierInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    categoryId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    orderNumber: string
    warehouseId: string
    status?: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    deliveredDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    shipping?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractCreateManySupplierInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_PurchaseOrder_createdByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_createdByIdToUserNestedInput
    User_PurchaseOrder_updatedByIdToUser?: UserUpdateOneWithoutPurchaseOrder_PurchaseOrder_updatedByIdToUserNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shipping?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: string
    productId: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateManyProductInput = {
    id?: string
    auditId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyProductInput = {
    id?: string
    warehouseId?: string | null
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InventoryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateManyProductInput = {
    id?: string
    purchaseOrderId: string
    description?: string | null
    orderedQuantity: number
    receivedQuantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateManyProductInput = {
    id?: string
    saleId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyProductInput = {
    id?: string
    transferId: string
    sourceInventoryId?: string | null
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    TransferItem_TransferItem_destinationInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    TransferItem_TransferItem_sourceInventoryIdToInventoryItem?: TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderedQuantity?: IntFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyCategoryInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    supplierId?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string
    retailPrice?: Decimal | DecimalJsLike | number | string
    unit?: string
    minStockLevel?: number
    maxStockLevel?: number | null
    reorderPoint?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_Category?: CategoryUpdateManyWithoutCategoryNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    other_Category?: CategoryUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    User_Product_createdByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_createdByIdToUserNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    User_Product_updatedByIdToUser?: UserUpdateOneRequiredWithoutProduct_Product_updatedByIdToUserNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    retailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    minStockLevel?: IntFieldUpdateOperationsInput | number
    maxStockLevel?: NullableIntFieldUpdateOperationsInput | number | null
    reorderPoint?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateManyInventoryItemInput = {
    id?: string
    auditId: string
    productId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateManyInventoryItemInput = {
    id?: string
    saleId: string
    productId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: string
    transferId: string
    productId: string
    sourceInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: string
    transferId: string
    productId: string
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTransferItemsNestedInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_destinationInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemsNestedInput
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutInventoryItem_TransferItem_sourceInventoryIdToInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateManySaleInput = {
    id?: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateManySaleInput = {
    id: string
    promotionId: string
    customerId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleItemCreateManySaleInput = {
    id?: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput
    program?: LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneRequiredWithoutPromotionRedemptionNestedInput
    CustomerPromotion?: CustomerPromotionUpdateOneRequiredWithoutPromotionRedemptionNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateManyTransferInput = {
    id?: string
    productId: string
    sourceInventoryId?: string | null
    destinationInventoryId?: string | null
    requestedQuantity: number
    approvedQuantity?: number | null
    shippedQuantity?: number | null
    receivedQuantity?: number | null
    sourceCostPrice: Decimal | DecimalJsLike | number | string
    sourceWholesalePrice: Decimal | DecimalJsLike | number | string
    sourceRetailPrice: Decimal | DecimalJsLike | number | string
    destinationCostPrice: Decimal | DecimalJsLike | number | string
    destinationWholesalePrice: Decimal | DecimalJsLike | number | string
    destinationRetailPrice: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    InventoryItem_TransferItem_destinationInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_destinationInventoryIdToInventoryItemNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemsNestedInput
    InventoryItem_TransferItem_sourceInventoryIdToInventoryItem?: InventoryItemUpdateOneWithoutTransferItem_TransferItem_sourceInventoryIdToInventoryItemNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sourceInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    destinationInventoryId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedQuantity?: IntFieldUpdateOperationsInput | number
    approvedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    shippedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    receivedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    sourceCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sourceRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationCostPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationWholesalePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinationRetailPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyCustomerInput = {
    id?: string
    addressType?: string
    isDefault?: boolean
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    postalCode: string
    country: string
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNoteCreateManyCustomerInput = {
    id?: string
    note: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerToGroupCreateManyCustomerInput = {
    groupId: string
    createdAt?: Date | string
  }

  export type LoyaltyTransactionCreateManyCustomerInput = {
    id?: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type PromotionRedemptionCreateManyCustomerInput = {
    id: string
    promotionId: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    receiptNumber: string
    storeId: string
    createdById: string
    saleDate?: Date | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: number
    loyaltyPointsRedeemed?: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressType?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCustomerNoteNestedInput
  }

  export type CustomerNoteUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNoteUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerGroup?: CustomerGroupUpdateOneRequiredWithoutCustomerToGroupNestedInput
  }

  export type CustomerToGroupUncheckedUpdateWithoutCustomerInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupUncheckedUpdateManyWithoutCustomerInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput
    Sale?: SaleUpdateOneWithoutLoyaltyTransactionNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerPromotion?: CustomerPromotionUpdateOneRequiredWithoutPromotionRedemptionNestedInput
    Sale?: SaleUpdateOneRequiredWithoutPromotionRedemptionNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutSaleNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    LoyaltyTransaction?: LoyaltyTransactionUncheckedUpdateManyWithoutSaleNestedInput
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutSaleNestedInput
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPointsEarned?: IntFieldUpdateOperationsInput | number
    loyaltyPointsRedeemed?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPromotionCreateManyLoyaltyProgramInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.PromotionType
    discountValue: Decimal | DecimalJsLike | number | string
    isPercentage?: boolean
    code?: string | null
    minimumPurchase?: Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: $Enums.LoyaltyTier | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    usageLimit?: number | null
    usageCount?: number
    applicableProducts?: string | null
    applicableCategories?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LoyaltyProgramRuleCreateManyLoyaltyProgramInput = {
    id: string
    name: string
    description?: string | null
    type: $Enums.LoyaltyRuleType
    conditions?: string | null
    pointsAwarded: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LoyaltyProgramTierCreateManyProgramInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: Decimal | DecimalJsLike | number | string
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionCreateManyProgramInput = {
    id?: string
    customerId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
  }

  export type CustomerPromotionUpdateWithoutLoyaltyProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionRedemption?: PromotionRedemptionUpdateManyWithoutCustomerPromotionNestedInput
  }

  export type CustomerPromotionUncheckedUpdateWithoutLoyaltyProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionRedemption?: PromotionRedemptionUncheckedUpdateManyWithoutCustomerPromotionNestedInput
  }

  export type CustomerPromotionUncheckedUpdateManyWithoutLoyaltyProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromotionTypeFieldUpdateOperationsInput | $Enums.PromotionType
    discountValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPercentage?: BoolFieldUpdateOperationsInput | boolean
    code?: NullableStringFieldUpdateOperationsInput | string | null
    minimumPurchase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    requiredLoyaltyTier?: NullableEnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    applicableProducts?: NullableStringFieldUpdateOperationsInput | string | null
    applicableCategories?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramRuleUpdateWithoutLoyaltyProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramRuleUncheckedUpdateWithoutLoyaltyProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramRuleUncheckedUpdateManyWithoutLoyaltyProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLoyaltyRuleTypeFieldUpdateOperationsInput | $Enums.LoyaltyRuleType
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput
    Sale?: SaleUpdateOneWithoutLoyaltyTransactionNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentCreateManyAuditInput = {
    id?: string
    userId: string
    assignedZones?: string | null
    assignedAisles?: string | null
    assignedShelves?: string | null
    assignedBins?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateManyAuditInput = {
    id?: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    actualQuantity?: number | null
    variance?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditAssignmentsNestedInput
  }

  export type AuditAssignmentUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAisles?: NullableStringFieldUpdateOperationsInput | string | null
    assignedShelves?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBins?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    actualQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    variance?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupCreateManyCustomerGroupInput = {
    customerId: string
    createdAt?: Date | string
  }

  export type CustomerToGroupUpdateWithoutCustomerGroupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneRequiredWithoutCustomerToGroupNestedInput
  }

  export type CustomerToGroupUncheckedUpdateWithoutCustomerGroupInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerToGroupUncheckedUpdateManyWithoutCustomerGroupInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionCreateManyCustomerPromotionInput = {
    id: string
    customerId: string
    saleId: string
    discountAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PromotionRedemptionUpdateWithoutCustomerPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneRequiredWithoutPromotionRedemptionNestedInput
    Sale?: SaleUpdateOneRequiredWithoutPromotionRedemptionNestedInput
  }

  export type PromotionRedemptionUncheckedUpdateWithoutCustomerPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRedemptionUncheckedUpdateManyWithoutCustomerPromotionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}